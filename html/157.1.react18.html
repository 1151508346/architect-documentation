<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>珠峰架构师成长计划</title>
    <link rel="stylesheet" type="text/css" href="../static/css/main.css">
    <link rel="stylesheet" href="https://static.zhufengpeixun.com/bootstrapmin_1645176572503.css">
    <style>
        .page-toc > ul .red {
            background: #f3f3f3;
            z-index: 1;
            border-left: 3px solid #009a61;
            -webkit-transition: all .2s ease;
            transition: all .2s ease;
            color: #000
        }
    </style>
</head>
<body>
<div class="nav" style="height: 80.8px;">
    <div class="logo">
        
                    珠峰架构师成长计划
                        
                        </div>
                        <ul><li><a href="../index.html">0.api</a></li><li><a href="../html/0.Async.html">0.Async</a></li><li><a href="../html/0.module.html">0.module</a></li><li><a href="../html/1.ES2015.html">1.ES2015</a></li><li><a href="../html/2.Promise.html">2.Promise</a></li><li><a href="../html/3.Node.html">3.Node</a></li><li><a href="../html/4.NodeInstall.html">4.NodeInstall</a></li><li><a href="../html/5.REPL.html">5.REPL</a></li><li><a href="../html/6.NodeCore.html">6.NodeCore</a></li><li><a href="../html/7.module&amp;NPM.html">7.module&amp;NPM</a></li><li><a href="../html/8.Encoding.html">8.Encoding</a></li><li><a href="../html/9.Buffer.html">9.Buffer</a></li><li><a href="../html/10.fs.html">10.fs</a></li><li><a href="../html/11.Stream-1.html">11.Stream-1</a></li><li><a href="../html/11.Stream-2.html">11.Stream-2</a></li><li><a href="../html/11.Stream-3.html">11.Stream-3</a></li><li><a href="../html/11.Stream-4.html">11.Stream-4</a></li><li><a href="../html/12-Network-2.html">12-Network-2</a></li><li><a href="../html/12.NetWork-3.html">12.NetWork-3</a></li><li><a href="../html/12.Network-1.html">12.Network-1</a></li><li><a href="../html/13.tcp.html">13.tcp</a></li><li><a href="../html/14.http-1.html">14.http-1</a></li><li><a href="../html/14.http-2.html">14.http-2</a></li><li><a href="../html/15.compress.html">15.compress</a></li><li><a href="../html/16.crypto.html">16.crypto</a></li><li><a href="../html/17.process.html">17.process</a></li><li><a href="../html/18.yargs.html">18.yargs</a></li><li><a href="../html/19.cache.html">19.cache</a></li><li><a href="../html/20.action.html">20.action</a></li><li><a href="../html/21.https.html">21.https</a></li><li><a href="../html/22.cookie.html">22.cookie</a></li><li><a href="../html/23.session.html">23.session</a></li><li><a href="../html/24.express-1.html">24.express-1</a></li><li><a href="../html/24.express-2.html">24.express-2</a></li><li><a href="../html/24.express-3.html">24.express-3</a></li><li><a href="../html/24.express-4.html">24.express-4</a></li><li><a href="../html/25.koa-1.html">25.koa-1</a></li><li><a href="../html/26.webpack-1-basic.html">26.webpack-1-basic</a></li><li><a href="../html/26.webpack-2-optimize.html">26.webpack-2-optimize</a></li><li><a href="../html/26.webpack-3-file.html">26.webpack-3-file</a></li><li><a href="../html/26.webpack-4.tapable.html">26.webpack-4.tapable</a></li><li><a href="../html/26.webpack-5-AST.html">26.webpack-5-AST</a></li><li><a href="../html/26.webpack-6-sources.html">26.webpack-6-sources</a></li><li><a href="../html/26.webpack-7-loader.html">26.webpack-7-loader</a></li><li><a href="../html/26.webpack-8-plugin.html">26.webpack-8-plugin</a></li><li><a href="../html/26.webpack-9-hand.html">26.webpack-9-hand</a></li><li><a href="../html/26.webpack-10-prepare.html">26.webpack-10-prepare</a></li><li><a href="../html/28.redux.html">28.redux</a></li><li><a href="../html/28.redux-jwt-back.html">28.redux-jwt-back</a></li><li><a href="../html/28.redux-jwt-front.html">28.redux-jwt-front</a></li><li><a href="../html/29.mongodb-1.html">29.mongodb-1</a></li><li><a href="../html/29.mongodb-2.html">29.mongodb-2</a></li><li><a href="../html/29.mongodb-3.html">29.mongodb-3</a></li><li><a href="../html/29.mongodb-4.html">29.mongodb-4</a></li><li><a href="../html/29.mongodb-5.html">29.mongodb-5</a></li><li><a href="../html/29.mongodb-6.html">29.mongodb-6</a></li><li><a href="../html/30.cms-1-mysql.html">30.cms-1-mysql</a></li><li><a href="../html/30.cms-2-mysql.html">30.cms-2-mysql</a></li><li><a href="../html/30.cms-3-mysql.html">30.cms-3-mysql</a></li><li><a href="../html/30.cms-4-nunjucks.html">30.cms-4-nunjucks</a></li><li><a href="../html/30.cms-5-mock.html">30.cms-5-mock</a></li><li><a href="../html/30.cms-6-egg.html">30.cms-6-egg</a></li><li><a href="../html/30.cms-7-api.html">30.cms-7-api</a></li><li><a href="../html/30.cms-8-roadhog.html">30.cms-8-roadhog</a></li><li><a href="../html/30.cms-9-yaml.html">30.cms-9-yaml</a></li><li><a href="../html/30.cms-10-umi.html">30.cms-10-umi</a></li><li><a href="../html/30.cms-12-dva.html">30.cms-12-dva</a></li><li><a href="../html/30.cms-13-dva-ant.html">30.cms-13-dva-ant</a></li><li><a href="../html/30.cms-14-front.html">30.cms-14-front</a></li><li><a href="../html/30.cms-15-deploy.html">30.cms-15-deploy</a></li><li><a href="../html/31.dva.html">31.dva</a></li><li><a href="../html/31.cms-13-dva-antdesign.html">31.cms-13-dva-antdesign</a></li><li><a href="../html/33.redis.html">33.redis</a></li><li><a href="../html/34.unittest.html">34.unittest</a></li><li><a href="../html/35.jwt.html">35.jwt</a></li><li><a href="../html/36.websocket-1.html">36.websocket-1</a></li><li><a href="../html/36.websocket-2.html">36.websocket-2</a></li><li><a href="../html/38.chat-api-1.html">38.chat-api-1</a></li><li><a href="../html/38.chat-api-2.html">38.chat-api-2</a></li><li><a href="../html/38.chat-3.html">38.chat-3</a></li><li><a href="../html/38.chat-api-3.html">38.chat-api-3</a></li><li><a href="../html/38.chat.html">38.chat</a></li><li><a href="../html/38.chat2.html">38.chat2</a></li><li><a href="../html/38.chat2.html">38.chat2</a></li><li><a href="../html/39.crawl-0.html">39.crawl-0</a></li><li><a href="../html/39.crawl-1.html">39.crawl-1</a></li><li><a href="../html/39.crawl-2.html">39.crawl-2</a></li><li><a href="../html/40.deploy.html">40.deploy</a></li><li><a href="../html/41.safe.html">41.safe</a></li><li><a href="../html/42.test.html">42.test</a></li><li><a href="../html/43.nginx.html">43.nginx</a></li><li><a href="../html/44.enzyme.html">44.enzyme</a></li><li><a href="../html/45.docker.html">45.docker</a></li><li><a href="../html/46.elastic.html">46.elastic</a></li><li><a href="../html/47.oauth.html">47.oauth</a></li><li><a href="../html/48.wxpay.html">48.wxpay</a></li><li><a href="../html/index.html">index</a></li><li><a href="../html/52.UML.html">52.UML</a></li><li><a href="../html/53.design.html">53.design</a></li><li><a href="../html/index.html">index</a></li><li><a href="../html/54.linux.html">54.linux</a></li><li><a href="../html/57.ts.html">57.ts</a></li><li><a href="../html/56.react-ssr.html">56.react-ssr</a></li><li><a href="../html/58.ts_react.html">58.ts_react</a></li><li><a href="../html/59.ketang.html">59.ketang</a></li><li><a href="../html/59.ketang2.html">59.ketang2</a></li><li><a href="../html/61.1.devops-linux.html">61.1.devops-linux</a></li><li><a href="../html/61.2.devops-vi.html">61.2.devops-vi</a></li><li><a href="../html/61.3.devops-user.html">61.3.devops-user</a></li><li><a href="../html/61.4.devops-auth.html">61.4.devops-auth</a></li><li><a href="../html/61.5.devops-shell.html">61.5.devops-shell</a></li><li><a href="../html/61.6.devops-install.html">61.6.devops-install</a></li><li><a href="../html/61.7.devops-system.html">61.7.devops-system</a></li><li><a href="../html/61.8.devops-service.html">61.8.devops-service</a></li><li><a href="../html/61.9.devops-network.html">61.9.devops-network</a></li><li><a href="../html/61.10.devops-nginx.html">61.10.devops-nginx</a></li><li><a href="../html/61.11.devops-docker.html">61.11.devops-docker</a></li><li><a href="../html/61.12.devops-jekins.html">61.12.devops-jekins</a></li><li><a href="../html/61.13.devops-groovy.html">61.13.devops-groovy</a></li><li><a href="../html/61.14.devops-php.html">61.14.devops-php</a></li><li><a href="../html/61.15.devops-java.html">61.15.devops-java</a></li><li><a href="../html/61.16.devops-node.html">61.16.devops-node</a></li><li><a href="../html/61.17.devops-k8s.html">61.17.devops-k8s</a></li><li><a href="../html/62.1.react-basic.html">62.1.react-basic</a></li><li><a href="../html/62.2.react-state.html">62.2.react-state</a></li><li><a href="../html/62.3.react-high.html">62.3.react-high</a></li><li><a href="../html/62.4.react-optimize.html">62.4.react-optimize</a></li><li><a href="../html/62.5.react-hooks.html">62.5.react-hooks</a></li><li><a href="../html/62.6.react-immutable.html">62.6.react-immutable</a></li><li><a href="../html/62.7.react-mobx.html">62.7.react-mobx</a></li><li><a href="../html/62.8.react-source.html">62.8.react-source</a></li><li><a href="../html/63.1.redux.html">63.1.redux</a></li><li><a href="../html/63.2.redux-middleware.html">63.2.redux-middleware</a></li><li><a href="../html/63.3.redux-hooks.html">63.3.redux-hooks</a></li><li><a href="../html/63.4.redux-saga.html">63.4.redux-saga</a></li><li><a href="../html/63.5.redux-saga-hand.html">63.5.redux-saga-hand</a></li><li><a href="../html/64.1.router.html">64.1.router</a></li><li><a href="../html/64.2.router-connected.html">64.2.router-connected</a></li><li><a href="../html/65.1.typescript.html">65.1.typescript</a></li><li><a href="../html/65.2.typescript.html">65.2.typescript</a></li><li><a href="../html/65.3.typescript.html">65.3.typescript</a></li><li><a href="../html/65.4.antd.html">65.4.antd</a></li><li><a href="../html/65.4.definition.html">65.4.definition</a></li><li><a href="../html/66-1.vue-base.html">66-1.vue-base</a></li><li><a href="../html/66-2.vue-component.html">66-2.vue-component</a></li><li><a href="../html/66-3.vue-cli3.0.html">66-3.vue-cli3.0</a></li><li><a href="../html/66-4.$message组件.html">66-4.$message组件</a></li><li><a href="../html/66-5.Form组件.html">66-5.Form组件</a></li><li><a href="../html/66-6.tree.html">66-6.tree</a></li><li><a href="../html/66-7.vue-router-apply.html">66-7.vue-router-apply</a></li><li><a href="../html/66-8.axios-apply.html">66-8.axios-apply</a></li><li><a href="../html/66-9.vuex-apply.html">66-9.vuex-apply</a></li><li><a href="../html/66-10.jwt-vue.html">66-10.jwt-vue</a></li><li><a href="../html/66-11.vue-ssr.html">66-11.vue-ssr</a></li><li><a href="../html/66-12.nuxt-apply.html">66-12.nuxt-apply</a></li><li><a href="../html/66-13.pwa.html">66-13.pwa</a></li><li><a href="../html/66-14.vue单元测试.html">66-14.vue单元测试</a></li><li><a href="../html/66-15.权限校验.html">66-15.权限校验</a></li><li><a href="../html/67-1-network.html">67-1-network</a></li><li><a href="../html/68-2-wireshark.html">68-2-wireshark</a></li><li><a href="../html/7.npm2.html">7.npm2</a></li><li><a href="../html/69-hooks.html">69-hooks</a></li><li><a href="../html/70-deploy.html">70-deploy</a></li><li><a href="../html/71-hmr.html">71-hmr</a></li><li><a href="../html/72.deploy.html">72.deploy</a></li><li><a href="../html/73.import.html">73.import</a></li><li><a href="../html/74.mobile.html">74.mobile</a></li><li><a href="../html/75.webpack-1.文件分析.html">75.webpack-1.文件分析</a></li><li><a href="../html/75.webpack-2.loader.html">75.webpack-2.loader</a></li><li><a href="../html/75.webpack-3.源码流程.html">75.webpack-3.源码流程</a></li><li><a href="../html/75.webpack-4.tapable.html">75.webpack-4.tapable</a></li><li><a href="../html/75.webpack-5.prepare.html">75.webpack-5.prepare</a></li><li><a href="../html/75.webpack-6.resolve.html">75.webpack-6.resolve</a></li><li><a href="../html/75.webpack-7.loader.html">75.webpack-7.loader</a></li><li><a href="../html/75.webpack-8.module.html">75.webpack-8.module</a></li><li><a href="../html/75.webpack-9.chunk.html">75.webpack-9.chunk</a></li><li><a href="../html/75.webpack-10.asset.html">75.webpack-10.asset</a></li><li><a href="../html/75.webpack-11.实现.html">75.webpack-11.实现</a></li><li><a href="../html/76.react_optimize.html">76.react_optimize</a></li><li><a href="../html/77.ts_ketang_back.html">77.ts_ketang_back</a></li><li><a href="../html/77.ts_ketang_front.html">77.ts_ketang_front</a></li><li><a href="../html/78.vue-domdiff.html">78.vue-domdiff</a></li><li><a href="../html/79.grammar.html">79.grammar</a></li><li><a href="../html/80.tree.html">80.tree</a></li><li><a href="../html/81.axios.html">81.axios</a></li><li><a href="../html/82.1.react.html">82.1.react</a></li><li><a href="../html/82.2.react-high.html">82.2.react-high</a></li><li><a href="../html/82.3.react-router.html">82.3.react-router</a></li><li><a href="../html/82.4.redux.html">82.4.redux</a></li><li><a href="../html/82.5.redux_middleware.html">82.5.redux_middleware</a></li><li><a href="../html/82.6.connected.html">82.6.connected</a></li><li><a href="../html/82.7.saga.html">82.7.saga</a></li><li><a href="../html/82.8.dva.html">82.8.dva</a></li><li><a href="../html/82.8.dva-source.html">82.8.dva-source</a></li><li><a href="../html/82.9.roadhog.html">82.9.roadhog</a></li><li><a href="../html/82.10.umi.html">82.10.umi</a></li><li><a href="../html/82.11.antdesign.html">82.11.antdesign</a></li><li><a href="../html/82.12.ketang-front.html">82.12.ketang-front</a></li><li><a href="../html/82.12.ketang-back.html">82.12.ketang-back</a></li><li><a href="../html/83.upload.html">83.upload</a></li><li><a href="../html/84.graphql.html">84.graphql</a></li><li><a href="../html/85.antpro.html">85.antpro</a></li><li><a href="../html/86.1.uml.html">86.1.uml</a></li><li><a href="../html/86.2.design.html">86.2.design</a></li><li><a href="../html/87.postcss.html">87.postcss</a></li><li><a href="../html/88.react16-1.html">88.react16-1</a></li><li><a href="../html/89.nextjs.html">89.nextjs</a></li><li><a href="../html/90.react-test.html">90.react-test</a></li><li><a href="../html/91.react-ts.html">91.react-ts</a></li><li><a href="../html/92.rbac.html">92.rbac</a></li><li><a href="../html/93.tsnode.html">93.tsnode</a></li><li><a href="../html/94.1.JavaScript.html">94.1.JavaScript</a></li><li><a href="../html/94.2.JavaScript.html">94.2.JavaScript</a></li><li><a href="../html/94.3.MODULE.html">94.3.MODULE</a></li><li><a href="../html/94.4.EventLoop.html">94.4.EventLoop</a></li><li><a href="../html/94.5.文件上传.html">94.5.文件上传</a></li><li><a href="../html/94.6.https.html">94.6.https</a></li><li><a href="../html/94.7. nginx.html">94.7. nginx</a></li><li><a href="../html/95.1. react.html">95.1. react</a></li><li><a href="../html/95.2.react.html">95.2.react</a></li><li><a href="../html/96.1.react16.html">96.1.react16</a></li><li><a href="../html/96.2.fiber.html">96.2.fiber</a></li><li><a href="../html/96.3.fiber.html">96.3.fiber</a></li><li><a href="../html/97.serverless.html">97.serverless</a></li><li><a href="../html/98.websocket.html">98.websocket</a></li><li><a href="../html/100.1.react-basic.html">100.1.react-basic</a></li><li><a href="../html/101.1.monitor.html">101.1.monitor</a></li><li><a href="../html/101.2.monitor.html">101.2.monitor</a></li><li><a href="../html/102.java.html">102.java</a></li><li><a href="../html/103.1.webpack-usage.html">103.1.webpack-usage</a></li><li><a href="../html/103.2.webpack-bundle.html">103.2.webpack-bundle</a></li><li><a href="../html/103.3.webpack-ast.html">103.3.webpack-ast</a></li><li><a href="../html/103.4.webpack-flow.html">103.4.webpack-flow</a></li><li><a href="../html/103.5.webpack-loader.html">103.5.webpack-loader</a></li><li><a href="../html/103.6.webpack-tapable.html">103.6.webpack-tapable</a></li><li><a href="../html/103.7.webpack-plugin.html">103.7.webpack-plugin</a></li><li><a href="../html/103.8.webpack-optimize1.html">103.8.webpack-optimize1</a></li><li><a href="../html/103.9.webpack-optimize2.html">103.9.webpack-optimize2</a></li><li><a href="../html/103.10.webpack-hand.html">103.10.webpack-hand</a></li><li><a href="../html/103.11.webpack-hmr.html">103.11.webpack-hmr</a></li><li><a href="../html/103.11.webpack5.html">103.11.webpack5</a></li><li><a href="../html/103.13.splitChunks.html">103.13.splitChunks</a></li><li><a href="../html/103.14.webpack-sourcemap.html">103.14.webpack-sourcemap</a></li><li><a href="../html/103.15.webpack-compiler1.html">103.15.webpack-compiler1</a></li><li><a href="../html/103.15.webpack-compiler2.html">103.15.webpack-compiler2</a></li><li><a href="../html/103.16.rollup.1.html">103.16.rollup.1</a></li><li><a href="../html/103.16.rollup.2.html">103.16.rollup.2</a></li><li><a href="../html/103.16.rollup.3.html">103.16.rollup.3</a></li><li><a href="../html/103.16.vite.basic.html">103.16.vite.basic</a></li><li><a href="../html/103.16.vite.source.html">103.16.vite.source</a></li><li><a href="../html/103.16.vite.plugin.html">103.16.vite.plugin</a></li><li><a href="../html/103.16.vite.1.html">103.16.vite.1</a></li><li><a href="../html/103.16.vite.2.html">103.16.vite.2</a></li><li><a href="../html/103.17.polyfill.html">103.17.polyfill</a></li><li><a href="../html/104.1.binary.html">104.1.binary</a></li><li><a href="../html/104.2.binary.html">104.2.binary</a></li><li><a href="../html/105.skeleton.html">105.skeleton</a></li><li><a href="../html/106.1.react.html">106.1.react</a></li><li><a href="../html/106.2.react_hooks.html">106.2.react_hooks</a></li><li><a href="../html/106.3.react_router.html">106.3.react_router</a></li><li><a href="../html/106.4.redux.html">106.4.redux</a></li><li><a href="../html/106.5.redux_middleware.html">106.5.redux_middleware</a></li><li><a href="../html/106.6.connected-react-router.html">106.6.connected-react-router</a></li><li><a href="../html/106.6.redux-first-history.html">106.6.redux-first-history</a></li><li><a href="../html/106.7.redux-saga.html">106.7.redux-saga</a></li><li><a href="../html/106.8.dva.html">106.8.dva</a></li><li><a href="../html/106.9.umi.html">106.9.umi</a></li><li><a href="../html/106.10.ketang.html">106.10.ketang</a></li><li><a href="../html/106.11.antdesign.html">106.11.antdesign</a></li><li><a href="../html/106.12.antpro.html">106.12.antpro</a></li><li><a href="../html/106.13.router-6.html">106.13.router-6</a></li><li><a href="../html/106.14.ssr.html">106.14.ssr</a></li><li><a href="../html/106.15.nextjs.html">106.15.nextjs</a></li><li><a href="../html/106.16.1.cms.html">106.16.1.cms</a></li><li><a href="../html/106.16.2.cms.html">106.16.2.cms</a></li><li><a href="../html/106.16.3.cms.html">106.16.3.cms</a></li><li><a href="../html/106.16.4.cms.html">106.16.4.cms</a></li><li><a href="../html/106.16.mobx.html">106.16.mobx</a></li><li><a href="../html/106.17.fomily.html">106.17.fomily</a></li><li><a href="../html/107.fiber.html">107.fiber</a></li><li><a href="../html/108.http.html">108.http</a></li><li><a href="../html/109.1.webpack_usage.html">109.1.webpack_usage</a></li><li><a href="../html/109.2.webpack_source.html">109.2.webpack_source</a></li><li><a href="../html/109.3.dll.html">109.3.dll</a></li><li><a href="../html/110.nest.js.html">110.nest.js</a></li><li><a href="../html/111.xstate.html">111.xstate</a></li><li><a href="../html/112.Form.html">112.Form</a></li><li><a href="../html/113.redux-saga.html">113.redux-saga</a></li><li><a href="../html/114.react+typescript.html">114.react+typescript</a></li><li><a href="../html/115.immer.html">115.immer</a></li><li><a href="../html/116.pro5.html">116.pro5</a></li><li><a href="../html/117.css-loader.html">117.css-loader</a></li><li><a href="../html/118.1.umi-core.html">118.1.umi-core</a></li><li><a href="../html/119.2.module-federation.html">119.2.module-federation</a></li><li><a href="../html/119.1.module-federation.html">119.1.module-federation</a></li><li><a href="../html/120.create-react-app.html">120.create-react-app</a></li><li><a href="../html/121.react-scripts.html">121.react-scripts</a></li><li><a href="../html/122.react-optimize.html">122.react-optimize</a></li><li><a href="../html/123.jsx-runtime.html">123.jsx-runtime</a></li><li><a href="../html/124.next.js.html">124.next.js</a></li><li><a href="../html/125.1.linux.html">125.1.linux</a></li><li><a href="../html/125.2.linux-vi.html">125.2.linux-vi</a></li><li><a href="../html/125.3.linux-user.html">125.3.linux-user</a></li><li><a href="../html/125.4.linux-auth.html">125.4.linux-auth</a></li><li><a href="../html/125.5.linux-shell.html">125.5.linux-shell</a></li><li><a href="../html/125.6.linux-install.html">125.6.linux-install</a></li><li><a href="../html/125.7.linux-system.html">125.7.linux-system</a></li><li><a href="../html/125.8.linux-service.html">125.8.linux-service</a></li><li><a href="../html/125.9.linux-network.html">125.9.linux-network</a></li><li><a href="../html/125.10.nginx.html">125.10.nginx</a></li><li><a href="../html/125.11.docker.html">125.11.docker</a></li><li><a href="../html/125.12.ci.html">125.12.ci</a></li><li><a href="../html/125.13.k8s.html">125.13.k8s</a></li><li><a href="../html/125.14.k8s.html">125.14.k8s</a></li><li><a href="../html/125.15.k8s.html">125.15.k8s</a></li><li><a href="../html/125.16.k8s.html">125.16.k8s</a></li><li><a href="../html/126.11.react-1.html">126.11.react-1</a></li><li><a href="../html/126.12.react-2.html">126.12.react-2</a></li><li><a href="../html/126.12.react-3.html">126.12.react-3</a></li><li><a href="../html/126.12.react-4.html">126.12.react-4</a></li><li><a href="../html/126.12.react-5.html">126.12.react-5</a></li><li><a href="../html/126.12.react-6.html">126.12.react-6</a></li><li><a href="../html/126.12.react-7.html">126.12.react-7</a></li><li><a href="../html/126.12.react-8.html">126.12.react-8</a></li><li><a href="../html/127.frontend.html">127.frontend</a></li><li><a href="../html/128.rollup.html">128.rollup</a></li><li><a href="../html/129.px2rem-loader.html">129.px2rem-loader</a></li><li><a href="../html/130.health.html">130.health</a></li><li><a href="../html/131.hooks.html">131.hooks</a></li><li><a href="../html/132.keepalive.html">132.keepalive</a></li><li><a href="../html/133.vue-cli.html">133.vue-cli</a></li><li><a href="../html/134.react18.html">134.react18</a></li><li><a href="../html/134.2.react18.html">134.2.react18</a></li><li><a href="../html/134.3.react18.html">134.3.react18</a></li><li><a href="../html/135.function.html">135.function</a></li><li><a href="../html/136.toolkit.html">136.toolkit</a></li><li><a href="../html/137.lerna.html">137.lerna</a></li><li><a href="../html/138.create-vite.html">138.create-vite</a></li><li><a href="../html/139.cli.html">139.cli</a></li><li><a href="../html/140.antd.html">140.antd</a></li><li><a href="../html/141.react-dnd.html">141.react-dnd</a></li><li><a href="../html/142.1.link.html">142.1.link</a></li><li><a href="../html/143.1.gulp.html">143.1.gulp</a></li><li><a href="../html/143.2.stream.html">143.2.stream</a></li><li><a href="../html/143.3.gulp.html">143.3.gulp</a></li><li><a href="../html/144.1.closure.html">144.1.closure</a></li><li><a href="../html/144.2.v8.html">144.2.v8</a></li><li><a href="../html/144.3.gc.html">144.3.gc</a></li><li><a href="../html/145.react-router-v6.html">145.react-router-v6</a></li><li><a href="../html/146.browser.html">146.browser</a></li><li><a href="../html/147.lighthouse.html">147.lighthouse</a></li><li><a href="../html/148.1.basic.html">148.1.basic</a></li><li><a href="../html/148.2.basic .html">148.2.basic </a></li><li><a href="../html/148.3.basic.html">148.3.basic</a></li><li><a href="../html/148.4.basic.html">148.4.basic</a></li><li><a href="../html/148.5.basic.html">148.5.basic</a></li><li><a href="../html/149.1.vite.html">149.1.vite</a></li><li><a href="../html/149.2.vite.html">149.2.vite</a></li><li><a href="../html/149.3.vite.html">149.3.vite</a></li><li><a href="../html/149.4.vite.html">149.4.vite</a></li><li><a href="../html/150.react-window.html">150.react-window</a></li><li><a href="../html/151.react-query.html">151.react-query</a></li><li><a href="../html/152.useRequest.html">152.useRequest</a></li><li><a href="../html/153.transition.html">153.transition</a></li><li><a href="../html/154.emotion.html">154.emotion</a></li><li><a href="../html/155.1.formily.html">155.1.formily</a></li><li><a href="../html/155.2.formily.html">155.2.formily</a></li><li><a href="../html/155.3.formily.html">155.3.formily</a></li><li><a href="../html/155.3.1.mobx.usage.html">155.3.1.mobx.usage</a></li><li><a href="../html/155.3.2.mobx.source.html">155.3.2.mobx.source</a></li><li><a href="../html/156.vue-loader.html">156.vue-loader</a></li><li><a href="../html/103.11.mf.html">103.11.mf</a></li><li class="active"><a href="../html/157.1.react18.html">157.1.react18</a></li><li><a href="../html/158.umi4.html">158.umi4</a></li><li><a href="../html/159.rxjs.html">159.rxjs</a></li><li><a href="../html/159.rxjs2.html">159.rxjs2</a></li><li><a href="../html/160.bff.html">160.bff</a></li><li><a href="../html/161.zustand.html">161.zustand</a></li><li><a href="../html/162.vscode.html">162.vscode</a></li><li><a href="../html/163.emp.html">163.emp</a></li></ul>                        </div>

                        
  <div class="warpper">
    <div class="page-toc">
      <ul><li><a href="#t01.React 前置知识">1.React 前置知识</a><ul><li><a href="#t11.1 React 是什么?">1.1 React 是什么?</a></li><li><a href="#t21.2 JSX 是什么">1.2 JSX 是什么</a><ul><li><a href="#t31.2.1 旧转换">1.2.1 旧转换</a><ul><li><a href="#t41.2.1.1 jsx.js">1.2.1.1 jsx.js</a></li><li><a href="#t51.2.1.2 转译结果">1.2.1.2 转译结果</a></li></ul></li><li><a href="#t61.2.2 新转换">1.2.2 新转换</a><ul><li><a href="#t71.2.2.1 jsx.js">1.2.2.1 jsx.js</a></li><li><a href="#t81.2.2.2 转译结果">1.2.2.2 转译结果</a></li></ul></li></ul></li><li><a href="#t91.3 Virtual DOM">1.3 Virtual DOM</a></li><li><a href="#t101.4 链表">1.4 链表</a><ul><li><a href="#t111.4.1 链表分类">1.4.1 链表分类</a><ul><li><a href="#t121.4.1.1 单向链表">1.4.1.1 单向链表</a></li><li><a href="#t131.4.1.2 双向链表">1.4.1.2 双向链表</a></li><li><a href="#t141.4.1.3 循环链表">1.4.1.3 循环链表</a></li><li><a href="#t151.4.1.4 示例">1.4.1.4 示例</a></li></ul></li></ul></li><li><a href="#t161.5 fiber">1.5 fiber</a><ul><li><a href="#t171.5.1 性能瓶颈">1.5.1 性能瓶颈</a></li><li><a href="#t181.5.2 屏幕刷新率">1.5.2 屏幕刷新率</a></li><li><a href="#t191.5.3 帧">1.5.3 帧</a></li><li><a href="#t201.5.4 requestIdleCallback">1.5.4 requestIdleCallback</a></li><li><a href="#t211.5.5 fiber">1.5.5 fiber</a><ul><li><a href="#t221.5.5.1 Fiber 是一个执行单元">1.5.5.1 Fiber 是一个执行单元</a></li><li><a href="#t231.5.5.2 Fiber 是一种数据结构">1.5.5.2 Fiber 是一种数据结构</a></li><li><a href="#t241.5.5.3 递归构建 fiber 树">1.5.5.3 递归构建 fiber 树</a></li></ul></li></ul></li><li><a href="#t251.6 树的遍历">1.6 树的遍历</a><ul><li><a href="#t261.6.1 深度优先(DFS)">1.6.1 深度优先(DFS)</a></li><li><a href="#t271.6.2 广度优先(BFS)">1.6.2 广度优先(BFS)</a></li><li><a href="#t281.6.3 栈">1.6.3 栈</a></li></ul></li><li><a href="#t291.7 位运算">1.7 位运算</a><ul><li><a href="#t301.7.1 比特">1.7.1 比特</a></li><li><a href="#t311.7.2 位运算">1.7.2 位运算</a></li><li><a href="#t321.7.3 使用">1.7.3 使用</a></li></ul></li><li><a href="#t331.8 事件">1.8 事件</a><ul><li><a href="#t341.8.1 DOM 事件流">1.8.1 DOM 事件流</a></li><li><a href="#t351.8.2 事件捕获">1.8.2 事件捕获</a></li><li><a href="#t361.8.3 目标阶段">1.8.3 目标阶段</a></li><li><a href="#t371.8.4 事件冒泡">1.8.4 事件冒泡</a></li><li><a href="#t381.8.5 addEventListener">1.8.5 addEventListener</a></li><li><a href="#t391.8.6 阻止冒泡">1.8.6 阻止冒泡</a></li><li><a href="#t401.8.7 阻止默认行为">1.8.7 阻止默认行为</a></li><li><a href="#t411.8.8 事件代理">1.8.8 事件代理</a></li><li><a href="#t421.8.9 事件系统">1.8.9 事件系统</a><ul><li><a href="#t431.8.10.1 使用">1.8.10.1 使用</a></li><li><a href="#t441.8.10.2 简易实现">1.8.10.2 简易实现</a></li></ul></li></ul></li><li><a href="#t451.9 最小堆">1.9 最小堆</a><ul><li><a href="#t461.9.1 二叉树">1.9.1 二叉树</a></li><li><a href="#t471.9.2 满二叉树">1.9.2 满二叉树</a></li><li><a href="#t481.9.3 完全二叉树">1.9.3 完全二叉树</a></li><li><a href="#t491.9.4 最小堆">1.9.4 最小堆</a></li><li><a href="#t501.9.5 SchedulerMinHeap.js">1.9.5 SchedulerMinHeap.js</a></li></ul></li><li><a href="#t511.10 MessageChannel">1.10 MessageChannel</a></li><li><a href="#t521.11 二进制">1.11 二进制</a><ul><li><a href="#t531.11.1 ES5规范">1.11.1 ES5规范</a></li><li><a href="#t541.11.2 真值">1.11.2 真值</a></li><li><a href="#t551.11.3 原码">1.11.3 原码</a></li><li><a href="#t561.11.4 反码">1.11.4 反码</a></li><li><a href="#t571.11.5 补码">1.11.5 补码</a></li><li><a href="#t581.11.6 二进制数整数">1.11.6 二进制数整数</a></li><li><a href="#t591.11.7 ~非">1.11.7 ~非</a></li><li><a href="#t601.11.8 getHighestPriorityLane">1.11.8 getHighestPriorityLane</a></li><li><a href="#t611.11.9 左移">1.11.9 左移</a></li><li><a href="#t621.11.10 >> 有符号右移">1.11.10 &gt;&gt; 有符号右移</a></li><li><a href="#t631.11.11 >>>无符号右移">1.11.11 &gt;&gt;&gt;无符号右移</a></li></ul></li><li><a href="#t641.12 更新优先级">1.12 更新优先级</a><ul><li><a href="#t651.12.1 lane">1.12.1 lane</a></li><li><a href="#t661.12.2 Hydration">1.12.2 Hydration</a></li><li><a href="#t671.12.3 ReactFiberLane.js">1.12.3 ReactFiberLane.js</a></li><li><a href="#t681.12.4 ReactUpdateQueue.js">1.12.4 ReactUpdateQueue.js</a></li><li><a href="#t691.12.5 processUpdateQueue.js">1.12.5 processUpdateQueue.js</a></li></ul></li></ul></li><li><a href="#t702.创建项目">2.创建项目</a><ul><li><a href="#t712.1 创建目录">2.1 创建目录</a></li><li><a href="#t722.2 安装">2.2 安装</a></li><li><a href="#t732.3 vite.config.js">2.3 vite.config.js</a></li><li><a href="#t742.4 jsconfig.json">2.4 jsconfig.json</a></li><li><a href="#t752.5 main.jsx">2.5 main.jsx</a></li><li><a href="#t762.6 index.html">2.6 index.html</a></li><li><a href="#t772.7 package.json">2.7 package.json</a></li></ul></li><li><a href="#t783.实现虚拟 DOM">3.实现虚拟 DOM</a><ul><li><a href="#t793.1 main.jsx">3.1 main.jsx</a></li><li><a href="#t803.2 jsx-dev-runtime.js">3.2 jsx-dev-runtime.js</a></li><li><a href="#t813.3 ReactJSXElement.js">3.3 ReactJSXElement.js</a></li><li><a href="#t823.4 ReactSymbols.js">3.4 ReactSymbols.js</a></li><li><a href="#t833.5 hasOwnProperty.js">3.5 hasOwnProperty.js</a></li></ul></li><li><a href="#t844.创建 ReactDOMRoot">4.创建 ReactDOMRoot</a><ul><li><a href="#t854.1 main.jsx">4.1 main.jsx</a></li><li><a href="#t864.2 client.js">4.2 client.js</a></li><li><a href="#t874.3 ReactDOMRoot.js">4.3 ReactDOMRoot.js</a></li><li><a href="#t884.4 ReactFiberReconciler.js">4.4 ReactFiberReconciler.js</a></li><li><a href="#t894.5 ReactFiberRoot.js">4.5 ReactFiberRoot.js</a></li></ul></li><li><a href="#t905.创建 RootFiber">5.创建 RootFiber</a><ul><li><a href="#t915.1 ReactFiberRoot.js">5.1 ReactFiberRoot.js</a></li><li><a href="#t925.2 ReactFiber.js">5.2 ReactFiber.js</a></li><li><a href="#t935.3 ReactWorkTags.js">5.3 ReactWorkTags.js</a></li><li><a href="#t945.4 ReactFiberFlags.js">5.4 ReactFiberFlags.js</a></li></ul></li><li><a href="#t956.初始化 UpdateQueue">6.初始化 UpdateQueue</a><ul><li><a href="#t966.1 ReactFiberRoot.js">6.1 ReactFiberRoot.js</a></li><li><a href="#t976.2 ReactFiberClassUpdateQueue.js">6.2 ReactFiberClassUpdateQueue.js</a></li></ul></li><li><a href="#t987. enqueueUpdate">7. enqueueUpdate</a><ul><li><a href="#t997.1 main.jsx">7.1 main.jsx</a></li><li><a href="#t1007.2 ReactDOMRoot.js">7.2 ReactDOMRoot.js</a></li><li><a href="#t1017.3 ReactFiberReconciler.js">7.3 ReactFiberReconciler.js</a></li><li><a href="#t1027.4 ReactFiberClassUpdateQueue.js">7.4 ReactFiberClassUpdateQueue.js</a></li><li><a href="#t1037.5 ReactFiberConcurrentUpdates.js">7.5 ReactFiberConcurrentUpdates.js</a></li></ul></li><li><a href="#t1048.performConcurrentWorkOnRoot">8.performConcurrentWorkOnRoot</a><ul><li><a href="#t1058.1 ReactFiberReconciler.js">8.1 ReactFiberReconciler.js</a></li><li><a href="#t1068.2 ReactFiberWorkLoop.js">8.2 ReactFiberWorkLoop.js</a></li><li><a href="#t1078.3 scheduler\index.js">8.3 scheduler\index.js</a></li><li><a href="#t1088.4 Scheduler.js">8.4 Scheduler.js</a></li></ul></li><li><a href="#t1099.prepareFreshStack">9.prepareFreshStack</a><ul><li><a href="#t1109.1 ReactFiberWorkLoop.js">9.1 ReactFiberWorkLoop.js</a></li><li><a href="#t1119.2 ReactFiber.js">9.2 ReactFiber.js</a></li></ul></li><li><a href="#t11210.beginWork">10.beginWork</a><ul><li><a href="#t11310.1 ReactFiberWorkLoop.js">10.1 ReactFiberWorkLoop.js</a></li><li><a href="#t11410.2 ReactFiberBeginWork.js">10.2 ReactFiberBeginWork.js</a></li><li><a href="#t11510.3 ReactWorkTags.js">10.3 ReactWorkTags.js</a></li><li><a href="#t11610.4 ReactFiberClassUpdateQueue.js">10.4 ReactFiberClassUpdateQueue.js</a></li><li><a href="#t11710.5 ReactChildFiber.js">10.5 ReactChildFiber.js</a></li><li><a href="#t11810.6 ReactDOMHostConfig.js">10.6 ReactDOMHostConfig.js</a></li><li><a href="#t11910.7 logger.js">10.7 logger.js</a></li><li><a href="#t12010.8 assign.js">10.8 assign.js</a></li><li><a href="#t12110.9 isArray.js">10.9 isArray.js</a></li><li><a href="#t12210.10 ReactFiber.js">10.10 ReactFiber.js</a></li><li><a href="#t12310.11 ReactFiberFlags.js">10.11 ReactFiberFlags.js</a></li></ul></li><li><a href="#t12411.completeUnitOfWork">11.completeUnitOfWork</a><ul><li><a href="#t12511.1 ReactFiberWorkLoop.js">11.1 ReactFiberWorkLoop.js</a></li><li><a href="#t12611.2 ReactFiberCompleteWork.js">11.2 ReactFiberCompleteWork.js</a></li><li><a href="#t12711.3 ReactDOMHostConfig.js">11.3 ReactDOMHostConfig.js</a></li><li><a href="#t12811.4 ReactDOMComponent.js">11.4 ReactDOMComponent.js</a></li><li><a href="#t12911.5 CSSPropertyOperations.js">11.5 CSSPropertyOperations.js</a></li><li><a href="#t13011.6 setTextContent.js">11.6 setTextContent.js</a></li><li><a href="#t13111.7 DOMPropertyOperations.js">11.7 DOMPropertyOperations.js</a></li></ul></li><li><a href="#t13212.commitRoot">12.commitRoot</a><ul><li><a href="#t13312.1 ReactFiberWorkLoop.js">12.1 ReactFiberWorkLoop.js</a></li></ul></li><li><a href="#t13413.commitMutationEffectsOnFiber">13.commitMutationEffectsOnFiber</a><ul><li><a href="#t13513.1 ReactFiberWorkLoop.js">13.1 ReactFiberWorkLoop.js</a></li><li><a href="#t13613.2 ReactFiberCommitWork.js">13.2 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t13714.commitPlacement">14.commitPlacement</a><ul><li><a href="#t13814.1 ReactFiberCommitWork.js">14.1 ReactFiberCommitWork.js</a></li><li><a href="#t13914.2 ReactDOMHostConfig.js">14.2 ReactDOMHostConfig.js</a></li></ul></li><li><a href="#t14015.函数组件">15.函数组件</a><ul><li><a href="#t14115.1 src\main.jsx">15.1 src\main.jsx</a></li><li><a href="#t14215.2 ReactWorkTags.js">15.2 ReactWorkTags.js</a></li><li><a href="#t14315.3 ReactFiberBeginWork.js">15.3 ReactFiberBeginWork.js</a></li><li><a href="#t14415.4 ReactFiberHooks.js">15.4 ReactFiberHooks.js</a></li><li><a href="#t14515.5 ReactFiberCommitWork.js">15.5 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t14616.注册事件名">16.注册事件名</a><ul><li><a href="#t14716.1 src\main.jsx">16.1 src\main.jsx</a></li><li><a href="#t14816.2 ReactDOMRoot.js">16.2 ReactDOMRoot.js</a></li><li><a href="#t14916.3 DOMPluginEventSystem.js">16.3 DOMPluginEventSystem.js</a></li><li><a href="#t15016.4 EventRegistry.js">16.4 EventRegistry.js</a></li><li><a href="#t15116.5 SimpleEventPlugin.js">16.5 SimpleEventPlugin.js</a></li><li><a href="#t15216.6 DOMEventProperties.js">16.6 DOMEventProperties.js</a></li></ul></li><li><a href="#t15317.listenToNativeEvent">17.listenToNativeEvent</a><ul><li><a href="#t15417.1 DOMPluginEventSystem.js">17.1 DOMPluginEventSystem.js</a></li><li><a href="#t15517.2 EventSystemFlags.js">17.2 EventSystemFlags.js</a></li><li><a href="#t15617.3 ReactDOMEventListener.js">17.3 ReactDOMEventListener.js</a></li><li><a href="#t15717.4 EventListener.js">17.4 EventListener.js</a></li></ul></li><li><a href="#t15818.extractEvents">18.extractEvents</a><ul><li><a href="#t15918.1 ReactDOMEventListener.js">18.1 ReactDOMEventListener.js</a></li><li><a href="#t16018.2 getEventTarget.js">18.2 getEventTarget.js</a></li><li><a href="#t16118.3 ReactDOMComponentTree.js">18.3 ReactDOMComponentTree.js</a></li><li><a href="#t16218.4 DOMPluginEventSystem.js">18.4 DOMPluginEventSystem.js</a></li><li><a href="#t16318.5 getListener.js">18.5 getListener.js</a></li><li><a href="#t16418.6 SimpleEventPlugin.js">18.6 SimpleEventPlugin.js</a></li><li><a href="#t16518.7 SyntheticEvent.js">18.7 SyntheticEvent.js</a></li><li><a href="#t16618.8 ReactDOMHostConfig.js">18.8 ReactDOMHostConfig.js</a></li><li><a href="#t16718.9 DOMEventProperties.js">18.9 DOMEventProperties.js</a></li></ul></li><li><a href="#t16819.processDispatchQueue">19.processDispatchQueue</a><ul><li><a href="#t16919.1 DOMPluginEventSystem.js">19.1 DOMPluginEventSystem.js</a></li></ul></li><li><a href="#t17020.mountReducer">20.mountReducer</a><ul><li><a href="#t17120.1 src\main.jsx">20.1 src\main.jsx</a></li><li><a href="#t17220.2 ReactFiberHooks.js">20.2 ReactFiberHooks.js</a></li><li><a href="#t17320.3 react\index.js">20.3 react\index.js</a></li><li><a href="#t17420.4 React.js">20.4 React.js</a></li><li><a href="#t17520.5 ReactHooks.js">20.5 ReactHooks.js</a></li><li><a href="#t17620.6 ReactCurrentDispatcher.js">20.6 ReactCurrentDispatcher.js</a></li><li><a href="#t17720.7 ReactSharedInternals.js">20.7 ReactSharedInternals.js</a></li><li><a href="#t17820.8 ReactSharedInternals.js">20.8 ReactSharedInternals.js</a></li></ul></li><li><a href="#t17921.updateReducer">21.updateReducer</a><ul><li><a href="#t18021.1 ReactFiberHooks.js">21.1 ReactFiberHooks.js</a></li><li><a href="#t18121.2 ReactFiberConcurrentUpdates.js">21.2 ReactFiberConcurrentUpdates.js</a></li><li><a href="#t18221.3 ReactFiberWorkLoop.js">21.3 ReactFiberWorkLoop.js</a></li><li><a href="#t18321.4 ReactFiberBeginWork.js">21.4 ReactFiberBeginWork.js</a></li><li><a href="#t18421.5 ReactChildFiber.js">21.5 ReactChildFiber.js</a></li><li><a href="#t18521.6 ReactFiberCompleteWork.js">21.6 ReactFiberCompleteWork.js</a></li><li><a href="#t18621.7 ReactFiberFlags.js">21.7 ReactFiberFlags.js</a></li><li><a href="#t18721.8 ReactDOMHostConfig.js">21.8 ReactDOMHostConfig.js</a></li><li><a href="#t18821.9 ReactDOMComponent.js">21.9 ReactDOMComponent.js</a></li></ul></li><li><a href="#t18922.commitUpdate">22.commitUpdate</a><ul><li><a href="#t19022.1 DOMPluginEventSystem.js">22.1 DOMPluginEventSystem.js</a></li><li><a href="#t19122.2 ReactFiberCompleteWork.js">22.2 ReactFiberCompleteWork.js</a></li><li><a href="#t19222.3 ReactFiberCommitWork.js">22.3 ReactFiberCommitWork.js</a></li><li><a href="#t19322.4 ReactDOMHostConfig.js">22.4 ReactDOMHostConfig.js</a></li><li><a href="#t19422.5 ReactDOMComponent.js">22.5 ReactDOMComponent.js</a></li></ul></li><li><a href="#t19523.useState">23.useState</a><ul><li><a href="#t19623.1 src\main.jsx">23.1 src\main.jsx</a></li><li><a href="#t19723.2 react\index.js">23.2 react\index.js</a></li><li><a href="#t19823.3 React.js">23.3 React.js</a></li><li><a href="#t19923.4 ReactHooks.js">23.4 ReactHooks.js</a></li><li><a href="#t20023.5 objectIs.js">23.5 objectIs.js</a></li><li><a href="#t20123.6 ReactFiberHooks.js">23.6 ReactFiberHooks.js</a></li></ul></li><li><a href="#t20224.单节点(key 相同,类型相同)">24.单节点(key 相同,类型相同)</a><ul><li><a href="#t20324.1 src\main.jsx">24.1 src\main.jsx</a></li></ul></li><li><a href="#t20425.单节点 key 不同,类型相同">25.单节点 key 不同,类型相同</a><ul><li><a href="#t20525.1 main.jsx">25.1 main.jsx</a></li><li><a href="#t20625.2 ReactFiberFlags.js">25.2 ReactFiberFlags.js</a></li><li><a href="#t20725.3 ReactFiber.js">25.3 ReactFiber.js</a></li><li><a href="#t20825.4 ReactDOMHostConfig.js">25.4 ReactDOMHostConfig.js</a></li><li><a href="#t20925.5 ReactChildFiber.js">25.5 ReactChildFiber.js</a></li><li><a href="#t21025.6 ReactFiberCommitWork.js">25.6 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t21126.单节点 key 相同,类型不同">26.单节点 key 相同,类型不同</a><ul><li><a href="#t21226.1 src\main.jsx">26.1 src\main.jsx</a></li><li><a href="#t21326.2 ReactChildFiber.js">26.2 ReactChildFiber.js</a></li></ul></li><li><a href="#t21427.原来多个节点，现在只有一个节点">27.原来多个节点，现在只有一个节点</a><ul><li><a href="#t21527.1 src\main.jsx">27.1 src\main.jsx</a></li></ul></li><li><a href="#t21628.多节点 DIFF">28.多节点 DIFF</a></li><li><a href="#t21729.多个节点的数量和 key 相同，有的 type 不同">29.多个节点的数量和 key 相同，有的 type 不同</a><ul><li><a href="#t21829.1 src\main.jsx">29.1 src\main.jsx</a></li><li><a href="#t21929.2 ReactChildFiber.js">29.2 ReactChildFiber.js</a></li></ul></li><li><a href="#t22030.多个节点的类型和 key 全部相同，有新增元素">30.多个节点的类型和 key 全部相同，有新增元素</a><ul><li><a href="#t22130.1 src\main.jsx">30.1 src\main.jsx</a></li></ul></li><li><a href="#t22231.多个节点的类型和 key 全部相同，有删除老元素">31.多个节点的类型和 key 全部相同，有删除老元素</a><ul><li><a href="#t22331.1 src\main.jsx">31.1 src\main.jsx</a></li></ul></li><li><a href="#t22432.多个节点数量不同、key 不同">32.多个节点数量不同、key 不同</a><ul><li><a href="#t22532.1 src\main.jsx">32.1 src\main.jsx</a></li><li><a href="#t22632.2 ReactFiber.js">32.2 ReactFiber.js</a></li><li><a href="#t22732.3 ReactFiberWorkLoop.js">32.3 ReactFiberWorkLoop.js</a></li><li><a href="#t22832.4 ReactChildFiber.js">32.4 ReactChildFiber.js</a></li></ul></li><li><a href="#t22933.useEffect">33.useEffect</a><ul><li><a href="#t23033.1 src\main.jsx">33.1 src\main.jsx</a></li><li><a href="#t23133.2 react\index.js">33.2 react\index.js</a></li><li><a href="#t23233.3 React.js">33.3 React.js</a></li><li><a href="#t23333.4 ReactHooks.js">33.4 ReactHooks.js</a></li><li><a href="#t23433.5 ReactHookEffectTags.js">33.5 ReactHookEffectTags.js</a></li><li><a href="#t23533.6 ReactFiberFlags.js">33.6 ReactFiberFlags.js</a></li><li><a href="#t23633.7 ReactFiberHooks.js">33.7 ReactFiberHooks.js</a></li><li><a href="#t23733.8 ReactFiberWorkLoop.js">33.8 ReactFiberWorkLoop.js</a></li><li><a href="#t23833.9 ReactFiberCommitWork.js">33.9 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t23934.useLayoutEffect">34.useLayoutEffect</a><ul><li><a href="#t24034.1 src\main.jsx">34.1 src\main.jsx</a></li><li><a href="#t24133.2 react\index.js">33.2 react\index.js</a></li><li><a href="#t24234.3 React.js">34.3 React.js</a></li><li><a href="#t24334.4 ReactHooks.js">34.4 ReactHooks.js</a></li><li><a href="#t24434.5 ReactHookEffectTags.js">34.5 ReactHookEffectTags.js</a></li><li><a href="#t24534.6 ReactFiberFlags.js">34.6 ReactFiberFlags.js</a></li><li><a href="#t24634.7 ReactFiberHooks.js">34.7 ReactFiberHooks.js</a></li><li><a href="#t24734.8 ReactFiberWorkLoop.js">34.8 ReactFiberWorkLoop.js</a></li><li><a href="#t24834.9 ReactFiberCommitWork.js">34.9 ReactFiberCommitWork.js</a></li></ul></li><li><a href="#t24935.Scheduler_scheduleCallback">35.Scheduler_scheduleCallback</a><ul><li><a href="#t25035.1 ReactFiberWorkLoop.js">35.1 ReactFiberWorkLoop.js</a></li><li><a href="#t25135.2 Scheduler.js">35.2 Scheduler.js</a></li><li><a href="#t25235.3 Scheduler.js">35.3 Scheduler.js</a></li><li><a href="#t25335.4 SchedulerFeatureFlags.js">35.4 SchedulerFeatureFlags.js</a></li><li><a href="#t25435.5 SchedulerMinHeap.js">35.5 SchedulerMinHeap.js</a></li><li><a href="#t25535.6 SchedulerPriorities.js">35.6 SchedulerPriorities.js</a></li></ul></li><li><a href="#t25636.初次渲染">36.初次渲染</a><ul><li><a href="#t25736.1 src\main.jsx">36.1 src\main.jsx</a></li><li><a href="#t25836.2  ReactFiberReconciler.js">36.2  ReactFiberReconciler.js</a></li><li><a href="#t25936.3  ReactFiberClassUpdateQueue.js">36.3  ReactFiberClassUpdateQueue.js</a></li><li><a href="#t26036.4 ReactFiberConcurrentUpdates.js">36.4 ReactFiberConcurrentUpdates.js</a></li><li><a href="#t26136.5 ReactFiberWorkLoop.js">36.5 ReactFiberWorkLoop.js</a></li><li><a href="#t26236.6 ReactFiberBeginWork.js">36.6 ReactFiberBeginWork.js</a></li><li><a href="#t26336.7 ReactFiberLane.js">36.7 ReactFiberLane.js</a></li><li><a href="#t26436.8 ReactEventPriorities.js">36.8 ReactEventPriorities.js</a></li><li><a href="#t26536.9 ReactDOMHostConfig.js">36.9 ReactDOMHostConfig.js</a></li><li><a href="#t26636.10 ReactDOMEventListener.js">36.10 ReactDOMEventListener.js</a></li><li><a href="#t26736.11 Scheduler.js">36.11 Scheduler.js</a></li></ul></li><li><a href="#t26837.更新渲染">37.更新渲染</a><ul><li><a href="#t26937.1 main.jsx">37.1 main.jsx</a></li><li><a href="#t27037.2 ReactFiberHooks.js">37.2 ReactFiberHooks.js</a></li><li><a href="#t27137.3 ReactFiberWorkLoop.js">37.3 ReactFiberWorkLoop.js</a></li><li><a href="#t27237.4 ReactFiberSyncTaskQueue.js">37.4 ReactFiberSyncTaskQueue.js</a></li><li><a href="#t27337.5  ReactFiberConcurrentUpdates.js">37.5  ReactFiberConcurrentUpdates.js</a></li><li><a href="#t27437.6 ReactDOMEventListener.js">37.6 ReactDOMEventListener.js</a></li></ul></li><li><a href="#t27538.并发渲染">38.并发渲染</a><ul><li><a href="#t27638.1  src\main.jsx">38.1  src\main.jsx</a></li><li><a href="#t27738.2  ReactFiberWorkLoop.js">38.2  ReactFiberWorkLoop.js</a></li><li><a href="#t27838.3 Scheduler.js">38.3 Scheduler.js</a></li><li><a href="#t27938.4 Scheduler.js">38.4 Scheduler.js</a></li><li><a href="#t28038.5 ReactFiberLane.js">38.5 ReactFiberLane.js</a></li><li><a href="#t28138.6 ReactFeatureFlags.js">38.6 ReactFeatureFlags.js</a></li></ul></li><li><a href="#t28239.批量更新">39.批量更新</a><ul><li><a href="#t28339.1  src\main.jsx">39.1  src\main.jsx</a></li><li><a href="#t28439.2 ReactFiberHooks.js">39.2 ReactFiberHooks.js</a></li><li><a href="#t28539.3  ReactFiberWorkLoop.js">39.3  ReactFiberWorkLoop.js</a></li></ul></li><li><a href="#t28640.高优更新打断低优更新(useRef)">40.高优更新打断低优更新(useRef)</a><ul><li><a href="#t28740.1 src\main.jsx">40.1 src\main.jsx</a></li><li><a href="#t28840.2 react\index.js">40.2 react\index.js</a></li><li><a href="#t28940.3 React.js">40.3 React.js</a></li><li><a href="#t29040.4 ReactHooks.js">40.4 ReactHooks.js</a></li><li><a href="#t29140.5 ReactFiberWorkLoop.js">40.5 ReactFiberWorkLoop.js</a></li><li><a href="#t29240.6 ReactFiberLane.js">40.6 ReactFiberLane.js</a></li><li><a href="#t29340.7  ReactFiberHooks.js">40.7  ReactFiberHooks.js</a></li><li><a href="#t29440.8 ReactFiberFlags.js">40.8 ReactFiberFlags.js</a></li><li><a href="#t29540.9 ReactFiberCompleteWork.js">40.9 ReactFiberCompleteWork.js</a></li><li><a href="#t29640.10 ReactFiberCommitWork.js">40.10 ReactFiberCommitWork.js</a></li><li><a href="#t29740.11  ReactFiber.js">40.11  ReactFiber.js</a></li><li><a href="#t29840.12 ReactChildFiber.js">40.12 ReactChildFiber.js</a></li></ul></li><li><a href="#t29941.饥饿问题">41.饥饿问题</a><ul><li><a href="#t30041.1 src\main.jsx">41.1 src\main.jsx</a></li><li><a href="#t30141.2 Scheduler.js">41.2 Scheduler.js</a></li><li><a href="#t30241.3 Scheduler.js">41.3 Scheduler.js</a></li><li><a href="#t30341.4 ReactFiberWorkLoop.js">41.4 ReactFiberWorkLoop.js</a></li><li><a href="#t30441.5 ReactFiberLane.js">41.5 ReactFiberLane.js</a></li><li><a href="#t30541.6 ReactFiber.js">41.6 ReactFiber.js</a></li><li><a href="#t30641.7 ReactFiberBeginWork.js">41.7 ReactFiberBeginWork.js</a></li><li><a href="#t30741.8 ReactFiberCompleteWork.js">41.8 ReactFiberCompleteWork.js</a></li><li><a href="#t30841.9 ReactFiberConcurrentUpdates.js">41.9 ReactFiberConcurrentUpdates.js</a></li><li><a href="#t30941.10 ReactFiberHooks.js">41.10 ReactFiberHooks.js</a></li><li><a href="#t31041.11 ReactFiberReconciler.js">41.11 ReactFiberReconciler.js</a></li><li><a href="#t31141.12 ReactFiberRoot.js">41.12 ReactFiberRoot.js</a></li></ul></li><li><a href="#t31242.context">42.context</a><ul><li><a href="#t31342.1 src\main.jsx">42.1 src\main.jsx</a></li><li><a href="#t31442.2  react\index.js">42.2  react\index.js</a></li><li><a href="#t31542.3 React.js">42.3 React.js</a></li><li><a href="#t31642.4 ReactContext.js">42.4 ReactContext.js</a></li><li><a href="#t31742.5 ReactHooks.js">42.5 ReactHooks.js</a></li><li><a href="#t31842.6 ReactFiber.js">42.6 ReactFiber.js</a></li><li><a href="#t31942.7 ReactFiberBeginWork.js">42.7 ReactFiberBeginWork.js</a></li><li><a href="#t32042.8 ReactFiberCompleteWork.js">42.8 ReactFiberCompleteWork.js</a></li><li><a href="#t32142.9 ReactFiberCommitWork.js">42.9 ReactFiberCommitWork.js</a></li><li><a href="#t32242.10 ReactFiberHooks.js">42.10 ReactFiberHooks.js</a></li><li><a href="#t32342.11 ReactFiberNewContext.js">42.11 ReactFiberNewContext.js</a></li><li><a href="#t32442.12 ReactWorkTags.js">42.12 ReactWorkTags.js</a></li><li><a href="#t32542.13 ReactSymbols.js">42.13 ReactSymbols.js</a></li></ul></li></ul>
    </div>
    <div class="content markdown-body">
      <h2 id="t01.React 前置知识">1.React 前置知识 <a href="#t01.React 前置知识"> # </a></h2>
<h3 id="t11.1 React 是什么?">1.1 React 是什么? <a href="#t11.1 React 是什么?"> # </a></h3>
<ul>
<li><a href="https://zh-hans.reactjs.org/">React</a>是一个用于构建用户界面的 JavaScript 库</li>
<li>可以通过组件化的方式构建 构建快速响应的大型<code>Web</code>应用程序</li>
</ul>
<h3 id="t21.2 JSX 是什么">1.2 JSX 是什么 <a href="#t21.2 JSX 是什么"> # </a></h3>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/introducing-jsx.html">jsx</a></li>
<li>JSX 是一个<code>JavaScript</code>的语法扩展,JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式</li>
<li><a href="https://babeljs.io/repl">repl</a>可以在线转换代码</li>
<li><a href="https://astexplorer.net/">astexplorer</a>可以把代码转换成 AST 树</li>
<li><code>react/jsx-runtime</code> 和 <code>react/jsx-dev-runtime</code> 中的函数只能由编译器转换使用。如果你需要在代码中手动创建元素，你可以继续使用 <code>React.createElement</code></li>
</ul>
<h4 id="t31.2.1 旧转换">1.2.1 旧转换 <a href="#t31.2.1 旧转换"> # </a></h4>
<h5 id="t41.2.1.1 jsx.js">1.2.1.1 jsx.js <a href="#t41.2.1.1 jsx.js"> # </a></h5>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/core"</span>);
<span class="hljs-keyword">const</span> sourceCode = <span class="hljs-string">`
&lt;h1&gt;
    hello&lt;span style={{ color: "red" }}&gt;world&lt;/span&gt;
&lt;/h1&gt;
`</span>;
<span class="hljs-keyword">const</span> result = babel.transform(sourceCode, {
  <span class="hljs-attr">plugins</span>: [[<span class="hljs-string">"@babel/plugin-transform-react-jsx"</span>, { <span class="hljs-attr">runtime</span>: <span class="hljs-string">"classic"</span> }]],
});
<span class="hljs-built_in">console</span>.log(result.code);
</code></pre>
<h5 id="t51.2.1.2 转译结果">1.2.1.2 转译结果 <a href="#t51.2.1.2 转译结果"> # </a></h5>
<pre><code class="lang-js">React.createElement(
  <span class="hljs-string">"h1"</span>,
  <span class="hljs-literal">null</span>,
  <span class="hljs-string">"hello"</span>,
  React.createElement(
    <span class="hljs-string">"span"</span>,
    {
      <span class="hljs-attr">style</span>: {
        <span class="hljs-attr">color</span>: <span class="hljs-string">"red"</span>,
      },
    },
    <span class="hljs-string">"world"</span>
  )
);
</code></pre>
<h4 id="t61.2.2 新转换">1.2.2 新转换 <a href="#t61.2.2 新转换"> # </a></h4>
<h5 id="t71.2.2.1 jsx.js">1.2.2.1 jsx.js <a href="#t71.2.2.1 jsx.js"> # </a></h5>
<pre><code class="lang-diff">const babel = require("@babel/core");
const sourceCode = `
&lt;h1&gt;
    hello&lt;span style={{ color: "red" }}&gt;world&lt;/span&gt;
&lt;/h1&gt;
`;
const result = babel.transform(sourceCode, {
<span class="hljs-addition">+ plugins: [["@babel/plugin-transform-react-jsx", { runtime: "automatic" }]],</span>
});
console.log(result.code);
</code></pre>
<h5 id="t81.2.2.2 转译结果">1.2.2.2 转译结果 <a href="#t81.2.2.2 转译结果"> # </a></h5>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> { jsxDEV } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"react/jsx-dev-runtime"</span>);
jsxDEV(<span class="hljs-string">"h1"</span>, {
  <span class="hljs-attr">children</span>: [
    <span class="hljs-string">"hello"</span>,
    jsxDEV(<span class="hljs-string">"span"</span>, {
      <span class="hljs-attr">style</span>: {
        <span class="hljs-attr">color</span>: <span class="hljs-string">"red"</span>,
      },
      <span class="hljs-attr">children</span>: <span class="hljs-string">"world"</span>,
    }),
  ],
});
</code></pre>
<h3 id="t91.3 Virtual DOM">1.3 Virtual DOM <a href="#t91.3 Virtual DOM"> # </a></h3>
<ul>
<li><code>React.createElement</code> 函数所返回的就是一个虚拟 DOM</li>
<li>虚拟 DOM 就是一个描述真实 DOM 的纯 JS 对象</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/virutaldom_1664073330011.jpg" alt=""></p>
<h3 id="t101.4 链表">1.4 链表 <a href="#t101.4 链表"> # </a></h3>
<h4 id="t111.4.1 链表分类">1.4.1 链表分类 <a href="#t111.4.1 链表分类"> # </a></h4>
<h5 id="t121.4.1.1 单向链表">1.4.1.1 单向链表 <a href="#t121.4.1.1 单向链表"> # </a></h5>
<p><img src="https://static.zhufengpeixun.com/dan_xiang_lian_biao_1644749400974.jpg" alt=""></p>
<h5 id="t131.4.1.2 双向链表">1.4.1.2 双向链表 <a href="#t131.4.1.2 双向链表"> # </a></h5>
<p><img src="https://static.zhufengpeixun.com/shuang_xiang_lian_biao_1644749407158.jpg" alt=""></p>
<h5 id="t141.4.1.3 循环链表">1.4.1.3 循环链表 <a href="#t141.4.1.3 循环链表"> # </a></h5>
<p><img src="https://static.zhufengpeixun.com/xun_huan_lian_biao_1644749414532.jpg" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/queuepending_1644750048819.png" alt=""></p>
<h5 id="t151.4.1.4 示例">1.4.1.4 示例 <a href="#t151.4.1.4 示例"> # </a></h5>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> UpdateState = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initializeUpdateQueue</span>(<span class="hljs-params">fiber</span>) </span>{
  <span class="hljs-keyword">const</span> queue = {
    <span class="hljs-attr">shared</span>: {
      <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
    },
  };
  fiber.updateQueue = queue;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createUpdate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> update = { <span class="hljs-attr">tag</span>: UpdateState };
  <span class="hljs-keyword">return</span> update;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueUpdate</span>(<span class="hljs-params">fiber, update</span>) </span>{
  <span class="hljs-keyword">const</span> updateQueue = fiber.updateQueue;
  <span class="hljs-keyword">const</span> sharedQueue = updateQueue.shared;
  <span class="hljs-keyword">const</span> pending = sharedQueue.pending;
  <span class="hljs-keyword">if</span> (pending === <span class="hljs-literal">null</span>) {
    update.next = update;
  } <span class="hljs-keyword">else</span> {
    update.next = pending.next;
    pending.next = update;
  }
  updateQueue.shared.pending = update;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStateFromUpdate</span>(<span class="hljs-params">update, prevState</span>) </span>{
  <span class="hljs-keyword">switch</span> (update.tag) {
    <span class="hljs-keyword">case</span> UpdateState: {
      <span class="hljs-keyword">const</span> { payload } = update;
      <span class="hljs-keyword">const</span> partialState = payload;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, prevState, partialState);
    }
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> prevState;
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processUpdateQueue</span>(<span class="hljs-params">workInProgress</span>) </span>{
  <span class="hljs-keyword">const</span> queue = workInProgress.updateQueue;
  <span class="hljs-keyword">const</span> pendingQueue = queue.shared.pending;
  <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) {
    queue.shared.pending = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> lastPendingUpdate = pendingQueue;
    <span class="hljs-keyword">const</span> firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> newState = workInProgress.memoizedState;
    <span class="hljs-keyword">let</span> update = firstPendingUpdate;
    <span class="hljs-keyword">while</span> (update) {
      newState = getStateFromUpdate(update, newState);
      update = update.next;
    }
    workInProgress.memoizedState = newState;
  }
}
<span class="hljs-keyword">let</span> fiber = { <span class="hljs-attr">memoizedState</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> } };
initializeUpdateQueue(fiber);
<span class="hljs-keyword">let</span> update1 = createUpdate();
update1.payload = { <span class="hljs-attr">name</span>: <span class="hljs-string">"zhufeng"</span> };
enqueueUpdate(fiber, update1);
<span class="hljs-keyword">let</span> update2 = createUpdate();
update2.payload = { <span class="hljs-attr">age</span>: <span class="hljs-number">14</span> };
enqueueUpdate(fiber, update2);
processUpdateQueue(fiber);
<span class="hljs-built_in">console</span>.log(fiber);
</code></pre>
<h3 id="t161.5 fiber">1.5 fiber <a href="#t161.5 fiber"> # </a></h3>
<h4 id="t171.5.1 性能瓶颈">1.5.1 性能瓶颈 <a href="#t171.5.1 性能瓶颈"> # </a></h4>
<ul>
<li>JS 任务执行时间过长<ul>
<li>浏览器刷新频率为 60Hz,大概 16.6 毫秒渲染一次，而 JS 线程和渲染线程是互斥的，所以如果 JS 线程执行任务时间超过 16.6ms 的话，就会导致掉帧，导致卡顿，解决方案就是 React 利用空闲的时间进行更新，不影响渲染进行的渲染</li>
<li>把一个耗时任务切分成一个个小任务，分布在每一帧里的方式就叫时间切片</li>
</ul>
</li>
</ul>
<h4 id="t181.5.2 屏幕刷新率">1.5.2 屏幕刷新率 <a href="#t181.5.2 屏幕刷新率"> # </a></h4>
<ul>
<li>目前大多数设备的屏幕刷新率为 60 次/秒</li>
<li>浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致</li>
<li>页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的,小于这个值时，用户会感觉到卡顿</li>
<li>每个帧的预算时间是 16.66 毫秒 (1 秒/60)</li>
<li>1s 60 帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms,所以我们书写代码时力求不让一帧的工作量超过 16ms</li>
</ul>
<h4 id="t191.5.3 帧">1.5.3 帧 <a href="#t191.5.3 帧"> # </a></h4>
<ul>
<li>每个帧的开头包括样式计算、布局和绘制</li>
<li>JavaScript 执行 Javascript 引擎和页面渲染引擎在同一个渲染线程,GUI 渲染和 Javascript 执行两者是互斥的</li>
<li>如果某个任务执行时间过长，浏览器会推迟渲染</li>
</ul>
<p><img src="http://img.zhufengpeixun.cn/lifeofframe.jpg" alt="lifeofframe"></p>
<h4 id="t201.5.4 requestIdleCallback">1.5.4 requestIdleCallback <a href="#t201.5.4 requestIdleCallback"> # </a></h4>
<ul>
<li>我们希望快速响应用户，让用户觉得够快，不能阻塞用户的交互</li>
<li><code>requestIdleCallback</code> 使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应</li>
<li>正常帧任务完成后没超过 16 ms,说明时间有富余，此时就会执行 <code>requestIdleCallback</code> 里注册的任务</li>
</ul>
<p><img src="http://img.zhufengpeixun.cn/cooperativescheduling2.jpg" alt="cooperativescheduling2"></p>
<pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">d</span>) </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-built_in">Date</span>.now() - t &lt;= d; );
      }
      <span class="hljs-keyword">const</span> works = [
        <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"第1个任务开始"</span>);
          sleep(<span class="hljs-number">20</span>); <span class="hljs-comment">//sleep(20);</span>
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"第1个任务结束"</span>);
        },
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"第2个任务开始"</span>);
          sleep(<span class="hljs-number">20</span>); <span class="hljs-comment">//sleep(20);</span>
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"第2个任务结束"</span>);
        },
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"第3个任务开始"</span>);
          sleep(<span class="hljs-number">20</span>); <span class="hljs-comment">//sleep(20);</span>
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"第3个任务结束"</span>);
        },
      ];

      requestIdleCallback(workLoop);
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoop</span>(<span class="hljs-params">deadline</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"本帧剩余时间"</span>, <span class="hljs-built_in">parseInt</span>(deadline.timeRemaining()));
        <span class="hljs-keyword">while</span> (deadline.timeRemaining() &gt; <span class="hljs-number">1</span> &amp;&amp; works.length &gt; <span class="hljs-number">0</span>) {
          performUnitOfWork();
        }
        <span class="hljs-keyword">if</span> (works.length &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`只剩下<span class="hljs-subst">${<span class="hljs-built_in">parseInt</span>(deadline.timeRemaining())}</span>ms,时间片到了等待下次空闲时间的调度`</span>);
          requestIdleCallback(workLoop);
        }
      }
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performUnitOfWork</span>(<span class="hljs-params"></span>) </span>{
        works.shift()();
      }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h4 id="t211.5.5 fiber">1.5.5 fiber <a href="#t211.5.5 fiber"> # </a></h4>
<ul>
<li>我们可以通过某些调度策略合理分配 CPU 资源，从而提高用户的响应速度</li>
<li>通过 Fiber 架构，让自己的调和过程变成可被中断。 适时地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互</li>
</ul>
<h5 id="t221.5.5.1 Fiber 是一个执行单元">1.5.5.1 Fiber 是一个执行单元 <a href="#t221.5.5.1 Fiber 是一个执行单元"> # </a></h5>
<ul>
<li>Fiber 是一个执行单元,每次执行完一个执行单元, React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</li>
</ul>
<p><img src="http://img.zhufengpeixun.cn/fiberflow.jpg" alt="fiberflow"></p>
<h5 id="t231.5.5.2 Fiber 是一种数据结构">1.5.5.2 Fiber 是一种数据结构 <a href="#t231.5.5.2 Fiber 是一种数据结构"> # </a></h5>
<ul>
<li>React 目前的做法是使用链表, 每个虚拟节点内部表示为一个<code>Fiber</code></li>
<li>从顶点开始遍历</li>
<li>如果有第一个儿子，先遍历第一个儿子</li>
<li>如果没有第一个儿子，标志着此节点遍历完成</li>
<li>如果有弟弟遍历弟弟</li>
<li>如果有没有下一个弟弟，返回父节点标识完成父节点遍历，如果有叔叔遍历叔叔</li>
<li>没有父节点遍历结束</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/renderFiber1_1664076149659.jpg" alt=""></p>
<h5 id="t241.5.5.3 递归构建 fiber 树">1.5.5.3 递归构建 fiber 树 <a href="#t241.5.5.3 递归构建 fiber 树"> # </a></h5>
<p><img src="https://static.zhufengpeixun.com/di_gui_gou_jian_fiber_shu_1664076989593.jpg" alt=""></p>
<h3 id="t251.6 树的遍历">1.6 树的遍历 <a href="#t251.6 树的遍历"> # </a></h3>
<p><img src="https://static.zhufengpeixun.com/dfs_he_bfs1_1644891966511.jpg" alt=""></p>
<h4 id="t261.6.1 深度优先(DFS)">1.6.1 深度优先(DFS) <a href="#t261.6.1 深度优先(DFS)"> # </a></h4>
<ul>
<li>深度优先搜索英文缩写为 DFS 即<code>Depth First Search</code></li>
<li>其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次</li>
<li>应用场景<ul>
<li>React 虚拟 DOM 的构建</li>
<li>React 的 fiber 树构建</li>
</ul>
</li>
</ul>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-built_in">console</span>.log(node.name);
  node.children &amp;&amp;
    node.children.forEach(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
      dfs(child);
    });
}
<span class="hljs-keyword">let</span> root = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"A"</span>,
  <span class="hljs-attr">children</span>: [
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">"B"</span>,
      <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">"B1"</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">"B2"</span> }],
    },
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">"C"</span>,
      <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">"C1"</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">"C2"</span> }],
    },
  ],
};
dfs(root);
</code></pre>
<h4 id="t271.6.2 广度优先(BFS)">1.6.2 广度优先(BFS) <a href="#t271.6.2 广度优先(BFS)"> # </a></h4>
<ul>
<li>宽度优先搜索算法（又称广度优先搜索），其英文全称是 Breadth First Search</li>
<li>算法首先搜索距离为<code>k</code>的所有顶点，然后再去搜索距离为<code>k+l</code>的其他顶点</li>
</ul>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">const</span> stack = [];
  stack.push(node);
  <span class="hljs-keyword">let</span> current;
  <span class="hljs-keyword">while</span> ((current = stack.shift())) {
    <span class="hljs-built_in">console</span>.log(current.name);
    current.children &amp;&amp;
      current.children.forEach(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
        stack.push(child);
      });
  }
}
<span class="hljs-keyword">let</span> root = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"A"</span>,
  <span class="hljs-attr">children</span>: [
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">"B"</span>,
      <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">"B1"</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">"B2"</span> }],
    },
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">"C"</span>,
      <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">"C1"</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">"C2"</span> }],
    },
  ],
};
bfs(root);
</code></pre>
<h4 id="t281.6.3 栈">1.6.3 栈 <a href="#t281.6.3 栈"> # </a></h4>
<ul>
<li>栈（stack）又名堆栈，它是一种运算受限的线性表</li>
<li>限定仅在表尾进行插入和删除操作的线性表，这一端被称为栈顶，相对地，把另一端称为栈底</li>
<li>向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素</li>
<li>从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/stack_1664077689567.png" alt=""></p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.data = [];
    <span class="hljs-keyword">this</span>.top = <span class="hljs-number">0</span>;
  }
  push(node) {
    <span class="hljs-keyword">this</span>.data[<span class="hljs-keyword">this</span>.top++] = node;
  }
  pop() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data[--<span class="hljs-keyword">this</span>.top];
  }
  peek() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data[<span class="hljs-keyword">this</span>.top - <span class="hljs-number">1</span>];
  }
  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.top;
  }
  clear() {
    <span class="hljs-keyword">this</span>.top = <span class="hljs-number">0</span>;
  }
}

<span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack();
stack.push(<span class="hljs-string">"1"</span>);
stack.push(<span class="hljs-string">"2"</span>);
stack.push(<span class="hljs-string">"3"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"stack.size()"</span>, stack.size());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"stack.peek"</span>, stack.peek());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"stack.pop()"</span>, stack.pop());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"stack.peek()"</span>, stack.peek());
stack.push(<span class="hljs-string">"4"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"stack.peek"</span>, stack.peek());
stack.clear();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"stack.size"</span>, stack.size());
stack.push(<span class="hljs-string">"5"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"stack.peek"</span>, stack.peek());
</code></pre>
<h3 id="t291.7 位运算">1.7 位运算 <a href="#t291.7 位运算"> # </a></h3>
<h4 id="t301.7.1 比特">1.7.1 比特 <a href="#t301.7.1 比特"> # </a></h4>
<ul>
<li>比特(bit)是表示信息的最小单位</li>
<li>比特(bit)是二进制单位(binary unit)的缩写</li>
<li>比特(bit)只有两种状态：0 和 1</li>
<li>一般来说 n 比特的信息量可以表示出 2 的 n 次方种选择</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/bits_1644547153133.png" alt="bit"></p>
<pre><code class="lang-js"><span class="hljs-number">0b1000</span>=<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>=<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)=<span class="hljs-number">8</span>
</code></pre>
<h4 id="t311.7.2 位运算">1.7.2 位运算 <a href="#t311.7.2 位运算"> # </a></h4>
<ul>
<li><a href="https://262.ecma-international.org/5.1/#sec-11.10">Binary Bitwise Operators</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_AND">按位与</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_OR">按位或</a></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">运算</th>
<th style="text-align:left">使用</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">按位与(&amp;)</td>
<td style="text-align:left">x &amp; y</td>
<td style="text-align:left">每一个比特位都为 1 时，结果为 1，否则为 0</td>
</tr>
<tr>
<td style="text-align:left">按位或(<img src="https://static.zhufengpeixun.com/huo_1645097073861.png" alt="">)</td>
<td style="text-align:left">x <img src="https://static.zhufengpeixun.com/huo_1645097073861.png" alt=""> y</td>
<td style="text-align:left">每一个比特位都为 0 时，结果为 0，否则为 1</td>
</tr>
</tbody>
</table>
<h4 id="t321.7.3 使用">1.7.3 使用 <a href="#t321.7.3 使用"> # </a></h4>
<pre><code class="lang-js"><span class="hljs-comment">//定义常量</span>
<span class="hljs-keyword">const</span> Placement = <span class="hljs-number">0b001</span>; <span class="hljs-comment">// 0b001</span>
<span class="hljs-keyword">const</span> Update = <span class="hljs-number">0b010</span>; <span class="hljs-comment">// 0b010</span>
<span class="hljs-comment">//定义操作</span>
<span class="hljs-keyword">let</span> flags = <span class="hljs-number">0b000</span>;
<span class="hljs-comment">//增加操作</span>
flags |= Placement;
flags |= Update;
<span class="hljs-built_in">console</span>.log(flags.toString(<span class="hljs-number">2</span>)); <span class="hljs-comment">//0b11</span>
<span class="hljs-comment">//删除操作</span>
flags = flags &amp; ~Placement;
<span class="hljs-built_in">console</span>.log(flags.toString(<span class="hljs-number">2</span>)); <span class="hljs-comment">//0b10</span>
<span class="hljs-comment">//判断包含</span>
<span class="hljs-built_in">console</span>.log((flags &amp; Placement) === Placement);
<span class="hljs-built_in">console</span>.log((flags &amp; Update) === Update);
<span class="hljs-comment">//判断不包含</span>
<span class="hljs-built_in">console</span>.log((flags &amp; Placement) === <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log((flags &amp; Update) === <span class="hljs-number">0</span>);
</code></pre>
<h3 id="t331.8 事件">1.8 事件 <a href="#t331.8 事件"> # </a></h3>
<ul>
<li>事件是用户或浏览器自身执行的某种动作，而响应某个事件的函数叫做事件处理程序</li>
</ul>
<h4 id="t341.8.1 DOM 事件流">1.8.1 DOM 事件流 <a href="#t341.8.1 DOM 事件流"> # </a></h4>
<p><img src="https://static.zhufengpeixun.com/eventflow_1665894563837.jpg" alt="eventflow"></p>
<ul>
<li>事件流包含三个阶段<ul>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ul>
</li>
<li>首先发生的是事件捕获，然后是实际的目标接收到事件，最后阶段是冒泡阶段</li>
</ul>
<h4 id="t351.8.2 事件捕获">1.8.2 事件捕获 <a href="#t351.8.2 事件捕获"> # </a></h4>
<ul>
<li>是先由最上一级的节点先接收事件,然后向下传播到具体的节点 <code>document-&gt;body-&gt;div-&gt;button</code></li>
</ul>
<h4 id="t361.8.3 目标阶段">1.8.3 目标阶段 <a href="#t361.8.3 目标阶段"> # </a></h4>
<ul>
<li>在目标节点上触发,称为目标阶段</li>
<li>事件目标是真正触发事件的对象</li>
</ul>
<pre><code class="lang-js"><span class="hljs-comment">//w3c浏览器：event.target</span>
<span class="hljs-comment">//IE6、7、8： event.srcElement</span>
<span class="hljs-keyword">let</span> target = event.target || event.srcElement;
</code></pre>
<h4 id="t371.8.4 事件冒泡">1.8.4 事件冒泡 <a href="#t371.8.4 事件冒泡"> # </a></h4>
<ul>
<li>事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收,然后逐级向上传播 <code>button-&gt;div-&gt;body-&gt;document</code></li>
</ul>
<h4 id="t381.8.5 addEventListener">1.8.5 addEventListener <a href="#t381.8.5 addEventListener"> # </a></h4>
<ul>
<li>任何发生在 W3C 事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</li>
<li>可以选择是在捕获阶段还是冒泡阶段绑定事件处理函数</li>
<li><code>useCapture</code>参数是<code>true</code>，则在捕获阶段绑定函数，反之<code>false</code>，在冒泡阶段绑定函数</li>
</ul>
<pre><code class="lang-js">element.addEventListener(event, <span class="hljs-function"><span class="hljs-keyword">function</span>, <span class="hljs-title">useCapture</span>)
</span></code></pre>
<h4 id="t391.8.6 阻止冒泡">1.8.6 阻止冒泡 <a href="#t391.8.6 阻止冒泡"> # </a></h4>
<ul>
<li>如果想要阻止事件的传播<ul>
<li>在微软的模型中你必须设置事件的<code>cancelBubble</code>的属性为 true</li>
<li>在 W3C 模型中你必须调用事件的<code>stopPropagation()</code>方法</li>
</ul>
</li>
</ul>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopPropagation</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (!event) {
    <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">if</span> (event.stopPropagation) {
    event.stopPropagation();
  }
}
</code></pre>
<h4 id="t401.8.7 阻止默认行为">1.8.7 阻止默认行为 <a href="#t401.8.7 阻止默认行为"> # </a></h4>
<ul>
<li>取消默认事件</li>
</ul>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preventDefault</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (!event) {
    <span class="hljs-built_in">window</span>.event.returnValue = <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">if</span> (event.preventDefault) {
    event.preventDefault();
  }
}
</code></pre>
<h4 id="t411.8.8 事件代理">1.8.8 事件代理 <a href="#t411.8.8 事件代理"> # </a></h4>
<ul>
<li>事件代理又称之为事件委托</li>
<li>事件代理是把原本需要绑定在<code>子元素</code>的事件委托给<code>父元素</code>，让父元素负责事件监听</li>
<li>事件代理是利用<code>事件冒泡</code>来实现的</li>
<li>优点<ul>
<li>可以大量节省内存占用，减少事件注册</li>
<li>当新增子对象时无需再次对其绑定</li>
</ul>
</li>
</ul>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"show(event)"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item n<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span><span class="hljs-params">(event)</span> </span>{
      alert(event.target.innerHTML);
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<h4 id="t421.8.9 事件系统">1.8.9 事件系统 <a href="#t421.8.9 事件系统"> # </a></h4>
<ul>
<li>合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象,它们将不同浏览器的行为合并为一个 API,这样做是为了确保事件在不同浏览器中显示一致的属性</li>
</ul>
<h5 id="t431.8.10.1 使用">1.8.10.1 使用 <a href="#t431.8.10.1 使用"> # </a></h5>
<p><img src="https://static.zhufengpeixun.com/eventuse_1665894712077.jpg" alt="eventuse"></p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  parentRef = React.createRef();
  childRef = React.createRef();
  componentDidMount() {
    <span class="hljs-keyword">this</span>.parentRef.current.addEventListener(
      <span class="hljs-string">"click"</span>,
      () =&gt; {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"父元素原生捕获"</span>);
      },
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-keyword">this</span>.parentRef.current.addEventListener(<span class="hljs-string">"click"</span>, () =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"父元素原生冒泡"</span>);
    });
    <span class="hljs-keyword">this</span>.childRef.current.addEventListener(
      <span class="hljs-string">"click"</span>,
      () =&gt; {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子元素原生捕获"</span>);
      },
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-keyword">this</span>.childRef.current.addEventListener(<span class="hljs-string">"click"</span>, () =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子元素原生冒泡"</span>);
    });
    <span class="hljs-built_in">document</span>.addEventListener(
      <span class="hljs-string">"click"</span>,
      () =&gt; {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"document原生捕获"</span>);
      },
      <span class="hljs-literal">true</span>
    );
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">"click"</span>, () =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"document原生冒泡"</span>);
    });
  }
  parentBubble = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"父元素React事件冒泡"</span>);
  };
  childBubble = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子元素React事件冒泡"</span>);
  };
  parentCapture = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"父元素React事件捕获"</span>);
  };
  childCapture = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子元素React事件捕获"</span>);
  };
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.parentRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.parentBubble}</span> <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">{this.parentCapture}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.childRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.childBubble}</span> <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">{this.childCapture}</span>&gt;</span>
          事件执行顺序
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>));
<span class="hljs-comment">/**
document原生捕获
父元素React事件捕获
子元素React事件捕获
父元素原生捕获
子元素原生捕获
子元素原生冒泡
父元素原生冒泡
子元素React事件冒泡
父元素React事件冒泡
document原生冒泡
 */</span>
</code></pre>
<h5 id="t441.8.10.2 简易实现">1.8.10.2 简易实现 <a href="#t441.8.10.2 简易实现"> # </a></h5>
<pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>event<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"child"</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-keyword">let</span> root = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>);
      <span class="hljs-keyword">let</span> parent = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"parent"</span>);
      <span class="hljs-keyword">let</span> child = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"child"</span>);
      <span class="hljs-comment">//listenToNativeEvent('click',false,root);</span>
      <span class="hljs-comment">//listenToNativeEvent( 'click',true,root);</span>

      <span class="hljs-comment">//root的捕获阶段的处理函数</span>
      root.addEventListener(<span class="hljs-string">"click"</span>, (event) =&gt; dispatchEvent(event, <span class="hljs-literal">true</span>), <span class="hljs-literal">true</span>);
      <span class="hljs-comment">//root的冒泡阶段的处理函数</span>
      root.addEventListener(<span class="hljs-string">"click"</span>, (event) =&gt; dispatchEvent(event, <span class="hljs-literal">false</span>), <span class="hljs-literal">false</span>);
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchEvent</span>(<span class="hljs-params">event, isCapture</span>) </span>{
        <span class="hljs-comment">//console.log(event,isCapture);</span>
        <span class="hljs-keyword">let</span> paths = []; <span class="hljs-comment">//事件的传播路径数组[child,parent,root,body,document]</span>
        <span class="hljs-keyword">let</span> currentTarget = event.target; <span class="hljs-comment">//事件源</span>
        <span class="hljs-keyword">while</span> (currentTarget) {
          paths.push(currentTarget);
          currentTarget = currentTarget.parentNode;
        }
        <span class="hljs-keyword">if</span> (isCapture) {
          <span class="hljs-comment">//如果当前是捕获阶段</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = paths.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-comment">//[document,body,root,parent.child]</span>
            <span class="hljs-keyword">let</span> handler = paths[i].onClickCapture; <span class="hljs-comment">//react捕获事件</span>
            handler &amp;&amp; handler();
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; paths.length; i++) {
            <span class="hljs-comment">//[child,parent,root,body,document]</span>
            <span class="hljs-keyword">let</span> handler = paths[i].onClick; <span class="hljs-comment">//react冒泡事件</span>
            handler &amp;&amp; handler();
          }
        }
      }
      root.addEventListener(<span class="hljs-string">"click"</span>, (event) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"根元素原生事件捕获"</span>), <span class="hljs-literal">true</span>);
      root.addEventListener(<span class="hljs-string">"click"</span>, (event) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"根元素原生事件冒泡"</span>), <span class="hljs-literal">false</span>);
      parent.addEventListener(
        <span class="hljs-string">"click"</span>,
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"父元素原生事件捕获"</span>);
        },
        <span class="hljs-literal">true</span>
      );
      parent.addEventListener(
        <span class="hljs-string">"click"</span>,
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"父元素原生事件冒泡"</span>);
        },
        <span class="hljs-literal">false</span>
      );
      child.addEventListener(
        <span class="hljs-string">"click"</span>,
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子元素原生事件捕获"</span>);
        },
        <span class="hljs-literal">true</span>
      );
      child.addEventListener(
        <span class="hljs-string">"click"</span>,
        () =&gt; {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子元素原生事件冒泡"</span>);
        },
        <span class="hljs-literal">false</span>
      );
      parent.onClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"React:父元素React事件冒泡"</span>);
      };
      parent.onClickCapture = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"React:父元素React事件捕获"</span>);
      };
      child.onClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"React:子元素React事件冒泡"</span>);
      };
      child.onClickCapture = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"React:子元素React事件捕获"</span>);
      };
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 id="t451.9 最小堆">1.9 最小堆 <a href="#t451.9 最小堆"> # </a></h3>
<p><img src="https://static.zhufengpeixun.com/xiao_ding_dui_1643273795848.png" style="width:20%"></p>
<h4 id="t461.9.1 二叉树">1.9.1 二叉树 <a href="#t461.9.1 二叉树"> # </a></h4>
<ul>
<li>每个节点最多有两个子节点</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/er_cha_shu_1643273951562.jpg" alt=""></p>
<h4 id="t471.9.2 满二叉树">1.9.2 满二叉树 <a href="#t471.9.2 满二叉树"> # </a></h4>
<ul>
<li>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/man_er_cha_shu_1643274395792.jpg" alt=""></p>
<h4 id="t481.9.3 完全二叉树">1.9.3 完全二叉树 <a href="#t481.9.3 完全二叉树"> # </a></h4>
<ul>
<li>叶子结点只能出现在最下层和次下层</li>
<li>且最下层的叶子结点集中在树的左部</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/wan_quan_er_cha_shu_1643274486956.jpg" alt=""></p>
<h4 id="t491.9.4 最小堆">1.9.4 最小堆 <a href="#t491.9.4 最小堆"> # </a></h4>
<ul>
<li><a href="https://www.processon.com/diagraming/61f26156e0b34d06c3b5bf48">processon</a></li>
<li>最小堆是一种经过排序的完全二叉树</li>
<li>其中任一非终端节点的数据值均不大于其左子节点和右子节点的值</li>
<li>根结点值是所有堆结点值中最小者</li>
<li>编号关系<ul>
<li>左子节点编号=父节点编号<em>2  1</em>2=2</li>
<li>右子节点编号=左子节点编号+1</li>
<li>父节点编号=子节点编号/2 2/2=1</li>
</ul>
</li>
<li>索引关系<ul>
<li>左子节点索引=(父节点索引+1)<em>2-1 (0+1)</em>2-1=1</li>
<li>右子节点索引=左子节点索引+1 </li>
<li>父节点索引=(子节点索引-1)/2 (1-1)/2=0</li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift">Unsigned_right_shift</a></li>
</ul>
<p><img src="https://static.zhufengpeixun.com/zui_xiao_dui_1_1643275468911.jpg" alt=""></p>
<h4 id="t501.9.5 SchedulerMinHeap.js">1.9.5 SchedulerMinHeap.js <a href="#t501.9.5 SchedulerMinHeap.js"> # </a></h4>
<ul>
<li>peek() 查看堆的顶点</li>
<li>pop() 弹出堆的定点后需要调用<code>siftDown</code>函数向下调整堆</li>
<li>push() 添加新节点后需要调用<code>siftUp</code>函数向上调整堆</li>
<li>siftDown() 向下调整堆结构, 保证最小堆</li>
<li>siftUp() 需要向上调整堆结构, 保证最小堆</li>
</ul>
<p>react\packages\scheduler\src\SchedulerMinHeap.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">heap, node</span>) </span>{
  <span class="hljs-keyword">const</span> index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peek</span>(<span class="hljs-params">heap</span>) </span>{
  <span class="hljs-keyword">const</span> first = heap[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">return</span> first === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : first;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params">heap</span>) </span>{
  <span class="hljs-keyword">const</span> first = heap[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (first !== <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">const</span> last = heap.pop();
    <span class="hljs-keyword">if</span> (last !== first) {
      heap[<span class="hljs-number">0</span>] = last;
      siftDown(heap, last, <span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">return</span> first;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftUp</span>(<span class="hljs-params">heap, node, i</span>) </span>{
  <span class="hljs-keyword">let</span> index = i;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> parentIndex = index - <span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> parent = heap[parentIndex];
    <span class="hljs-keyword">if</span> (parent !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(parent, node) &gt; <span class="hljs-number">0</span>) {
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } <span class="hljs-keyword">else</span> {

      <span class="hljs-keyword">return</span>;
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftDown</span>(<span class="hljs-params">heap, node, i</span>) </span>{
  <span class="hljs-keyword">let</span> index = i;
  <span class="hljs-keyword">const</span> length = heap.length;
  <span class="hljs-keyword">while</span> (index &lt; length) {
    <span class="hljs-keyword">const</span> leftIndex = (index + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> left = heap[leftIndex];
    <span class="hljs-keyword">const</span> rightIndex = leftIndex + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> right = heap[rightIndex]; 
    <span class="hljs-keyword">if</span> (left !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(left, node) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (right !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(right, left) &lt; <span class="hljs-number">0</span>) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } <span class="hljs-keyword">else</span> {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(right, node) &lt; <span class="hljs-number">0</span>) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>;
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">const</span> diff = a.sortIndex - b.sortIndex;
  <span class="hljs-keyword">return</span> diff !== <span class="hljs-number">0</span> ? diff : a.id - b.id;
}
</code></pre>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { push, pop, peek } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./SchedulerMinHeap'</span>);
<span class="hljs-keyword">let</span> heap = [];
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">1</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">2</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">3</span> });
<span class="hljs-built_in">console</span>.log(peek(heap));
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">4</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">5</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">6</span> });
push(heap, { <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">7</span> });
<span class="hljs-built_in">console</span>.log(peek(heap));
pop(heap);
<span class="hljs-built_in">console</span>.log(peek(heap));
</code></pre>
<h3 id="t511.10 MessageChannel">1.10 MessageChannel <a href="#t511.10 MessageChannel"> # </a></h3>
<ul>
<li>目前 <code>requestIdleCallback</code> 目前只有Chrome支持</li>
<li>所以目前 React利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel">MessageChannel</a>模拟了requestIdleCallback，将回调延迟到绘制操作之后执行</li>
<li>MessageChannel API允许我们创建一个新的消息通道，并通过它的两个MessagePort属性发送数据</li>
<li>MessageChannel创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过postMessage发送数据，而一个端口只要绑定了onmessage回调方法，就可以接收从另一个端口传过来的数据</li>
<li>MessageChannel是一个宏任务</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/liu_lan_qi_zhen_1643277067067.jpg" alt=""></p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> channel = <span class="hljs-keyword">new</span> MessageChannel();
<span class="hljs-comment">//channel.port1</span>
<span class="hljs-comment">//channel.port2</span>
</code></pre>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> channel = <span class="hljs-keyword">new</span> MessageChannel();
<span class="hljs-keyword">var</span> port1 = channel.port1;
<span class="hljs-keyword">var</span> port2 = channel.port2
port1.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"port1收到来自port2的数据："</span> + event.data);
}
port2.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"port2收到来自port1的数据："</span> + event.data);
}
port1.postMessage(<span class="hljs-string">"发送给port2"</span>);
port2.postMessage(<span class="hljs-string">"发送给port1"</span>);
</code></pre>
<h3 id="t521.11 二进制">1.11 二进制 <a href="#t521.11 二进制"> # </a></h3>
<ul>
<li>计算机用二进制来存储数字</li>
<li>为了简化运算，二进制数都是用一个字节(8个二进制位)来简化说明</li>
<li><a href="unit.html">在线工具</a></li>
</ul>
<h4 id="t531.11.1 ES5规范">1.11.1 ES5规范 <a href="#t531.11.1 ES5规范"> # </a></h4>
<ul>
<li><a href="https://262.ecma-international.org/5.1/#sec-11.10">Binary Bitwise Operators</a></li>
<li><a href="https://262.ecma-international.org/5.1/#sec-9.5">ToInt32: (Signed 32 Bit Integer)</a></li>
<li>位运算只支持整数运算</li>
<li>位运算中的左右操作数都会转换为有符号32位整型, 且返回结果也是有符号32位整型</li>
<li>操作数的大小超过Int32范围(-2^31 ~ 2^31-1). 超过范围的二进制位会被截断, 取低位32bit</li>
</ul>
<h4 id="t541.11.2 真值">1.11.2 真值 <a href="#t541.11.2 真值"> # </a></h4>
<ul>
<li>8位二进制数能表示的真值范围是[-2^8, +2^8]</li>
</ul>
<pre><code class="lang-js">+ 00000001 # +1
- 00000001 # -1
</code></pre>
<h4 id="t551.11.3 原码">1.11.3 原码 <a href="#t551.11.3 原码"> # </a></h4>
<ul>
<li>由于计算机只能存储0和1，不能存储正负</li>
<li>所以用8个二进制位的最高位来表示符号，0表示正，1表示负，用后七位来表示真值的绝对值</li>
<li>这种表示方法称为原码表示法，简称原码</li>
<li>由于<code>10000000</code>的意思是-0，这个没有意义，所有这个数字被用来表示-128</li>
<li>由于最高位被用来表示符号了，现在能表示的范围是[-2^7, +2^7-1]，即[-128, +127]</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/originalcode_1644551851223.gif" alt=""></p>
<pre><code class="lang-js">0 0000001 # +1
1 0000001 # -1
</code></pre>
<h4 id="t561.11.4 反码">1.11.4 反码 <a href="#t561.11.4 反码"> # </a></h4>
<ul>
<li>反码是另一种表示数字的方法</li>
<li>其规则是整数的反码何其原码一样</li>
<li>负数的反码将其原码的符号位不变，其余各位按位取反</li>
<li>反码的表示范围是[-2^7, +2^7-1]，即[-128, +127]</li>
</ul>
<pre><code class="lang-js">0 0000001 # +1
1 1111110 # -1
</code></pre>
<p><img src="https://static.zhufengpeixun.com/completation_1644551871239.gif" alt=""></p>
<h4 id="t571.11.5 补码">1.11.5 补码 <a href="#t571.11.5 补码"> # </a></h4>
<ul>
<li>补码是为了简化运算，将减法变为加法而发明的数字表示法</li>
<li>其规则是整数的补码和原码一样，负数的补码是其反码末尾加1</li>
<li>8位补码表示的范围是[-2^7, +2^7-1]，即[-128, +127]</li>
<li>快速计算负数补码的规则就是，由其原码低位向高位找到第一个1，1和其低位不变，1前面的高位按位取反即可</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/bumacunzai_1644551883284.png" alt=""></p>
<pre><code class="lang-js">0 0000001 # +1
1 1111111 # -1
</code></pre>
<h4 id="t581.11.6 二进制数整数">1.11.6 二进制数整数 <a href="#t581.11.6 二进制数整数"> # </a></h4>
<ul>
<li>只要对js中的任何数字做位运算操作系统内部都会将其转换成整形</li>
<li>js中的这种整形是区分正负数的</li>
<li>js中的整数的表示范围是[-2^31, +2^31-1]，即[-2147483648, +2147483647]</li>
</ul>
<h4 id="t591.11.7 ~非">1.11.7 ~非 <a href="#t591.11.7 ~非"> # </a></h4>
<ul>
<li>~操作符会将操作数的每一位取反，如果是1则变为0，如果是0则边为1</li>
</ul>
<pre><code class="lang-js"><span class="hljs-number">0b00000011</span>
<span class="hljs-number">3</span>
~<span class="hljs-number">0b00000011</span> =&gt;  <span class="hljs-number">0b11111100</span>
<span class="hljs-number">-4</span>
(~<span class="hljs-number">0b00000011</span>).toString();
<span class="hljs-string">'-4'</span>
(~<span class="hljs-number">0b00000011</span>).toString(<span class="hljs-number">2</span>);
<span class="hljs-string">'-100'</span>

求补码的真值
<span class="hljs-number">1</span> 表示负号
剩下的 <span class="hljs-number">1111100</span> 开始转换
<span class="hljs-number">1111100</span> 减<span class="hljs-number">1</span>
<span class="hljs-number">1111011</span> 取反
<span class="hljs-number">0000100</span> <span class="hljs-number">4</span>
</code></pre>
<h4 id="t601.11.8 getHighestPriorityLane">1.11.8 getHighestPriorityLane <a href="#t601.11.8 getHighestPriorityLane"> # </a></h4>
<ul>
<li>可以找到最右边的1</li>
<li>最右边的1右边的全是0，全是0取反就全是1，再加上就会全部进位到1取反的位置</li>
<li>最右边的1和右边的数跟原来的值是完全一样的，左边的全是反的</li>
</ul>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * 分离出所有比特位中最右边的1
 * 分离出最高优先级的车道
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>lanes 车道
 * <span class="hljs-doctag">@returns </span>车道
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHighestPriorityLane</span>(<span class="hljs-params">lanes</span>) </span>{
    <span class="hljs-keyword">return</span> lanes &amp; -lanes;
}

lanes=<span class="hljs-number">0b00001100</span>=<span class="hljs-number">12</span>
-lanes=<span class="hljs-number">-12</span>
<span class="hljs-number">1</span>
<span class="hljs-number">0001100</span>
<span class="hljs-number">1110011</span>
<span class="hljs-number">1110100</span>
<span class="hljs-number">11110100</span>
<span class="hljs-number">00001100</span>
</code></pre>
<h4 id="t611.11.9 左移">1.11.9 左移 <a href="#t611.11.9 左移"> # </a></h4>
<ul>
<li>左移的规则就是每一位都向左移动一位，末尾补0，其效果相当于×2</li>
<li>计算机就是用移位操作来计算乘法的</li>
</ul>
<pre><code class="lang-js">(<span class="hljs-number">0b00000010</span>&lt;&lt;<span class="hljs-number">1</span>).toString(<span class="hljs-number">2</span>)
</code></pre>
<h4 id="t621.11.10 >> 有符号右移">1.11.10 &gt;&gt; 有符号右移 <a href="#t621.11.10 >> 有符号右移"> # </a></h4>
<ul>
<li>有符号右移也就是移位的时候高位补的是其符号位，整数则补0，负数则补1</li>
</ul>
<pre><code class="lang-js">(<span class="hljs-number">-0</span>b111&gt;&gt;<span class="hljs-number">1</span>).toString(<span class="hljs-number">2</span>) <span class="hljs-string">"-100"</span>
<span class="hljs-number">-0</span>b111 <span class="hljs-number">-7</span>
<span class="hljs-number">100000111</span> 原码
<span class="hljs-number">111111000</span> 反码
<span class="hljs-number">111111001</span> 补码
<span class="hljs-number">111111100</span>

<span class="hljs-number">1</span>
<span class="hljs-number">111111100</span>
<span class="hljs-number">111111011</span>
<span class="hljs-number">000000100</span>
<span class="hljs-number">1000000100</span>
<span class="hljs-number">-100</span>
<span class="hljs-number">-4</span>
</code></pre>
<h4 id="t631.11.11 >>>无符号右移">1.11.11 &gt;&gt;&gt;无符号右移 <a href="#t631.11.11 >>>无符号右移"> # </a></h4>
<ul>
<li>右移的时候高位始终补0</li>
<li>正数和有符号右移没有区别</li>
<li>负数右移后会变为正数</li>
</ul>
<pre><code class="lang-js">(<span class="hljs-number">0b111</span>&gt;&gt;&gt;<span class="hljs-number">1</span>).toString(<span class="hljs-number">2</span>)
&gt;&gt;&gt; <span class="hljs-string">"11"</span>
</code></pre>
<pre><code class="lang-js">(<span class="hljs-number">-0</span>b111&gt;&gt;&gt;<span class="hljs-number">1</span>).toString(<span class="hljs-number">2</span>)
&gt;&gt;&gt; <span class="hljs-string">"1111111111111111111111111111100"</span>

<span class="hljs-number">00000000000000000000000000000111</span>
<span class="hljs-number">11111111111111111111111111111000</span>
<span class="hljs-number">11111111111111111111111111111001</span>
<span class="hljs-number">01111111111111111111111111111100</span>
<span class="hljs-number">2147483644</span>
</code></pre>
<h3 id="t641.12 更新优先级">1.12 更新优先级 <a href="#t641.12 更新优先级"> # </a></h3>
<h4 id="t651.12.1 lane">1.12.1 lane <a href="#t651.12.1 lane"> # </a></h4>
<ul>
<li>React中用lane(车道)模型来表示任务优先级</li>
<li>一共有31条优先级，数字越小优先级越高，某些车道的优先级相同</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32">clz32</a>函数返回开头的 0 的个数</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/lanes_1645074174970.jfif" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/che_dao_1645080741671.jpg" alt=""></p>
<pre><code class="lang-js"><span class="hljs-comment">//一共有16种优先级</span>
<span class="hljs-comment">//同步优先级</span>
<span class="hljs-keyword">const</span> SyncLanePriority = <span class="hljs-number">15</span>;
<span class="hljs-keyword">const</span> SyncBatchedLanePriority = <span class="hljs-number">14</span>;
<span class="hljs-comment">//离散事件优先级</span>
<span class="hljs-keyword">const</span> InputDiscreteHydrationLanePriority = <span class="hljs-number">13</span>;
<span class="hljs-keyword">const</span> InputDiscreteLanePriority = <span class="hljs-number">12</span>;
<span class="hljs-comment">//连续事件优先级</span>
<span class="hljs-keyword">const</span> InputContinuousHydrationLanePriority = <span class="hljs-number">11</span>;
<span class="hljs-keyword">const</span> InputContinuousLanePriority = <span class="hljs-number">10</span>;
<span class="hljs-comment">//默认优先级</span>
<span class="hljs-keyword">const</span> DefaultHydrationLanePriority = <span class="hljs-number">9</span>;
<span class="hljs-keyword">const</span> DefaultLanePriority = <span class="hljs-number">8</span>;
<span class="hljs-comment">//渐变优先级</span>
<span class="hljs-keyword">const</span> TransitionHydrationPriority = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> TransitionPriority = <span class="hljs-number">6</span>;
<span class="hljs-keyword">const</span> RetryLanePriority = <span class="hljs-number">5</span>;
<span class="hljs-keyword">const</span> SelectiveHydrationLanePriority = <span class="hljs-number">4</span>;
<span class="hljs-comment">//空闲优先级</span>
<span class="hljs-keyword">const</span> IdleHydrationLanePriority = <span class="hljs-number">3</span>;
<span class="hljs-keyword">const</span> IdleLanePriority = <span class="hljs-number">2</span>;
<span class="hljs-comment">//离屏优先级</span>
<span class="hljs-keyword">const</span> OffscreenLanePriority = <span class="hljs-number">1</span>;
<span class="hljs-comment">//未设置优先级</span>
<span class="hljs-keyword">const</span> NoLanePriority = <span class="hljs-number">0</span>;
<span class="hljs-comment">/**
 * 一共有31条车道
 */</span>
<span class="hljs-keyword">const</span> TotalLanes = <span class="hljs-number">31</span>;
<span class="hljs-comment">//没有车道，所有位都为0</span>
<span class="hljs-keyword">const</span> NoLanes = <span class="hljs-number">0b0000000000000000000000000000000</span>;
<span class="hljs-keyword">const</span> NoLane = <span class="hljs-number">0b0000000000000000000000000000000</span>;
<span class="hljs-comment">//同步车道，优先级最高</span>
<span class="hljs-keyword">const</span> SyncLane = <span class="hljs-number">0b0000000000000000000000000000001</span>;
<span class="hljs-keyword">const</span> SyncBatchedLane = <span class="hljs-number">0b0000000000000000000000000000010</span>;
<span class="hljs-comment">//离散用户交互车道 click</span>
<span class="hljs-keyword">const</span> InputDiscreteHydrationLane = <span class="hljs-number">0b0000000000000000000000000000100</span>;
<span class="hljs-keyword">const</span> InputDiscreteLanes = <span class="hljs-number">0b0000000000000000000000000011000</span>;
<span class="hljs-comment">//连续交互车道 mouseMove</span>
<span class="hljs-keyword">const</span> InputContinuousHydrationLane = <span class="hljs-number">0b0000000000000000000000000100000</span>;
<span class="hljs-keyword">const</span> InputContinuousLanes = <span class="hljs-number">0b0000000000000000000000011000000</span>;
<span class="hljs-comment">//默认车道</span>
<span class="hljs-keyword">const</span> DefaultHydrationLane = <span class="hljs-number">0b0000000000000000000000100000000</span>;
<span class="hljs-keyword">const</span> DefaultLanes = <span class="hljs-number">0b0000000000000000000111000000000</span>;
<span class="hljs-comment">//渐变车道</span>
<span class="hljs-keyword">const</span> TransitionHydrationLane = <span class="hljs-number">0b0000000000000000001000000000000</span>;
<span class="hljs-keyword">const</span> TransitionLanes = <span class="hljs-number">0b0000000001111111110000000000000</span>;
<span class="hljs-comment">//重试车道</span>
<span class="hljs-keyword">const</span> RetryLanes = <span class="hljs-number">0b0000011110000000000000000000000</span>;
<span class="hljs-keyword">const</span> SomeRetryLane = <span class="hljs-number">0b0000010000000000000000000000000</span>;
<span class="hljs-comment">//选择性水合车道</span>
<span class="hljs-keyword">const</span> SelectiveHydrationLane = <span class="hljs-number">0b0000100000000000000000000000000</span>;
<span class="hljs-comment">//非空闲车道</span>
<span class="hljs-keyword">const</span> NonIdleLanes = <span class="hljs-number">0b0000111111111111111111111111111</span>;
<span class="hljs-keyword">const</span> IdleHydrationLane = <span class="hljs-number">0b0001000000000000000000000000000</span>;
<span class="hljs-comment">//空闲车道</span>
<span class="hljs-keyword">const</span> IdleLanes = <span class="hljs-number">0b0110000000000000000000000000000</span>;
<span class="hljs-comment">//离屏车道</span>
<span class="hljs-keyword">const</span> OffscreenLane = <span class="hljs-number">0b1000000000000000000000000000000</span>;

<span class="hljs-comment">/**
 * 分离出所有比特位中最右边的1
 * 分离出最高优先级的车道
 * @param {*} lanes 车道
 * @returns 车道
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHighestPriorityLane</span>(<span class="hljs-params">lanes</span>) </span>{
    <span class="hljs-keyword">return</span> lanes &amp; -lanes;
}

<span class="hljs-comment">//console.log(getHighestPriorityLane(InputDiscreteLanes));//8 0b1000</span>
<span class="hljs-comment">//console.log('0000000000000000000000000011000');</span>
<span class="hljs-comment">//console.log('1111111111111111111111111101000');</span>

<span class="hljs-comment">/**
 * 分离出所有比特位中最左边的1
 * 分离出最低优先级的车道
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>lanes 车道
 * <span class="hljs-doctag">@returns </span>车道
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLowestPriorityLane</span>(<span class="hljs-params">lanes</span>) </span>{
    <span class="hljs-keyword">const</span> index = <span class="hljs-number">31</span> - <span class="hljs-built_in">Math</span>.clz32(lanes);
    <span class="hljs-keyword">return</span> index &lt; <span class="hljs-number">0</span> ? NoLanes : <span class="hljs-number">1</span> &lt;&lt; index;
}
<span class="hljs-built_in">console</span>.log(getLowestPriorityLane(InputDiscreteLanes));<span class="hljs-comment">//16 0b10000</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'0000000000000000000000000011000'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.clz32(InputDiscreteLanes));<span class="hljs-comment">//27</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">31</span> - <span class="hljs-built_in">Math</span>.clz32(InputDiscreteLanes));<span class="hljs-comment">//4</span>
</code></pre>
<h4 id="t661.12.2 Hydration">1.12.2 Hydration <a href="#t661.12.2 Hydration"> # </a></h4>
<ul>
<li>水合反应(hydrated reaction)，也叫作水化</li>
<li>是指物质溶解在水里时，与水发生的化学作用,水合分子的过程</li>
<li>组件在服务器端拉取数据(水)，并在服务器端首次渲染</li>
<li>脱水: 对组件进行脱水，变成HTML字符串，脱去动态数据，成为风干标本快照</li>
<li>注水：发送到客户端后，重新注入数据(水)，重新变成可交互组件</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/huoyiner_1644572048109.jfif" style="width:500px"><br>
<img src="https://static.zhufengpeixun.com/saiyiner_1644571994221.jfif" style="width:500px"><br>
<img src="https://static.zhufengpeixun.com/paofayiner_1644572007011.jpeg" style="width:500px"><br></p>
<h4 id="t671.12.3 ReactFiberLane.js">1.12.3 ReactFiberLane.js <a href="#t671.12.3 ReactFiberLane.js"> # </a></h4>
<p>ReactFiberLane.js</p>
<pre><code class="lang-js">const NoLanes = 0b00;
const NoLane = 0b00;
const SyncLane = 0b01;
const SyncBatchedLane = 0b10;
/**
 * 判断subset是不是set的子集
 * @param {*} set 
 * @param {*} subset 
 * @returns 
 */
function isSubsetOfLanes(set, subset) {
    return (set &amp; subset) === subset;
}
/**
 * 合并两个车道
 * @param {*} a 
 * @param {*} b 
 * @returns 
 */
function mergeLanes(a, b) {
    return a | b;
}
module.exports = {
    NoLane,
    NoLanes,
    SyncLane,
    SyncBatchedLane,
    isSubsetOfLanes,
    mergeLanes
}
</code></pre>
<h4 id="t681.12.4 ReactUpdateQueue.js">1.12.4 ReactUpdateQueue.js <a href="#t681.12.4 ReactUpdateQueue.js"> # </a></h4>
<p>ReactUpdateQueue.js</p>
<p><img src="https://static.zhufengpeixun.com/update_1678680214838.png" alt=""></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { NoLane, NoLanes, isSubsetOfLanes, mergeLanes } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./ReactFiberLane'</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initializeUpdateQueue</span>(<span class="hljs-params">fiber</span>) </span>{
  <span class="hljs-keyword">const</span> queue = {
    <span class="hljs-attr">baseState</span>: fiber.memoizedState,<span class="hljs-comment">//本次更新前该Fiber节点的state,Update基于该state计算更新后的state</span>
    <span class="hljs-attr">firstBaseUpdate</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">//本次更新前该Fiber节点已保存的Update链表头</span>
    <span class="hljs-attr">lastBaseUpdate</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">//本次更新前该Fiber节点已保存的Update链表尾</span>
    <span class="hljs-attr">shared</span>: {
      <span class="hljs-comment">//触发更新时，产生的Update会保存在shared.pending中形成单向环状链表</span>
      <span class="hljs-comment">//当由Update计算state时这个环会被剪开并连接在lastBaseUpdate后面</span>
      <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>
    }
  }
  fiber.updateQueue = queue;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueUpdate</span>(<span class="hljs-params">fiber, update</span>) </span>{
  <span class="hljs-keyword">const</span> updateQueue = fiber.updateQueue;
  <span class="hljs-keyword">if</span> (updateQueue === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">const</span> sharedQueue = updateQueue.shared;
  <span class="hljs-keyword">const</span> pending = sharedQueue.pending;
  <span class="hljs-keyword">if</span> (pending === <span class="hljs-literal">null</span>) {
    update.next = update;
  } <span class="hljs-keyword">else</span> {
    update.next = pending.next;
    pending.next = update;
  }
  sharedQueue.pending = update;
}

<span class="hljs-comment">/**
 * 处理更新队列
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>fiber 
 * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>renderLanes 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processUpdateQueue</span>(<span class="hljs-params">fiber, renderLanes</span>) </span>{
  <span class="hljs-comment">//获取此fiber上的更新队列</span>
  <span class="hljs-keyword">const</span> queue = fiber.updateQueue;
  <span class="hljs-comment">//获取第一个更新</span>
  <span class="hljs-keyword">let</span> firstBaseUpdate = queue.firstBaseUpdate;
  <span class="hljs-keyword">let</span> lastBaseUpdate = queue.lastBaseUpdate;
  <span class="hljs-comment">//判断一下是否在等待生效的的更新，如果有，变成base队列</span>
  <span class="hljs-keyword">let</span> pendingQueue = queue.shared.pending;
  <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">//等待生效的队列是循环队列</span>
    queue.shared.pending = <span class="hljs-literal">null</span>;
    <span class="hljs-comment">//最后一个等待的更新 update4</span>
    <span class="hljs-keyword">const</span> lastPendingUpdate = pendingQueue;
    <span class="hljs-comment">//第一个等待的更新 update1</span>
    <span class="hljs-keyword">const</span> firstPendingUpdate = lastPendingUpdate.next;
    <span class="hljs-comment">//把环剪断，最后一个不再指向第一个</span>
    lastPendingUpdate.next = <span class="hljs-literal">null</span>;
    <span class="hljs-comment">//把等待生效的队列添加到base队列中</span>
    <span class="hljs-comment">//如果base队列为空</span>
    <span class="hljs-keyword">if</span> (lastBaseUpdate === <span class="hljs-literal">null</span>) {
      firstBaseUpdate = firstPendingUpdate;
    } <span class="hljs-keyword">else</span> {<span class="hljs-comment">//否则就把当前的更新队列添加到base队列的尾部</span>
      lastBaseUpdate.next = firstPendingUpdate;
    }
    <span class="hljs-comment">//尾部也接上</span>
    lastBaseUpdate = lastPendingUpdate;
  }
  <span class="hljs-comment">//开始计算新的状态</span>
  <span class="hljs-keyword">if</span> (firstBaseUpdate !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">//先获取老的值{number:0}</span>
    <span class="hljs-keyword">let</span> newState = queue.baseState;
    <span class="hljs-keyword">let</span> newLanes = NoLanes;
    <span class="hljs-keyword">let</span> newBaseState = <span class="hljs-literal">null</span>;<span class="hljs-comment">//新的基础状态</span>
    <span class="hljs-keyword">let</span> newFirstBaseUpdate = <span class="hljs-literal">null</span>;<span class="hljs-comment">//第一个跳过的更新</span>
    <span class="hljs-keyword">let</span> newLastBaseUpdate = <span class="hljs-literal">null</span>;<span class="hljs-comment">//新的最后一个基本更新</span>
    <span class="hljs-keyword">let</span> update = firstBaseUpdate;<span class="hljs-comment">//指向第一个更新</span>
    <span class="hljs-keyword">do</span> {
      <span class="hljs-comment">//获取更新车道</span>
      <span class="hljs-keyword">const</span> updateLane = update.lane;
      <span class="hljs-comment">//如果优先级不够，跳过这个更新，如果这是第一个跳过的更新，上一个状态和更新成为newBaseState和newFirstBaseUpdate</span>
      <span class="hljs-keyword">if</span> (!isSubsetOfLanes(renderLanes, updateLane)) {
        <span class="hljs-keyword">const</span> clone = {
          <span class="hljs-attr">id</span>: update.id,
          <span class="hljs-attr">lane</span>: updateLane,
          <span class="hljs-attr">payload</span>: update.payload
        };
        <span class="hljs-keyword">if</span> (newLastBaseUpdate === <span class="hljs-literal">null</span>) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;<span class="hljs-comment">// first=last=update1</span>
          newBaseState = newState;<span class="hljs-comment">//0</span>
        } <span class="hljs-keyword">else</span> {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        <span class="hljs-comment">//更新队列中的剩下的优先级</span>
        newLanes = mergeLanes(newLanes, updateLane);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//如果有足够的优先级 如果有曾经跳过的更新，仍然追加在后面</span>
        <span class="hljs-keyword">if</span> (newLastBaseUpdate !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">const</span> clone = {
            <span class="hljs-attr">id</span>: update.id,
            <span class="hljs-comment">//NoLane是所有的优先级的子集，永远不会被跳过</span>
            <span class="hljs-attr">lane</span>: NoLane,
            <span class="hljs-attr">payload</span>: update.payload
          };
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        newState = getStateFromUpdate(update, newState);
      }
      update = update.next;
      <span class="hljs-keyword">if</span> (!update) {
        <span class="hljs-keyword">break</span>;
      }
    } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);

    <span class="hljs-keyword">if</span> (!newLastBaseUpdate) {
      newBaseState = newState;
    }
    queue.baseState = newBaseState;
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate;
    fiber.lanes = newLanes;
    fiber.memoizedState = newState;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStateFromUpdate</span>(<span class="hljs-params">update, prevState</span>) </span>{
  <span class="hljs-keyword">const</span> payload = update.payload;
  <span class="hljs-keyword">let</span> partialState = payload(prevState);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, prevState, partialState);
}
<span class="hljs-built_in">module</span>.exports = {
  initializeUpdateQueue,
  enqueueUpdate,
  processUpdateQueue
}
</code></pre>
<h4 id="t691.12.5 processUpdateQueue.js">1.12.5 processUpdateQueue.js <a href="#t691.12.5 processUpdateQueue.js"> # </a></h4>
<p>use.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { initializeUpdateQueue, enqueueUpdate, processUpdateQueue } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./ReactUpdateQueue'</span>);
<span class="hljs-keyword">const</span> { SyncBatchedLane, SyncLane } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./ReactFiberLane'</span>);

<span class="hljs-comment">//初始化fiber节点</span>
<span class="hljs-keyword">let</span> fiber = { <span class="hljs-attr">memoizedState</span>: { <span class="hljs-attr">msg</span>: <span class="hljs-string">''</span> } };
initializeUpdateQueue(fiber);
<span class="hljs-keyword">let</span> update1 = { <span class="hljs-attr">id</span>: <span class="hljs-string">'A'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">'A'</span> }), <span class="hljs-attr">lane</span>: SyncBatchedLane };
enqueueUpdate(fiber, update1);
<span class="hljs-keyword">let</span> update2 = { <span class="hljs-attr">id</span>: <span class="hljs-string">'B'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">'B'</span> }), <span class="hljs-attr">lane</span>: SyncLane };
enqueueUpdate(fiber, update2);
<span class="hljs-keyword">let</span> update3 = { <span class="hljs-attr">id</span>: <span class="hljs-string">'C'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">'C'</span> }), <span class="hljs-attr">lane</span>: SyncBatchedLane };
enqueueUpdate(fiber, update3);
<span class="hljs-keyword">let</span> update4 = { <span class="hljs-attr">id</span>: <span class="hljs-string">'D'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">'D'</span> }), <span class="hljs-attr">lane</span>: SyncLane };
enqueueUpdate(fiber, update4);

<span class="hljs-comment">//以同步的优先级进行更新</span>
processUpdateQueue(fiber, SyncLane);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'memoizedState'</span>, fiber.memoizedState);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'updateQueue'</span>, printQueue(fiber.updateQueue));

<span class="hljs-keyword">let</span> update5 = { <span class="hljs-attr">id</span>: <span class="hljs-string">'E'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">'E'</span> }), <span class="hljs-attr">lane</span>: SyncLane };
enqueueUpdate(fiber, update5);
processUpdateQueue(fiber, SyncLane);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'memoizedState'</span>, fiber.memoizedState);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'updateQueue'</span>, printQueue(fiber.updateQueue));

processUpdateQueue(fiber, SyncBatchedLane);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'memoizedState'</span>, fiber.memoizedState);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'updateQueue'</span>, printQueue(fiber.updateQueue));

<span class="hljs-keyword">let</span> update6 = { <span class="hljs-attr">id</span>: <span class="hljs-string">'F'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">msg</span>: state.msg + <span class="hljs-string">'F'</span> }), <span class="hljs-attr">lane</span>: SyncLane };
enqueueUpdate(fiber, update6);
processUpdateQueue(fiber, SyncLane);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'memoizedState'</span>, fiber.memoizedState);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'updateQueue'</span>, printQueue(fiber.updateQueue));


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printQueue</span>(<span class="hljs-params">queue</span>) </span>{
  <span class="hljs-keyword">const</span> { baseState, firstBaseUpdate } = queue
  <span class="hljs-keyword">let</span> state = baseState.msg + <span class="hljs-string">'|'</span>;
  <span class="hljs-keyword">let</span> update = firstBaseUpdate;
  <span class="hljs-keyword">while</span> (update) {
    state += ((update.id) + <span class="hljs-string">"=&gt;"</span>);
    update = update.next;
  }
  state += <span class="hljs-string">"null"</span>;
  <span class="hljs-built_in">console</span>.log(state);
}
</code></pre>
<h2 id="t702.创建项目">2.创建项目 <a href="#t702.创建项目"> # </a></h2>
<ul>
<li><a href="https://cn.vitejs.dev/">vitejs</a></li>
</ul>
<h3 id="t712.1 创建目录">2.1 创建目录 <a href="#t712.1 创建目录"> # </a></h3>
<pre><code class="lang-js">mkdir react182
cd react182
npm init -y
</code></pre>
<h3 id="t722.2 安装">2.2 安装 <a href="#t722.2 安装"> # </a></h3>
<pre><code class="lang-js">npm install vite @vitejs/plugin-react --save
</code></pre>
<h3 id="t732.3 vite.config.js">2.3 vite.config.js <a href="#t732.3 vite.config.js"> # </a></h3>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig({
  <span class="hljs-attr">define</span>: {
    <span class="hljs-attr">__DEV__</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">__PROFILE__</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">__UMD__</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">__EXPERIMENTAL__</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-attr">react</span>: path.posix.resolve(<span class="hljs-string">"src/react"</span>),
      <span class="hljs-string">"react-dom"</span>: path.posix.resolve(<span class="hljs-string">"src/react-dom"</span>),
      <span class="hljs-string">"react-dom-bindings"</span>: path.posix.resolve(<span class="hljs-string">"src/react-dom-bindings"</span>),
      <span class="hljs-string">"react-reconciler"</span>: path.posix.resolve(<span class="hljs-string">"src/react-reconciler"</span>),
      <span class="hljs-attr">scheduler</span>: path.posix.resolve(<span class="hljs-string">"src/scheduler"</span>),
      <span class="hljs-attr">shared</span>: path.posix.resolve(<span class="hljs-string">"src/shared"</span>),
    },
  },
  <span class="hljs-attr">plugins</span>: [react()],
  <span class="hljs-attr">optimizeDeps</span>: {
    <span class="hljs-attr">force</span>: <span class="hljs-literal">true</span>,
  },
});
</code></pre>
<h3 id="t742.4 jsconfig.json">2.4 jsconfig.json <a href="#t742.4 jsconfig.json"> # </a></h3>
<p>jsconfig.json</p>
<pre><code class="lang-json">{
  <span class="hljs-attr">"compilerOptions"</span>: {
    <span class="hljs-attr">"baseUrl"</span>: <span class="hljs-string">"./"</span>,
    <span class="hljs-attr">"paths"</span>: {
      <span class="hljs-attr">"react/*"</span>: [<span class="hljs-string">"src/react/*"</span>],
      <span class="hljs-attr">"react-dom/*"</span>: [<span class="hljs-string">"src/react-dom/*"</span>],
      <span class="hljs-attr">"react-dom-bindings/*"</span>: [<span class="hljs-string">"react-dom-bindings/*"</span>],
      <span class="hljs-attr">"react-reconciler/*"</span>: [<span class="hljs-string">"src/react-reconciler/*"</span>],
      <span class="hljs-attr">"scheduler/*"</span>: [<span class="hljs-string">"scheduler/*"</span>],
      <span class="hljs-attr">"shared/*"</span>: [<span class="hljs-string">"src/shared/*"</span>]
    }
  },
  <span class="hljs-attr">"exclude"</span>: [<span class="hljs-string">"node_modules"</span>, <span class="hljs-string">"dist"</span>]
}
</code></pre>
<h3 id="t752.5 main.jsx">2.5 main.jsx <a href="#t752.5 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"main"</span>);
</code></pre>
<h3 id="t762.6 index.html">2.6 index.html <a href="#t762.6 index.html"> # </a></h3>
<p>index.html</p>
<pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>React18<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/src/main.jsx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 id="t772.7 package.json">2.7 package.json <a href="#t772.7 package.json"> # </a></h3>
<p>package.json</p>
<pre><code class="lang-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"vite"</span>
  }
}
</code></pre>
<h2 id="t783.实现虚拟 DOM">3.实现虚拟 DOM <a href="#t783.实现虚拟 DOM"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/virutaldom_1664037444732.png" alt=""></p>
<h3 id="t793.1 main.jsx">3.1 main.jsx <a href="#t793.1 main.jsx"> # </a></h3>
<p>main.jsx</p>
<pre><code class="lang-js"><span class="hljs-keyword">let</span> element = (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
    hello<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> "<span class="hljs-attr">red</span>" }}&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
);
<span class="hljs-built_in">console</span>.log(element);
</code></pre>
<h3 id="t803.2 jsx-dev-runtime.js">3.2 jsx-dev-runtime.js <a href="#t803.2 jsx-dev-runtime.js"> # </a></h3>
<p>src\react\jsx-dev-runtime.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> { jsxDEV } <span class="hljs-keyword">from</span> <span class="hljs-string">"./src/jsx/ReactJSXElement"</span>;
</code></pre>
<h3 id="t813.3 ReactJSXElement.js">3.3 ReactJSXElement.js <a href="#t813.3 ReactJSXElement.js"> # </a></h3>
<p>src\react\src\jsx\ReactJSXElement.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> hasOwnProperty <span class="hljs-keyword">from</span> <span class="hljs-string">"shared/hasOwnProperty"</span>;
<span class="hljs-keyword">import</span> { REACT_ELEMENT_TYPE } <span class="hljs-keyword">from</span> <span class="hljs-string">"shared/ReactSymbols"</span>;

<span class="hljs-keyword">const</span> RESERVED_PROPS = {
  <span class="hljs-attr">key</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">ref</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">__self</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">__source</span>: <span class="hljs-literal">true</span>,
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasValidRef</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-keyword">return</span> config.ref !== <span class="hljs-literal">undefined</span>;
}

<span class="hljs-keyword">const</span> ReactElement = <span class="hljs-function">(<span class="hljs-params">type, key, ref, props</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> element = {
    <span class="hljs-attr">$$typeof</span>: REACT_ELEMENT_TYPE,
    type,
    key,
    ref,
    props,
  };
  <span class="hljs-keyword">return</span> element;
};

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsxDEV</span>(<span class="hljs-params">type, config, maybeKey</span>) </span>{
  <span class="hljs-keyword">let</span> propName;
  <span class="hljs-keyword">const</span> props = {};
  <span class="hljs-keyword">let</span> key = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> ref = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (maybeKey !== <span class="hljs-literal">undefined</span>) {
    key = <span class="hljs-string">""</span> + maybeKey;
  }

  <span class="hljs-keyword">if</span> (hasValidRef(config)) {
    ref = config.ref;
  }

  <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> config) {
    <span class="hljs-keyword">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) {
      props[propName] = config[propName];
    }
  }
  <span class="hljs-keyword">return</span> ReactElement(type, key, ref, props);
}
</code></pre>
<h3 id="t823.4 ReactSymbols.js">3.4 ReactSymbols.js <a href="#t823.4 ReactSymbols.js"> # </a></h3>
<p>src\shared\ReactSymbols.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> REACT_ELEMENT_TYPE = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"react.element"</span>);
</code></pre>
<h3 id="t833.5 hasOwnProperty.js">3.5 hasOwnProperty.js <a href="#t833.5 hasOwnProperty.js"> # </a></h3>
<p>src\shared\hasOwnProperty.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { hasOwnProperty } = <span class="hljs-built_in">Object</span>.prototype;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> hasOwnProperty;
</code></pre>
<h2 id="t844.创建 ReactDOMRoot">4.创建 ReactDOMRoot <a href="#t844.创建 ReactDOMRoot"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/ReactDOMRoot_1664038441123.png" alt=""></p>
<h3 id="t854.1 main.jsx">4.1 main.jsx <a href="#t854.1 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { createRoot } from "react-dom/client";</span>
let element = (
  &lt;h1&gt;
    hello&lt;span style={{ color: "red" }}&gt;world&lt;/span&gt;
  &lt;/h1&gt;
);
<span class="hljs-addition">+const root = createRoot(document.getElementById("root"));</span>
<span class="hljs-addition">+console.log(root);</span>
</code></pre>
<h3 id="t864.2 client.js">4.2 client.js <a href="#t864.2 client.js"> # </a></h3>
<p>src\react-dom\client.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">"./src/client/ReactDOMRoot"</span>;
</code></pre>
<h3 id="t874.3 ReactDOMRoot.js">4.3 ReactDOMRoot.js <a href="#t874.3 ReactDOMRoot.js"> # </a></h3>
<p>src\react-dom\src\client\ReactDOMRoot.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { createContainer } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-reconciler/src/ReactFiberReconciler"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReactDOMRoot</span>(<span class="hljs-params">internalRoot</span>) </span>{
  <span class="hljs-keyword">this</span>._internalRoot = internalRoot;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRoot</span>(<span class="hljs-params">container</span>) </span>{
  <span class="hljs-keyword">const</span> root = createContainer(container);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReactDOMRoot(root);
}
</code></pre>
<h3 id="t884.4 ReactFiberReconciler.js">4.4 ReactFiberReconciler.js <a href="#t884.4 ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { createFiberRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactFiberRoot"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createContainer</span>(<span class="hljs-params">containerInfo</span>) </span>{
  <span class="hljs-keyword">return</span> createFiberRoot(containerInfo);
}
</code></pre>
<h3 id="t894.5 ReactFiberRoot.js">4.5 ReactFiberRoot.js <a href="#t894.5 ReactFiberRoot.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberRoot.js</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FiberRootNode</span>(<span class="hljs-params">containerInfo</span>) </span>{
  <span class="hljs-keyword">this</span>.containerInfo = containerInfo;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberRoot</span>(<span class="hljs-params">containerInfo</span>) </span>{
  <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> FiberRootNode(containerInfo);
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h2 id="t905.创建 RootFiber">5.创建 RootFiber <a href="#t905.创建 RootFiber"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/FiberRootNode_1664039001283.png" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/FiberRootNode_1664074436254.jpg" alt=""></p>
<h3 id="t915.1 ReactFiberRoot.js">5.1 ReactFiberRoot.js <a href="#t915.1 ReactFiberRoot.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberRoot.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { createHostRootFiber } from "./ReactFiber";</span>
function FiberRootNode(containerInfo) {
  this.containerInfo = containerInfo;
}

export function createFiberRoot(containerInfo) {
  const root = new FiberRootNode(containerInfo);
<span class="hljs-addition">+ const uninitializedFiber = createHostRootFiber();</span>
<span class="hljs-addition">+ root.current = uninitializedFiber;</span>
<span class="hljs-addition">+ uninitializedFiber.stateNode = root;</span>
  return root;
}
</code></pre>
<h3 id="t925.2 ReactFiber.js">5.2 ReactFiber.js <a href="#t925.2 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { HostRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactWorkTags"</span>;
<span class="hljs-keyword">import</span> { NoFlags } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactFiberFlags"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FiberNode</span>(<span class="hljs-params">tag, pendingProps, key</span>) </span>{
  <span class="hljs-keyword">this</span>.tag = tag;
  <span class="hljs-keyword">this</span>.key = key;
  <span class="hljs-keyword">this</span>.type = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.stateNode = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">this</span>.return = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.child = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.sibling = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">this</span>.pendingProps = pendingProps;
  <span class="hljs-keyword">this</span>.memoizedProps = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.updateQueue = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.memoizedState = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">this</span>.flags = NoFlags;
  <span class="hljs-keyword">this</span>.subtreeFlags = NoFlags;
  <span class="hljs-keyword">this</span>.alternate = <span class="hljs-literal">null</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiber</span>(<span class="hljs-params">tag, pendingProps, key</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FiberNode(tag, pendingProps, key);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createHostRootFiber</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> createFiber(HostRoot, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
}
</code></pre>
<h3 id="t935.3 ReactWorkTags.js">5.3 ReactWorkTags.js <a href="#t935.3 ReactWorkTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactWorkTags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HostRoot = <span class="hljs-number">3</span>;
</code></pre>
<h3 id="t945.4 ReactFiberFlags.js">5.4 ReactFiberFlags.js <a href="#t945.4 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoFlags = <span class="hljs-number">0b00000000000000000000000000</span>;
</code></pre>
<h2 id="t956.初始化 UpdateQueue">6.初始化 UpdateQueue <a href="#t956.初始化 UpdateQueue"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/initializeUpdateQueue_1664039386818.png" alt=""></p>
<h3 id="t966.1 ReactFiberRoot.js">6.1 ReactFiberRoot.js <a href="#t966.1 ReactFiberRoot.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberRoot.js</p>
<pre><code class="lang-diff">import { createHostRootFiber } from "./ReactFiber";
<span class="hljs-addition">+import { initializeUpdateQueue } from "./ReactFiberClassUpdateQueue";</span>
function FiberRootNode(containerInfo) {
  this.containerInfo = containerInfo;
}

export function createFiberRoot(containerInfo) {
  const root = new FiberRootNode(containerInfo);
  const uninitializedFiber = createHostRootFiber();
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
<span class="hljs-addition">+ initializeUpdateQueue(uninitializedFiber);</span>
  return root;
}
</code></pre>
<h3 id="t976.2 ReactFiberClassUpdateQueue.js">6.2 ReactFiberClassUpdateQueue.js <a href="#t976.2 ReactFiberClassUpdateQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberClassUpdateQueue.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initializeUpdateQueue</span>(<span class="hljs-params">fiber</span>) </span>{
  <span class="hljs-keyword">const</span> queue = {
    <span class="hljs-attr">shared</span>: {
      <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
    },
  };
  fiber.updateQueue = queue;
}
</code></pre>
<h2 id="t987. enqueueUpdate">7. enqueueUpdate <a href="#t987. enqueueUpdate"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/enqueueUpdate_1664039875650.png" alt=""></p>
<h3 id="t997.1 main.jsx">7.1 main.jsx <a href="#t997.1 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import { createRoot } from "react-dom/client";
let element = (
  &lt;h1&gt;
    hello&lt;span style={{ color: "red" }}&gt;world&lt;/span&gt;
  &lt;/h1&gt;
);
const root = createRoot(document.getElementById("root"));
<span class="hljs-addition">+root.render(element);</span>
</code></pre>
<h3 id="t1007.2 ReactDOMRoot.js">7.2 ReactDOMRoot.js <a href="#t1007.2 ReactDOMRoot.js"> # </a></h3>
<p>src\react-dom\src\client\ReactDOMRoot.js</p>
<pre><code class="lang-diff">import {
  createContainer,
<span class="hljs-addition">+ updateContainer,</span>
} from "react-reconciler/src/ReactFiberReconciler";

function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
<span class="hljs-addition">+ReactDOMRoot.prototype.render = function render(children) {</span>
<span class="hljs-addition">+  const root = this._internalRoot;</span>
<span class="hljs-addition">+  root.containerInfo.innerHTML = "";</span>
<span class="hljs-addition">+  updateContainer(children, root);</span>
<span class="hljs-addition">+};</span>
export function createRoot(container) {
  const root = createContainer(container);
  return new ReactDOMRoot(root);
}
</code></pre>
<h3 id="t1017.3 ReactFiberReconciler.js">7.3 ReactFiberReconciler.js <a href="#t1017.3 ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-diff">import { createFiberRoot } from "./ReactFiberRoot";
<span class="hljs-addition">+import { createUpdate, enqueueUpdate } from "./ReactFiberClassUpdateQueue";</span>
export function createContainer(containerInfo) {
  return createFiberRoot(containerInfo);
}
<span class="hljs-addition">+export function updateContainer(element, container) {</span>
<span class="hljs-addition">+  const current = container.current;</span>
<span class="hljs-addition">+  const update = createUpdate();</span>
<span class="hljs-addition">+  update.payload = { element };</span>
<span class="hljs-addition">+  const root = enqueueUpdate(current, update);</span>
<span class="hljs-addition">+  console.log(root);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t1027.4 ReactFiberClassUpdateQueue.js">7.4 ReactFiberClassUpdateQueue.js <a href="#t1027.4 ReactFiberClassUpdateQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberClassUpdateQueue.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { markUpdateLaneFromFiberToRoot } from "./ReactFiberConcurrentUpdates";</span>
<span class="hljs-addition">+export const UpdateState = 0;</span>
export function initializeUpdateQueue(fiber) {
  const queue = {
    shared: {
      pending: null,
    },
  };
  fiber.updateQueue = queue;
}
<span class="hljs-addition">+export function createUpdate() {</span>
<span class="hljs-addition">+  const update = { tag: UpdateState };</span>
<span class="hljs-addition">+  return update;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function enqueueUpdate(fiber, update) {</span>
<span class="hljs-addition">+  const updateQueue = fiber.updateQueue;</span>
<span class="hljs-addition">+  const sharedQueue = updateQueue.shared;</span>
<span class="hljs-addition">+  const pending = sharedQueue.pending;</span>
<span class="hljs-addition">+  if (pending === null) {</span>
<span class="hljs-addition">+    update.next = update;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    update.next = pending.next;</span>
<span class="hljs-addition">+    pending.next = update;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  updateQueue.shared.pending = update;</span>
<span class="hljs-addition">+  return markUpdateLaneFromFiberToRoot(fiber);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t1037.5 ReactFiberConcurrentUpdates.js">7.5 ReactFiberConcurrentUpdates.js <a href="#t1037.5 ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { HostRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactWorkTags"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markUpdateLaneFromFiberToRoot</span>(<span class="hljs-params">sourceFiber</span>) </span>{
  <span class="hljs-keyword">let</span> node = sourceFiber;
  <span class="hljs-keyword">let</span> parent = sourceFiber.return;
  <span class="hljs-keyword">while</span> (parent !== <span class="hljs-literal">null</span>) {
    node = parent;
    parent = parent.return;
  }
  <span class="hljs-keyword">if</span> (node.tag === HostRoot) {
    <span class="hljs-keyword">const</span> root = node.stateNode;
    <span class="hljs-keyword">return</span> root;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<h2 id="t1048.performConcurrentWorkOnRoot">8.performConcurrentWorkOnRoot <a href="#t1048.performConcurrentWorkOnRoot"> # </a></h2>
<h3 id="t1058.1 ReactFiberReconciler.js">8.1 ReactFiberReconciler.js <a href="#t1058.1 ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-diff">import { createFiberRoot } from "./ReactFiberRoot";
import { createUpdate, enqueueUpdate } from "./ReactFiberClassUpdateQueue";
<span class="hljs-addition">+import { scheduleUpdateOnFiber } from "./ReactFiberWorkLoop";</span>
export function createContainer(containerInfo) {
  return createFiberRoot(containerInfo);
}
export function updateContainer(element, container) {
  const current = container.current;
  const update = createUpdate();
  update.payload = { element };
  const root = enqueueUpdate(current, update);
<span class="hljs-addition">+ scheduleUpdateOnFiber(root);</span>
}
</code></pre>
<h3 id="t1068.2 ReactFiberWorkLoop.js">8.2 ReactFiberWorkLoop.js <a href="#t1068.2 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { scheduleCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">"scheduler"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleUpdateOnFiber</span>(<span class="hljs-params">root</span>) </span>{
  ensureRootIsScheduled(root);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureRootIsScheduled</span>(<span class="hljs-params">root</span>) </span>{
  scheduleCallback(performConcurrentWorkOnRoot.bind(<span class="hljs-literal">null</span>, root));
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performConcurrentWorkOnRoot</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"performConcurrentWorkOnRoot"</span>);
}
</code></pre>
<h3 id="t1078.3 scheduler\index.js">8.3 scheduler\index.js <a href="#t1078.3 scheduler\index.js"> # </a></h3>
<p>src\scheduler\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">"./src/forks/Scheduler"</span>;
</code></pre>
<h3 id="t1088.4 Scheduler.js">8.4 Scheduler.js <a href="#t1088.4 Scheduler.js"> # </a></h3>
<p>src\scheduler\src\forks\Scheduler.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleCallback</span>(<span class="hljs-params">callback</span>) </span>{
  requestIdleCallback(callback);
}
</code></pre>
<h2 id="t1099.prepareFreshStack">9.prepareFreshStack <a href="#t1099.prepareFreshStack"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/prepareFreshStack_1664040902497.png" alt=""></p>
<h3 id="t1109.1 ReactFiberWorkLoop.js">9.1 ReactFiberWorkLoop.js <a href="#t1109.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from "scheduler";
<span class="hljs-addition">+import { createWorkInProgress } from "./ReactFiber";</span>
<span class="hljs-addition">+let workInProgress = null;</span>
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
<span class="hljs-addition">+ renderRootSync(root);</span>
}
<span class="hljs-addition">+function prepareFreshStack(root) {</span>
<span class="hljs-addition">+  workInProgress = createWorkInProgress(root.current, null);</span>
<span class="hljs-addition">+  console.log(workInProgress);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function renderRootSync(root) {</span>
<span class="hljs-addition">+  prepareFreshStack(root);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t1119.2 ReactFiber.js">9.2 ReactFiber.js <a href="#t1119.2 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">import { HostRoot } from "./ReactWorkTags";
import { NoFlags } from "./ReactFiberFlags";
export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.alternate = null;
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
<span class="hljs-addition">+// We use a double buffering pooling technique because we know that we'll</span>
<span class="hljs-addition">+// only ever need at most two versions of a tree. We pool the "other" unused</span>
<span class="hljs-addition">+// node that we're free to reuse. This is lazily created to avoid allocating</span>
<span class="hljs-addition">+// extra objects for things that are never updated. It also allow us to</span>
<span class="hljs-addition">+// reclaim the extra memory if needed.</span>
<span class="hljs-addition">+//我们使用双缓冲池技术，因为我们知道一棵树最多只需要两个版本</span>
<span class="hljs-addition">+//我们将“其他”未使用的我们可以自由重用的节点</span>
<span class="hljs-addition">+//这是延迟创建的，以避免分配从未更新的内容的额外对象。它还允许我们如果需要，回收额外的内+存</span>
<span class="hljs-addition">+export function createWorkInProgress(current, pendingProps) {</span>
<span class="hljs-addition">+  let workInProgress = current.alternate;</span>
<span class="hljs-addition">+  if (workInProgress === null) {</span>
<span class="hljs-addition">+    workInProgress = createFiber(current.tag, pendingProps, current.key);</span>
<span class="hljs-addition">+    workInProgress.type = current.type;</span>
<span class="hljs-addition">+    workInProgress.stateNode = current.stateNode;</span>
<span class="hljs-addition">+    workInProgress.alternate = current;</span>
<span class="hljs-addition">+    current.alternate = workInProgress;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    workInProgress.pendingProps = pendingProps;</span>
<span class="hljs-addition">+    workInProgress.type = current.type;</span>
<span class="hljs-addition">+    workInProgress.flags = NoFlags;</span>
<span class="hljs-addition">+    workInProgress.subtreeFlags = NoFlags;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  workInProgress.child = current.child;</span>
<span class="hljs-addition">+  workInProgress.memoizedProps = current.memoizedProps;</span>
<span class="hljs-addition">+  workInProgress.memoizedState = current.memoizedState;</span>
<span class="hljs-addition">+  workInProgress.updateQueue = current.updateQueue;</span>
<span class="hljs-addition">+  workInProgress.sibling = current.sibling;</span>
<span class="hljs-addition">+  workInProgress.index = current.index;</span>
<span class="hljs-addition">+  return workInProgress;</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h2 id="t11210.beginWork">10.beginWork <a href="#t11210.beginWork"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/beginWork_1664042035288.png" alt=""></p>
<h3 id="t11310.1 ReactFiberWorkLoop.js">10.1 ReactFiberWorkLoop.js <a href="#t11310.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from "scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);

}
function renderRootSync(root) {
  prepareFreshStack(root);
<span class="hljs-addition">+ workLoopSync();</span>
}

<span class="hljs-addition">+function workLoopSync() {</span>
<span class="hljs-addition">+  while (workInProgress !== null) {</span>
<span class="hljs-addition">+    performUnitOfWork(workInProgress);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function performUnitOfWork(unitOfWork) {</span>
<span class="hljs-addition">+  const current = unitOfWork.alternate;</span>
<span class="hljs-addition">+  const next = beginWork(current, unitOfWork);</span>
<span class="hljs-addition">+  unitOfWork.memoizedProps = unitOfWork.pendingProps;</span>
<span class="hljs-addition">+  if (next === null) {</span>
<span class="hljs-addition">+    //completeUnitOfWork(unitOfWork);</span>
<span class="hljs-addition">+    workInProgress = null;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    workInProgress = next;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t11410.2 ReactFiberBeginWork.js">10.2 ReactFiberBeginWork.js <a href="#t11410.2 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { HostRoot, HostComponent, HostText } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactWorkTags"</span>;
<span class="hljs-keyword">import</span> { processUpdateQueue } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactFiberClassUpdateQueue"</span>;
<span class="hljs-keyword">import</span> { mountChildFibers, reconcileChildFibers } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactChildFiber"</span>;
<span class="hljs-keyword">import</span> { shouldSetTextContent } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom-bindings/src/client/ReactDOMHostConfig"</span>;
<span class="hljs-keyword">import</span> logger, { indent } <span class="hljs-keyword">from</span> <span class="hljs-string">"shared/logger"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildren</span>(<span class="hljs-params">current, workInProgress, nextChildren</span>) </span>{
  <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
    workInProgress.child = mountChildFibers(workInProgress, <span class="hljs-literal">null</span>, nextChildren);
  } <span class="hljs-keyword">else</span> {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHostRoot</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
  processUpdateQueue(workInProgress);
  <span class="hljs-keyword">const</span> nextState = workInProgress.memoizedState;
  <span class="hljs-keyword">const</span> nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  <span class="hljs-keyword">return</span> workInProgress.child;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHostComponent</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
  <span class="hljs-keyword">const</span> { type } = workInProgress;
  <span class="hljs-keyword">const</span> nextProps = workInProgress.pendingProps;
  <span class="hljs-keyword">let</span> nextChildren = nextProps.children;
  <span class="hljs-keyword">const</span> isDirectTextChild = shouldSetTextContent(type, nextProps);
  <span class="hljs-keyword">if</span> (isDirectTextChild) {
    nextChildren = <span class="hljs-literal">null</span>;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  <span class="hljs-keyword">return</span> workInProgress.child;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beginWork</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
  logger(<span class="hljs-string">" "</span>.repeat(indent.number) + <span class="hljs-string">"beginWork"</span>, workInProgress);
  <span class="hljs-keyword">switch</span> (workInProgress.tag) {
    <span class="hljs-keyword">case</span> HostRoot:
      <span class="hljs-keyword">return</span> updateHostRoot(current, workInProgress);
    <span class="hljs-keyword">case</span> HostComponent:
      <span class="hljs-keyword">return</span> updateHostComponent(current, workInProgress);
    <span class="hljs-keyword">case</span> HostText:
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<h3 id="t11510.3 ReactWorkTags.js">10.3 ReactWorkTags.js <a href="#t11510.3 ReactWorkTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactWorkTags.js</p>
<pre><code class="lang-diff">export const HostRoot = 3;
<span class="hljs-addition">+export const IndeterminateComponent = 2;</span>
<span class="hljs-addition">+export const HostComponent = 5;</span>
<span class="hljs-addition">+export const HostText = 6;</span>
</code></pre>
<h3 id="t11610.4 ReactFiberClassUpdateQueue.js">10.4 ReactFiberClassUpdateQueue.js <a href="#t11610.4 ReactFiberClassUpdateQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberClassUpdateQueue.js</p>
<pre><code class="lang-diff">import { markUpdateLaneFromFiberToRoot } from "./ReactFiberConcurrentUpdates";
<span class="hljs-addition">+import assign from "shared/assign";</span>
export const UpdateState = 0;
export function initializeUpdateQueue(fiber) {
  const queue = {
    shared: {
      pending: null,
    },
  };
  fiber.updateQueue = queue;
}
export function createUpdate() {
  const update = { tag: UpdateState };
  return update;
}
export function enqueueUpdate(fiber, update) {
  const updateQueue = fiber.updateQueue;
  const sharedQueue = updateQueue.shared;
  const pending = sharedQueue.pending;
  if (pending <span class="hljs-comment">=== null) {</span>
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }
  updateQueue.shared.pending = update;
  return markUpdateLaneFromFiberToRoot(fiber);
}

<span class="hljs-addition">+function getStateFromUpdate(update, prevState) {</span>
<span class="hljs-addition">+  switch (update.tag) {</span>
<span class="hljs-addition">+    case UpdateState: {</span>
<span class="hljs-addition">+      const { payload } = update;</span>
<span class="hljs-addition">+      const partialState = payload;</span>
<span class="hljs-addition">+      return assign({}, prevState, partialState);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return prevState;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function processUpdateQueue(workInProgress) {</span>
<span class="hljs-addition">+  const queue = workInProgress.updateQueue;</span>
<span class="hljs-addition">+  const pendingQueue = queue.shared.pending;</span>
<span class="hljs-addition">+  if (pendingQueue !== null) {</span>
<span class="hljs-addition">+    queue.shared.pending = null;</span>
<span class="hljs-addition">+    const lastPendingUpdate = pendingQueue;</span>
<span class="hljs-addition">+    const firstPendingUpdate = lastPendingUpdate.next;</span>
<span class="hljs-addition">+    lastPendingUpdate.next = null;</span>
<span class="hljs-addition">+    let newState = workInProgress.memoizedState;</span>
<span class="hljs-addition">+    let update = firstPendingUpdate;</span>
<span class="hljs-addition">+    while (update) {</span>
<span class="hljs-addition">+      newState = getStateFromUpdate(update, newState);</span>
<span class="hljs-addition">+      update = update.next;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    workInProgress.memoizedState = newState;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t11710.5 ReactChildFiber.js">10.5 ReactChildFiber.js <a href="#t11710.5 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { REACT_ELEMENT_TYPE } <span class="hljs-keyword">from</span> <span class="hljs-string">"shared/ReactSymbols"</span>;
<span class="hljs-keyword">import</span> isArray <span class="hljs-keyword">from</span> <span class="hljs-string">"shared/isArray"</span>;
<span class="hljs-keyword">import</span> { createFiberFromElement, FiberNode, createFiberFromText } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactFiber"</span>;
<span class="hljs-keyword">import</span> { Placement } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactFiberFlags"</span>;
<span class="hljs-keyword">import</span> { HostText } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactWorkTags"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createChildReconciler</span>(<span class="hljs-params">shouldTrackSideEffects</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileSingleElement</span>(<span class="hljs-params">returnFiber, currentFirstChild, element</span>) </span>{
    <span class="hljs-keyword">const</span> created = createFiberFromElement(element);
    created.return = returnFiber;
    <span class="hljs-keyword">return</span> created;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">placeSingleChild</span>(<span class="hljs-params">newFiber</span>) </span>{
    <span class="hljs-keyword">if</span> (shouldTrackSideEffects) newFiber.flags |= Placement;
    <span class="hljs-keyword">return</span> newFiber;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileSingleTextNode</span>(<span class="hljs-params">returnFiber, currentFirstChild, content</span>) </span>{
    <span class="hljs-keyword">const</span> created = <span class="hljs-keyword">new</span> FiberNode(HostText, { content }, <span class="hljs-literal">null</span>);
    created.return = returnFiber;
    <span class="hljs-keyword">return</span> created;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createChild</span>(<span class="hljs-params">returnFiber, newChild</span>) </span>{
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">"string"</span> &amp;&amp; newChild !== <span class="hljs-string">""</span>) || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">"number"</span>) {
      <span class="hljs-keyword">const</span> created = createFiberFromText(<span class="hljs-string">`<span class="hljs-subst">${newChild}</span>`</span>);
      created.return = returnFiber;
      <span class="hljs-keyword">return</span> created;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">"object"</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
        <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE: {
          <span class="hljs-keyword">const</span> created = createFiberFromElement(newChild);
          created.return = returnFiber;
          <span class="hljs-keyword">return</span> created;
        }
        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">placeChild</span>(<span class="hljs-params">newFiber, newIndex</span>) </span>{
    newFiber.index = newIndex;
    <span class="hljs-keyword">if</span> (shouldTrackSideEffects) newFiber.flags |= Placement;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildrenArray</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChildren</span>) </span>{
    <span class="hljs-keyword">let</span> resultingFirstChild = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> previousNewFiber = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> newIdx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) {
      <span class="hljs-keyword">const</span> newFiber = createChild(returnFiber, newChildren[newIdx]);
      <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">continue</span>;
      }
      placeChild(newFiber, newIdx);
      <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
        resultingFirstChild = newFiber;
      } <span class="hljs-keyword">else</span> {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
    <span class="hljs-keyword">return</span> resultingFirstChild;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildFibers</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChild</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">"object"</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
        <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE: {
          <span class="hljs-keyword">return</span> placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">if</span> (isArray(newChild)) {
        <span class="hljs-keyword">return</span> reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">"string"</span>) {
      <span class="hljs-keyword">return</span> placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">return</span> reconcileChildFibers;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> reconcileChildFibers = createChildReconciler(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mountChildFibers = createChildReconciler(<span class="hljs-literal">false</span>);
</code></pre>
<h3 id="t11810.6 ReactDOMHostConfig.js">10.6 ReactDOMHostConfig.js <a href="#t11810.6 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldSetTextContent</span>(<span class="hljs-params">type, props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> props.children === <span class="hljs-string">"string"</span> || <span class="hljs-keyword">typeof</span> props.children === <span class="hljs-string">"number"</span>;
}
</code></pre>
<h3 id="t11910.7 logger.js">10.7 logger.js <a href="#t11910.7 logger.js"> # </a></h3>
<p>src\shared\logger.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactWorkTags <span class="hljs-keyword">from</span> <span class="hljs-string">"react-reconciler/src/ReactWorkTags"</span>;
<span class="hljs-keyword">const</span> ReactWorkTagsMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> tag <span class="hljs-keyword">in</span> ReactWorkTags) {
  ReactWorkTagsMap.set(ReactWorkTags[tag], tag);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logger</span>(<span class="hljs-params">prefix, workInProgress</span>) </span>{
  <span class="hljs-keyword">let</span> tagValue = workInProgress.tag;
  <span class="hljs-keyword">let</span> tagName = ReactWorkTagsMap.get(tagValue);
  <span class="hljs-keyword">let</span> str = <span class="hljs-string">` <span class="hljs-subst">${tagName}</span> `</span>;
  <span class="hljs-keyword">if</span> (tagName === <span class="hljs-string">"HostComponent"</span>) {
    str += <span class="hljs-string">` <span class="hljs-subst">${workInProgress.type}</span> `</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tagName === <span class="hljs-string">"HostText"</span>) {
    str += <span class="hljs-string">` <span class="hljs-subst">${workInProgress.pendingProps}</span> `</span>;
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${prefix}</span> <span class="hljs-subst">${str}</span>`</span>);
}

<span class="hljs-keyword">let</span> indent = { <span class="hljs-attr">number</span>: <span class="hljs-number">0</span> };
<span class="hljs-keyword">export</span> { indent };
</code></pre>
<h3 id="t12010.8 assign.js">10.8 assign.js <a href="#t12010.8 assign.js"> # </a></h3>
<p>src\shared\assign.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { assign } = <span class="hljs-built_in">Object</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> assign;
</code></pre>
<h3 id="t12110.9 isArray.js">10.9 isArray.js <a href="#t12110.9 isArray.js"> # </a></h3>
<p>src\shared\isArray.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { isArray } = <span class="hljs-built_in">Array</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> isArray;
</code></pre>
<h3 id="t12210.10 ReactFiber.js">10.10 ReactFiber.js <a href="#t12210.10 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">import {
  HostRoot,
<span class="hljs-addition">+ IndeterminateComponent,</span>
<span class="hljs-addition">+ HostComponent,</span>
<span class="hljs-addition">+ HostText,</span>
} from "./ReactWorkTags";
import { NoFlags } from "./ReactFiberFlags";
export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.alternate = null;
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
//我们使用双缓冲池技术，因为我们知道一棵树最多只需要两个版本
//我们将“其他”未使用的我们可以自由重用的节点
//这是延迟创建的，以避免分配从未更新的内容的额外对象。它还允许我们如果需要，回收额外的内存
export function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  if (workInProgress <span class="hljs-comment">=== null) {</span>
    workInProgress = createFiber(current.tag, pendingProps, current.key);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
  }
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  return workInProgress;
}
<span class="hljs-addition">+export function createFiberFromTypeAndProps(type, key, pendingProps) {</span>
<span class="hljs-addition">+  let fiberTag = IndeterminateComponent;</span>
<span class="hljs-addition">+  if (typeof type === "string") {</span>
<span class="hljs-addition">+    fiberTag = HostComponent;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const fiber = createFiber(fiberTag, pendingProps, key);</span>
<span class="hljs-addition">+  fiber.type = type;</span>
<span class="hljs-addition">+  return fiber;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function createFiberFromElement(element) {</span>
<span class="hljs-addition">+  const { type } = element;</span>
<span class="hljs-addition">+  const { key } = element;</span>
<span class="hljs-addition">+  const pendingProps = element.props;</span>
<span class="hljs-addition">+  const fiber = createFiberFromTypeAndProps(type, key, pendingProps);</span>
<span class="hljs-addition">+  return fiber;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+export function createFiberFromText(content) {</span>
<span class="hljs-addition">+  const fiber = createFiber(HostText, content, null);</span>
<span class="hljs-addition">+  return fiber;</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t12310.11 ReactFiberFlags.js">10.11 ReactFiberFlags.js <a href="#t12310.11 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
<span class="hljs-addition">+export const Placement = 0b00000000000000000000000010;</span>
<span class="hljs-addition">+export const MutationMask = Placement;</span>
</code></pre>
<h2 id="t12411.completeUnitOfWork">11.completeUnitOfWork <a href="#t12411.completeUnitOfWork"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/completeUnitOfWork_1664043469315.png" alt=""></p>
<h3 id="t12511.1 ReactFiberWorkLoop.js">11.1 ReactFiberWorkLoop.js <a href="#t12511.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from "scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
<span class="hljs-addition">+import { completeWork } from "./ReactFiberCompleteWork";</span>
let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
<span class="hljs-addition">+   completeUnitOfWork(unitOfWork);</span>
  } else {
    workInProgress = next;
  }
}

<span class="hljs-addition">+function completeUnitOfWork(unitOfWork) {</span>
<span class="hljs-addition">+  let completedWork = unitOfWork;</span>
<span class="hljs-addition">+  do {</span>
<span class="hljs-addition">+    const current = completedWork.alternate;</span>
<span class="hljs-addition">+    const returnFiber = completedWork.return;</span>
<span class="hljs-addition">+    completeWork(current, completedWork);</span>
<span class="hljs-addition">+    const siblingFiber = completedWork.sibling;</span>
<span class="hljs-addition">+    if (siblingFiber !== null) {</span>
<span class="hljs-addition">+      workInProgress = siblingFiber;</span>
<span class="hljs-addition">+      return;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    completedWork = returnFiber;</span>
<span class="hljs-addition">+    workInProgress = completedWork;</span>
<span class="hljs-addition">+  } while (completedWork !== null);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t12611.2 ReactFiberCompleteWork.js">11.2 ReactFiberCompleteWork.js <a href="#t12611.2 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom-bindings/src/client/ReactDOMHostConfig"</span>;
<span class="hljs-keyword">import</span> { HostComponent, HostRoot, HostText } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactWorkTags"</span>;
<span class="hljs-keyword">import</span> { NoFlags } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactFiberFlags"</span>;
<span class="hljs-keyword">import</span> logger, { indent } <span class="hljs-keyword">from</span> <span class="hljs-string">"shared/logger"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleProperties</span>(<span class="hljs-params">completedWork</span>) </span>{
  <span class="hljs-keyword">let</span> subtreeFlags = NoFlags;
  <span class="hljs-keyword">let</span> child = completedWork.child;
  <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.subtreeFlags |= subtreeFlags;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendAllChildren</span>(<span class="hljs-params">parent, workInProgress</span>) </span>{
  <span class="hljs-comment">// 我们只有创建的顶级fiber，但需要递归其子节点来查找所有终端节点</span>
  <span class="hljs-keyword">let</span> node = workInProgress.child;
  <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 如果是原生节点，直接添加到父节点上</span>
    <span class="hljs-keyword">if</span> (node.tag === HostComponent || node.tag === HostText) {
      appendInitialChild(parent, node.stateNode);
      <span class="hljs-comment">// 再看看第一个节节点是不是原生节点</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// node.child.return = node</span>
      node = node.child;
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">if</span> (node === workInProgress) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 如果没有弟弟就找父亲的弟弟</span>
    <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// 如果找到了根节点或者回到了原节点结束</span>
      <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || node.return === workInProgress) {
        <span class="hljs-keyword">return</span>;
      }
      node = node.return;
    }
    <span class="hljs-comment">// node.sibling.return = node.return</span>
    <span class="hljs-comment">// 下一个弟弟节点</span>
    node = node.sibling;
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeWork</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
  indent.number -= <span class="hljs-number">2</span>;
  logger(<span class="hljs-string">" "</span>.repeat(indent.number) + <span class="hljs-string">"completeWork"</span>, workInProgress);
  <span class="hljs-keyword">const</span> newProps = workInProgress.pendingProps;
  <span class="hljs-keyword">switch</span> (workInProgress.tag) {
    <span class="hljs-keyword">case</span> HostComponent: {
      <span class="hljs-keyword">const</span> { type } = workInProgress;
      <span class="hljs-keyword">const</span> instance = createInstance(type, newProps, workInProgress);
      appendAllChildren(instance, workInProgress);
      workInProgress.stateNode = instance;
      finalizeInitialChildren(instance, type, newProps);
      bubbleProperties(workInProgress);
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> HostRoot:
      bubbleProperties(workInProgress);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> HostText: {
      <span class="hljs-keyword">const</span> newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">break</span>;
  }
}
</code></pre>
<h3 id="t12711.3 ReactDOMHostConfig.js">11.3 ReactDOMHostConfig.js <a href="#t12711.3 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { setInitialProperties } from "./ReactDOMComponent";</span>
export function shouldSetTextContent(type, props) {
  return (
    typeof props.children <span class="hljs-comment">=== "string" || typeof props.children === "number"</span>
  );
}
<span class="hljs-addition">+export const appendInitialChild = (parent, child) =&gt; {</span>
<span class="hljs-addition">+  parent.appendChild(child);</span>
<span class="hljs-addition">+};</span>
<span class="hljs-addition">+export const createInstance = (type, props, internalInstanceHandle) =&gt; {</span>
<span class="hljs-addition">+  const domElement = document.createElement(type);</span>
<span class="hljs-addition">+  return domElement;</span>
<span class="hljs-addition">+};</span>
<span class="hljs-addition">+export const createTextInstance = (content) =&gt; document.createTextNode+(content);</span>
<span class="hljs-addition">+export function finalizeInitialChildren(domElement, type, props) {</span>
<span class="hljs-addition">+  setInitialProperties(domElement, type, props);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t12811.4 ReactDOMComponent.js">11.4 ReactDOMComponent.js <a href="#t12811.4 ReactDOMComponent.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMComponent.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { setValueForStyles } <span class="hljs-keyword">from</span> <span class="hljs-string">"./CSSPropertyOperations"</span>;
<span class="hljs-keyword">import</span> setTextContent <span class="hljs-keyword">from</span> <span class="hljs-string">"./setTextContent"</span>;
<span class="hljs-keyword">import</span> { setValueForProperty } <span class="hljs-keyword">from</span> <span class="hljs-string">"./DOMPropertyOperations"</span>;
<span class="hljs-keyword">const</span> CHILDREN = <span class="hljs-string">"children"</span>;
<span class="hljs-keyword">const</span> STYLE = <span class="hljs-string">"style"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInitialDOMProperties</span>(<span class="hljs-params">tag, domElement, nextProps</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propKey <span class="hljs-keyword">in</span> nextProps) {
    <span class="hljs-keyword">if</span> (nextProps.hasOwnProperty(propKey)) {
      <span class="hljs-keyword">const</span> nextProp = nextProps[propKey];
      <span class="hljs-keyword">if</span> (propKey === STYLE) {
        setValueForStyles(domElement, nextProp);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === CHILDREN) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">"string"</span>) {
          setTextContent(domElement, nextProp);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">"number"</span>) {
          setTextContent(domElement, <span class="hljs-string">`<span class="hljs-subst">${nextProp}</span>`</span>);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {
        setValueForProperty(domElement, propKey, nextProp);
      }
    }
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInitialProperties</span>(<span class="hljs-params">domElement, tag, props</span>) </span>{
  setInitialDOMProperties(tag, domElement, props);
}
</code></pre>
<h3 id="t12911.5 CSSPropertyOperations.js">11.5 CSSPropertyOperations.js <a href="#t12911.5 CSSPropertyOperations.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\CSSPropertyOperations.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setValueForStyles</span>(<span class="hljs-params">node, styles</span>) </span>{
  <span class="hljs-keyword">const</span> { style } = node;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> styleName <span class="hljs-keyword">in</span> styles) {
    <span class="hljs-keyword">if</span> (styles.hasOwnProperty(styleName)) {
      <span class="hljs-keyword">const</span> styleValue = styles[styleName];
      style[styleName] = styleValue;
    }
  }
}
</code></pre>
<h3 id="t13011.6 setTextContent.js">11.6 setTextContent.js <a href="#t13011.6 setTextContent.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\setTextContent.js</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTextContent</span>(<span class="hljs-params">node, text</span>) </span>{
  node.textContent = text;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> setTextContent;
</code></pre>
<h3 id="t13111.7 DOMPropertyOperations.js">11.7 DOMPropertyOperations.js <a href="#t13111.7 DOMPropertyOperations.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\DOMPropertyOperations.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setValueForProperty</span>(<span class="hljs-params">node, name, value</span>) </span>{
  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
    node.removeAttribute(name);
  } <span class="hljs-keyword">else</span> {
    node.setAttribute(name, value);
  }
}
</code></pre>
<h2 id="t13212.commitRoot">12.commitRoot <a href="#t13212.commitRoot"> # </a></h2>
<h3 id="t13312.1 ReactFiberWorkLoop.js">12.1 ReactFiberWorkLoop.js <a href="#t13312.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from "scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
<span class="hljs-addition">+import { MutationMask, NoFlags } from "./ReactFiberFlags";</span>
let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
<span class="hljs-addition">+ const finishedWork = root.current.alternate;</span>
<span class="hljs-addition">+ printFiber(finishedWork);</span>
<span class="hljs-addition">+ console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);</span>
<span class="hljs-addition">+ root.finishedWork = finishedWork;</span>
<span class="hljs-addition">+ commitRoot(root);</span>
}
<span class="hljs-addition">+function commitRoot(root) {</span>
<span class="hljs-addition">+  const { finishedWork } = root;</span>
<span class="hljs-addition">+  const subtreeHasEffects =</span>
<span class="hljs-addition">+    (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;</span>
<span class="hljs-addition">+  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;</span>
<span class="hljs-addition">+  if (subtreeHasEffects || rootHasEffect) {</span>
<span class="hljs-addition">+    console.log("commitRoot");</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  root.current = finishedWork;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function printFiber(fiber) {</span>
<span class="hljs-addition">+  /*</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~Forked;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~PlacementDEV;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~Snapshot;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~PerformedWork;</span>
<span class="hljs-addition">+  */</span>
<span class="hljs-addition">+  if (fiber.flags !== 0) {</span>
<span class="hljs-addition">+    console.log(</span>
<span class="hljs-addition">+      getFlags(fiber.flags),</span>
<span class="hljs-addition">+      getTag(fiber.tag),</span>
<span class="hljs-addition">+      typeof fiber.type === "function" ? fiber.type.name : fiber.type,</span>
<span class="hljs-addition">+      fiber.memoizedProps</span>
<span class="hljs-addition">+    );</span>
<span class="hljs-addition">+    if (fiber.deletions) {</span>
<span class="hljs-addition">+      for (let i = 0; i &lt; fiber.deletions.length; i++) {</span>
<span class="hljs-addition">+        const childToDelete = fiber.deletions[i];</span>
<span class="hljs-addition">+        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.+memoizedProps);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  let child = fiber.child;</span>
<span class="hljs-addition">+  while (child) {</span>
<span class="hljs-addition">+    printFiber(child);</span>
<span class="hljs-addition">+    child = child.sibling;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getTag(tag) {</span>
<span class="hljs-addition">+  switch (tag) {</span>
<span class="hljs-addition">+    case FunctionComponent:</span>
<span class="hljs-addition">+      return `FunctionComponent`;</span>
<span class="hljs-addition">+    case HostRoot:</span>
<span class="hljs-addition">+      return `HostRoot`;</span>
<span class="hljs-addition">+    case HostComponent:</span>
<span class="hljs-addition">+      return `HostComponent`;</span>
<span class="hljs-addition">+    case HostText:</span>
<span class="hljs-addition">+      return HostText;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return tag;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getFlags(flags) {</span>
<span class="hljs-addition">+  if (flags === (Update | Placement | ChildDeletion)) {</span>
<span class="hljs-addition">+    return `自己移动和子元素有删除`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === (ChildDeletion | Update)) {</span>
<span class="hljs-addition">+    return `自己有更新和子元素有删除`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === ChildDeletion) {</span>
<span class="hljs-addition">+    return `子元素有删除`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === (Placement | Update)) {</span>
<span class="hljs-addition">+    return `移动并更新`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === Placement) {</span>
<span class="hljs-addition">+    return `插入`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === Update) {</span>
<span class="hljs-addition">+    return `更新`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return flags;</span>
<span class="hljs-addition">+}</span>

function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}
</code></pre>
<h2 id="t13413.commitMutationEffectsOnFiber">13.commitMutationEffectsOnFiber <a href="#t13413.commitMutationEffectsOnFiber"> # </a></h2>
<h3 id="t13513.1 ReactFiberWorkLoop.js">13.1 ReactFiberWorkLoop.js <a href="#t13513.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from "scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags } from "./ReactFiberFlags";
<span class="hljs-addition">+import { commitMutationEffectsOnFiber } from "./ReactFiberCommitWork";</span>
let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function commitRoot(root) {
  const { finishedWork } = root;
  const subtreeHasEffects =
    (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
<span class="hljs-addition">+   commitMutationEffectsOnFiber(finishedWork, root);</span>
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

</code></pre>
<h3 id="t13613.2 ReactFiberCommitWork.js">13.2 ReactFiberCommitWork.js <a href="#t13613.2 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { HostRoot, HostComponent, HostText } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactWorkTags"</span>;
<span class="hljs-keyword">import</span> { MutationMask, Placement } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactFiberFlags"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursivelyTraverseMutationEffects</span>(<span class="hljs-params">root, parentFiber</span>) </span>{
  <span class="hljs-keyword">if</span> (parentFiber.subtreeFlags &amp; MutationMask) {
    <span class="hljs-keyword">let</span> { child } = parentFiber;
    <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitPlacement</span>(<span class="hljs-params">finishedWork</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"commitPlacement"</span>, finishedWork);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitReconciliationEffects</span>(<span class="hljs-params">finishedWork</span>) </span>{
  <span class="hljs-keyword">const</span> { flags } = finishedWork;
  <span class="hljs-keyword">if</span> (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitMutationEffectsOnFiber</span>(<span class="hljs-params">finishedWork, root</span>) </span>{
  <span class="hljs-keyword">switch</span> (finishedWork.tag) {
    <span class="hljs-keyword">case</span> HostRoot:
    <span class="hljs-keyword">case</span> HostComponent:
    <span class="hljs-keyword">case</span> HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-attr">default</span>: {
      <span class="hljs-keyword">break</span>;
    }
  }
}
</code></pre>
<h2 id="t13714.commitPlacement">14.commitPlacement <a href="#t13714.commitPlacement"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/getHostSibling_1678678135594.png" alt=""></p>
<h3 id="t13814.1 ReactFiberCommitWork.js">14.1 ReactFiberCommitWork.js <a href="#t13814.1 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText } from "./ReactWorkTags";
import { MutationMask, Placement } from "./ReactFiberFlags";
<span class="hljs-addition">+import {</span>
<span class="hljs-addition">+  insertBefore,</span>
<span class="hljs-addition">+  appendChild,</span>
<span class="hljs-addition">+} from "react-dom-bindings/src/client/ReactDOMHostConfig";</span>
function recursivelyTraverseMutationEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
<span class="hljs-addition">+function isHostParent(fiber) {</span>
<span class="hljs-addition">+  return fiber.tag === HostComponent || fiber.tag === HostRoot;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getHostParentFiber(fiber) {</span>
<span class="hljs-addition">+  let parent = fiber.return;</span>
<span class="hljs-addition">+  while (parent !== null) {</span>
<span class="hljs-addition">+    if (isHostParent(parent)) {</span>
<span class="hljs-addition">+      return parent;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    parent = parent.return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return parent;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function insertOrAppendPlacementNode(node, before, parent) {</span>
<span class="hljs-addition">+  const { tag } = node;</span>
<span class="hljs-addition">+  const isHost = tag === HostComponent || tag === HostText;</span>
<span class="hljs-addition">+  if (isHost) {</span>
<span class="hljs-addition">+    const { stateNode } = node;</span>
<span class="hljs-addition">+    if (before) {</span>
<span class="hljs-addition">+      insertBefore(parent, stateNode, before);</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      appendChild(parent, stateNode);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    const { child } = node;</span>
<span class="hljs-addition">+    if (child !== null) {</span>
<span class="hljs-addition">+      insertOrAppendPlacementNode(child, before, parent);</span>
<span class="hljs-addition">+      let { sibling } = child;</span>
<span class="hljs-addition">+      while (sibling !== null) {</span>
<span class="hljs-addition">+        insertOrAppendPlacementNode(sibling, before, parent);</span>
<span class="hljs-addition">+        sibling = sibling.sibling;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getHostSibling(fiber) {</span>
<span class="hljs-addition">+  let node = fiber;</span>
<span class="hljs-addition">+  siblings: while (true) {</span>
<span class="hljs-addition">+    // 如果我们没有找到任何东西，让我们试试下一个弟弟</span>
<span class="hljs-addition">+    while (node.sibling === null) {</span>
<span class="hljs-addition">+      if (node.return === null || isHostParent(node.return)) {</span>
<span class="hljs-addition">+        // 如果我们是根Fiber或者父亲是原生节点，我们就是最后的弟弟</span>
<span class="hljs-addition">+        return null;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      node = node.return;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    // node.sibling.return = node.return</span>
<span class="hljs-addition">+    node = node.sibling;</span>
<span class="hljs-addition">+    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {</span>
<span class="hljs-addition">+      // 如果它不是原生节点，并且，我们可能在其中有一个原生节点</span>
<span class="hljs-addition">+      // 试着向下搜索，直到找到为止</span>
<span class="hljs-addition">+      if (node.flags &amp; Placement) {</span>
<span class="hljs-addition">+        // 如果我们没有孩子，可以试试弟弟</span>
<span class="hljs-addition">+        continue siblings;</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        // node.child.return = node</span>
<span class="hljs-addition">+        node = node.child;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } // Check if this host node is stable or about to be placed.</span>
<span class="hljs-addition">+    // 检查此原生节点是否稳定可以放置</span>
<span class="hljs-addition">+    if (!(node.flags &amp; Placement)) {</span>
<span class="hljs-addition">+      // 找到它了!</span>
<span class="hljs-addition">+      return node.stateNode;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
function commitPlacement(finishedWork) {
<span class="hljs-addition">+  const parentFiber = getHostParentFiber(finishedWork);</span>
<span class="hljs-addition">+  switch (parentFiber.tag) {</span>
<span class="hljs-addition">+    case HostComponent: {</span>
<span class="hljs-addition">+      const parent = parentFiber.stateNode;</span>
<span class="hljs-addition">+      const before = getHostSibling(finishedWork);</span>
<span class="hljs-addition">+      insertOrAppendPlacementNode(finishedWork, before, parent);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostRoot: {</span>
<span class="hljs-addition">+      const parent = parentFiber.stateNode.containerInfo;</span>
<span class="hljs-addition">+      const before = getHostSibling(finishedWork);</span>
<span class="hljs-addition">+      insertOrAppendPlacementNode(finishedWork, before, parent);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  switch (finishedWork.tag) {
    case HostRoot:
    case HostComponent:
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}
</code></pre>
<h3 id="t13914.2 ReactDOMHostConfig.js">14.2 ReactDOMHostConfig.js <a href="#t13914.2 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff">import { setInitialProperties } from "./ReactDOMComponent";
export function shouldSetTextContent(type, props) {
  return (
    typeof props.children <span class="hljs-comment">=== "string" || typeof props.children === "number"</span>
  );
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
<span class="hljs-addition">+export function appendChild(parentInstance, child) {</span>
<span class="hljs-addition">+  parentInstance.appendChild(child);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function insertBefore(parentInstance, child, beforeChild) {</span>
<span class="hljs-addition">+  parentInstance.insertBefore(child, beforeChild);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h2 id="t14015.函数组件">15.函数组件 <a href="#t14015.函数组件"> # </a></h2>
<h3 id="t14115.1 src\main.jsx">15.1 src\main.jsx <a href="#t14115.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import { createRoot } from "react-dom/client";
<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  return (</span>
<span class="hljs-addition">+    &lt;h1&gt;</span>
<span class="hljs-addition">+      hello&lt;span style={{ color: "red" }}&gt;world&lt;/span&gt;</span>
<span class="hljs-addition">+    &lt;/h1&gt;</span>
<span class="hljs-addition">+  );</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+let element = &lt;FunctionComponent /&gt;;</span>
const root = createRoot(document.getElementById("root"));
root.render(element);
</code></pre>
<h3 id="t14215.2 ReactWorkTags.js">15.2 ReactWorkTags.js <a href="#t14215.2 ReactWorkTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactWorkTags.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+export const FunctionComponent = 0;</span>
<span class="hljs-addition">+export const IndeterminateComponent = 2;</span>
export const HostRoot = 3;
export const HostComponent = 5;
export const HostText = 6;
</code></pre>
<h3 id="t14315.3 ReactFiberBeginWork.js">15.3 ReactFiberBeginWork.js <a href="#t14315.3 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import {
  HostRoot,
  HostComponent,
  HostText,
<span class="hljs-addition">+ IndeterminateComponent,</span>
<span class="hljs-addition">+ FunctionComponent,</span>
} from "./ReactWorkTags";
import { processUpdateQueue } from "./ReactFiberClassUpdateQueue";
import { mountChildFibers, reconcileChildFibers } from "./ReactChildFiber";
import { shouldSetTextContent } from "react-dom-bindings/src/client/ReactDOMHostConfig";
import logger, { indent } from "shared/logger";
<span class="hljs-addition">+import { renderWithHooks } from "react-reconciler/src/ReactFiberHooks";</span>
function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren
    );
  }
}
function updateHostRoot(current, workInProgress) {
  processUpdateQueue(workInProgress);
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
<span class="hljs-addition">+function mountIndeterminateComponent(_current, workInProgress, Component) {</span>
<span class="hljs-addition">+  const props = workInProgress.pendingProps;</span>
<span class="hljs-addition">+  const value = renderWithHooks(null, workInProgress, Component, props);</span>
<span class="hljs-addition">+  workInProgress.tag = FunctionComponent;</span>
<span class="hljs-addition">+  reconcileChildren(null, workInProgress, value);</span>
<span class="hljs-addition">+  return workInProgress.child;</span>
<span class="hljs-addition">+}</span>
export function beginWork(current, workInProgress) {
  logger(" ".repeat(indent.number) + "beginWork", workInProgress);
  indent.number += 2;
  switch (workInProgress.tag) {
<span class="hljs-addition">+   case IndeterminateComponent: {</span>
<span class="hljs-addition">+     return mountIndeterminateComponent(</span>
<span class="hljs-addition">+       current,</span>
<span class="hljs-addition">+       workInProgress,</span>
<span class="hljs-addition">+       workInProgress.type</span>
<span class="hljs-addition">+     );</span>
<span class="hljs-addition">+   }</span>
    case HostRoot:
      return updateHostRoot(current, workInProgress);
    case HostComponent:
      return updateHostComponent(current, workInProgress);
    case HostText:
    default:
      return null;
  }
}
</code></pre>
<h3 id="t14415.4 ReactFiberHooks.js">15.4 ReactFiberHooks.js <a href="#t14415.4 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderWithHooks</span>(<span class="hljs-params">current, workInProgress, Component, props</span>) </span>{
  <span class="hljs-keyword">const</span> children = Component(props);
  <span class="hljs-keyword">return</span> children;
}
</code></pre>
<h3 id="t14515.5 ReactFiberCommitWork.js">15.5 ReactFiberCommitWork.js <a href="#t14515.5 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import {
  HostRoot,
  HostComponent,
  HostText,
<span class="hljs-addition">+ FunctionComponent,</span>
} from "./ReactWorkTags";
import { MutationMask, Placement } from "./ReactFiberFlags";
import {
  insertBefore,
  appendChild,
} from "react-dom-bindings/src/client/ReactDOMHostConfig";
function recursivelyTraverseMutationEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // 如果我们没有找到任何东西，让我们试试下一个弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // 如果我们是根Fiber或者父亲是原生节点，我们就是最后的弟弟
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // 如果它不是原生节点，并且，我们可能在其中有一个原生节点
      // 试着向下搜索，直到找到为止
      if (node.flags &amp; Placement) {
        // 如果我们没有孩子，可以试试弟弟
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // 检查此原生节点是否稳定可以放置
    if (!(node.flags &amp; Placement)) {
      // 找到它了!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  switch (finishedWork.tag) {
    case HostRoot:
<span class="hljs-addition">+   case FunctionComponent:</span>
    case HostComponent:
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}
</code></pre>
<h2 id="t14616.注册事件名">16.注册事件名 <a href="#t14616.注册事件名"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/DOMPluginEventSystem_1678676652281.png" alt="DOMPluginEventSystem"></p>
<h3 id="t14716.1 src\main.jsx">16.1 src\main.jsx <a href="#t14716.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import { createRoot } from "react-dom/client";
function FunctionComponent() {
  return (
<span class="hljs-addition">+   &lt;h1</span>
<span class="hljs-addition">+     onClick={() =&gt; console.log("onClick FunctionComponent")}</span>
<span class="hljs-addition">+     onClickCapture={() =&gt; console.log("onClickCapture FunctionComponent")}</span>
<span class="hljs-addition">+   &gt;</span>
<span class="hljs-addition">+     hello</span>
<span class="hljs-addition">+     &lt;span</span>
<span class="hljs-addition">+       style={{ color: "red" }}</span>
<span class="hljs-addition">+       onClick={() =&gt; console.log("onClick span")}</span>
<span class="hljs-addition">+       onClickCapture={() =&gt; console.log("onClickCapture span")}</span>
<span class="hljs-addition">+     &gt;</span>
<span class="hljs-addition">+       world</span>
<span class="hljs-addition">+     &lt;/span&gt;</span>
<span class="hljs-addition">+   &lt;/h1&gt;</span>
  );
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);
</code></pre>
<h3 id="t14816.2 ReactDOMRoot.js">16.2 ReactDOMRoot.js <a href="#t14816.2 ReactDOMRoot.js"> # </a></h3>
<p>src\react-dom\src\client\ReactDOMRoot.js</p>
<pre><code class="lang-diff">import {
  createContainer,
  updateContainer,
} from "react-reconciler/src/ReactFiberReconciler";
<span class="hljs-addition">+import { listenToAllSupportedEvents } from "react-dom-bindings/src/events/DOMPluginEventSystem";</span>

function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMRoot.prototype.render = function render(children) {
  const root = this._internalRoot;
  root.containerInfo.innerHTML = "";
  updateContainer(children, root);
};
export function createRoot(container) {
  const root = createContainer(container);
<span class="hljs-addition">+ listenToAllSupportedEvents(container);</span>
  return new ReactDOMRoot(root);
}
</code></pre>
<h3 id="t14916.3 DOMPluginEventSystem.js">16.3 DOMPluginEventSystem.js <a href="#t14916.3 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { allNativeEvents } <span class="hljs-keyword">from</span> <span class="hljs-string">"./EventRegistry"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> SimpleEventPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">"./plugins/SimpleEventPlugin"</span>;
SimpleEventPlugin.registerEvents();
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listenToAllSupportedEvents</span>(<span class="hljs-params">rootContainerElement</span>) </span>{
  allNativeEvents.forEach(<span class="hljs-function">(<span class="hljs-params">domEventName</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(domEventName);
  });
}
</code></pre>
<h3 id="t15016.4 EventRegistry.js">16.4 EventRegistry.js <a href="#t15016.4 EventRegistry.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\EventRegistry.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> allNativeEvents = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerTwoPhaseEvent</span>(<span class="hljs-params">registrationName, dependencies</span>) </span>{
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + <span class="hljs-string">"Capture"</span>, dependencies);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerDirectEvent</span>(<span class="hljs-params">registrationName, dependencies</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dependencies.length; i++) {
    allNativeEvents.add(dependencies[i]); <span class="hljs-comment">// click</span>
  }
}
</code></pre>
<h3 id="t15116.5 SimpleEventPlugin.js">16.5 SimpleEventPlugin.js <a href="#t15116.5 SimpleEventPlugin.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\plugins\SimpleEventPlugin.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { registerSimpleEvents } <span class="hljs-keyword">from</span> <span class="hljs-string">"../DOMEventProperties"</span>;
<span class="hljs-keyword">export</span> { registerSimpleEvents <span class="hljs-keyword">as</span> registerEvents };
</code></pre>
<h3 id="t15216.6 DOMEventProperties.js">16.6 DOMEventProperties.js <a href="#t15216.6 DOMEventProperties.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMEventProperties.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { registerTwoPhaseEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">"./EventRegistry"</span>;

<span class="hljs-keyword">const</span> simpleEventPluginEvents = [<span class="hljs-string">"click"</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerSimpleEvent</span>(<span class="hljs-params">domEventName, reactName</span>) </span>{
  registerTwoPhaseEvent(reactName, [domEventName]);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerSimpleEvents</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; simpleEventPluginEvents.length; i++) {
    <span class="hljs-keyword">const</span> eventName = simpleEventPluginEvents[i]; <span class="hljs-comment">// click</span>
    <span class="hljs-keyword">const</span> domEventName = eventName.toLowerCase(); <span class="hljs-comment">// click</span>
    <span class="hljs-keyword">const</span> capitalizedEvent = eventName[<span class="hljs-number">0</span>].toUpperCase() + eventName.slice(<span class="hljs-number">1</span>); <span class="hljs-comment">// Click</span>
    registerSimpleEvent(domEventName, <span class="hljs-string">`on<span class="hljs-subst">${capitalizedEvent}</span>`</span>); <span class="hljs-comment">// click=&gt;onClick</span>
  }
}
</code></pre>
<h2 id="t15317.listenToNativeEvent">17.listenToNativeEvent <a href="#t15317.listenToNativeEvent"> # </a></h2>
<h3 id="t15417.1 DOMPluginEventSystem.js">17.1 DOMPluginEventSystem.js <a href="#t15417.1 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-diff">import { allNativeEvents } from "./EventRegistry";
import * as SimpleEventPlugin from "./plugins/SimpleEventPlugin";
<span class="hljs-addition">+import { createEventListenerWrapperWithPriority } from "./ReactDOMEventListener";</span>
<span class="hljs-addition">+import { IS_CAPTURE_PHASE } from "./EventSystemFlags";</span>
<span class="hljs-addition">+import { addEventCaptureListener, addEventBubbleListener } from "./EventListener";</span>

SimpleEventPlugin.registerEvents();

export function listenToAllSupportedEvents(rootContainerElement) {
  allNativeEvents.forEach((domEventName) =&gt; {
<span class="hljs-addition">+   listenToNativeEvent(domEventName, true, rootContainerElement);</span>
<span class="hljs-addition">+   listenToNativeEvent(domEventName, false, rootContainerElement);</span>
  });
}

<span class="hljs-addition">+export function listenToNativeEvent(domEventName, isCapturePhaseListener, +target) {</span>
<span class="hljs-addition">+  let eventSystemFlags = 0; // 冒泡 = 0 捕获 = 4</span>
<span class="hljs-addition">+  if (isCapturePhaseListener) {</span>
<span class="hljs-addition">+    eventSystemFlags |= IS_CAPTURE_PHASE;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function addTrappedEventListener(targetContainer, domEventName, +eventSystemFlags, isCapturePhaseListener) {</span>
<span class="hljs-addition">+  const listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);</span>
<span class="hljs-addition">+  if (isCapturePhaseListener) {</span>
<span class="hljs-addition">+    addEventCaptureListener(targetContainer, domEventName, listener);</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    addEventBubbleListener(targetContainer, domEventName, listener);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t15517.2 EventSystemFlags.js">17.2 EventSystemFlags.js <a href="#t15517.2 EventSystemFlags.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\EventSystemFlags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IS_CAPTURE_PHASE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;
</code></pre>
<h3 id="t15617.3 ReactDOMEventListener.js">17.3 ReactDOMEventListener.js <a href="#t15617.3 ReactDOMEventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\ReactDOMEventListener.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createEventListenerWrapperWithPriority</span>(<span class="hljs-params">targetContainer, domEventName, eventSystemFlags</span>) </span>{
  <span class="hljs-keyword">const</span> listenerWrapper = dispatchDiscreteEvent;
  <span class="hljs-keyword">return</span> listenerWrapper.bind(<span class="hljs-literal">null</span>, domEventName, eventSystemFlags, targetContainer);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchDiscreteEvent</span>(<span class="hljs-params">domEventName, eventSystemFlags, container, nativeEvent</span>) </span>{
  dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchEvent</span>(<span class="hljs-params">domEventName, eventSystemFlags, targetContainer, nativeEvent</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"dispatchEvent"</span>, domEventName, eventSystemFlags, targetContainer, nativeEvent);
}
</code></pre>
<h3 id="t15717.4 EventListener.js">17.4 EventListener.js <a href="#t15717.4 EventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\EventListener.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventCaptureListener</span>(<span class="hljs-params">target, eventType, listener</span>) </span>{
  target.addEventListener(eventType, listener, <span class="hljs-literal">true</span>);
  <span class="hljs-keyword">return</span> listener;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventBubbleListener</span>(<span class="hljs-params">target, eventType, listener</span>) </span>{
  target.addEventListener(eventType, listener, <span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> listener;
}
</code></pre>
<h2 id="t15818.extractEvents">18.extractEvents <a href="#t15818.extractEvents"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/extractEvents2_1678678999496.png" alt=""></p>
<h3 id="t15918.1 ReactDOMEventListener.js">18.1 ReactDOMEventListener.js <a href="#t15918.1 ReactDOMEventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\ReactDOMEventListener.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import getEventTarget from "./getEventTarget";</span>
<span class="hljs-addition">+import { getClosestInstanceFromNode } from "../client/ReactDOMComponentTree";</span>
<span class="hljs-addition">+import { dispatchEventForPluginEventSystem } from "./DOMPluginEventSystem";</span>

<span class="hljs-addition">+export function createEventListenerWrapperWithPriority(</span>
<span class="hljs-addition">+  targetContainer,</span>
<span class="hljs-addition">+  domEventName,</span>
<span class="hljs-addition">+  eventSystemFlags</span>
<span class="hljs-addition">+) {</span>
<span class="hljs-addition">+  const listenerWrapper = dispatchDiscreteEvent;</span>
<span class="hljs-addition">+  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {</span>
<span class="hljs-addition">+  dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);</span>
<span class="hljs-addition">+}</span>
export function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
<span class="hljs-addition">+ const nativeEventTarget = getEventTarget(nativeEvent);</span>
<span class="hljs-addition">+ const targetInst = getClosestInstanceFromNode(nativeEventTarget);</span>
<span class="hljs-addition">+ dispatchEventForPluginEventSystem(</span>
<span class="hljs-addition">+   domEventName,</span>
<span class="hljs-addition">+   eventSystemFlags,</span>
<span class="hljs-addition">+   nativeEvent,</span>
<span class="hljs-addition">+   targetInst,</span>
<span class="hljs-addition">+   targetContainer</span>
<span class="hljs-addition">+ );</span>
}
</code></pre>
<h3 id="t16018.2 getEventTarget.js">18.2 getEventTarget.js <a href="#t16018.2 getEventTarget.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\getEventTarget.js</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventTarget</span>(<span class="hljs-params">nativeEvent</span>) </span>{
  <span class="hljs-keyword">const</span> target = nativeEvent.target || nativeEvent.srcElement || <span class="hljs-built_in">window</span>;
  <span class="hljs-keyword">return</span> target;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> getEventTarget;
</code></pre>
<h3 id="t16118.3 ReactDOMComponentTree.js">18.3 ReactDOMComponentTree.js <a href="#t16118.3 ReactDOMComponentTree.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMComponentTree.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> randomKey = <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).slice(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> internalInstanceKey = <span class="hljs-string">"__reactFiber$"</span> + randomKey;
<span class="hljs-keyword">const</span> internalPropsKey = <span class="hljs-string">"__reactProps$"</span> + randomKey;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getClosestInstanceFromNode</span>(<span class="hljs-params">targetNode</span>) </span>{
  <span class="hljs-keyword">const</span> targetInst = targetNode[internalInstanceKey];
  <span class="hljs-keyword">if</span> (targetInst) {
    <span class="hljs-keyword">return</span> targetInst;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFiberCurrentPropsFromNode</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">return</span> node[internalPropsKey] || <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">precacheFiberNode</span>(<span class="hljs-params">hostInst, node</span>) </span>{
  node[internalInstanceKey] = hostInst;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFiberProps</span>(<span class="hljs-params">node, props</span>) </span>{
  node[internalPropsKey] = props;
}
</code></pre>
<h3 id="t16218.4 DOMPluginEventSystem.js">18.4 DOMPluginEventSystem.js <a href="#t16218.4 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-diff">import { allNativeEvents } from "./EventRegistry";
import * as SimpleEventPlugin from "./plugins/SimpleEventPlugin";
import { createEventListenerWrapperWithPriority } from "./ReactDOMEventListener";
import { IS_CAPTURE_PHASE } from "./EventSystemFlags";
import { addEventCaptureListener, addEventBubbleListener } from "./EventListener";
<span class="hljs-addition">+import getEventTarget from "./getEventTarget";</span>
<span class="hljs-addition">+import getListener from "./getListener";</span>
<span class="hljs-addition">+import { HostComponent } from "react-reconciler/src/ReactWorkTags";</span>

SimpleEventPlugin.registerEvents();

export function listenToAllSupportedEvents(rootContainerElement) {
  allNativeEvents.forEach((domEventName) =&gt; {
    listenToNativeEvent(domEventName, true, rootContainerElement);
    listenToNativeEvent(domEventName, false, rootContainerElement);
  });
}

export function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  let eventSystemFlags = 0; // 冒泡 = 0 捕获 = 4
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }
  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
  const listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
  if (isCapturePhaseListener) {
    addEventCaptureListener(targetContainer, domEventName, listener);
  } else {
    addEventBubbleListener(targetContainer, domEventName, listener);
  }
}
<span class="hljs-addition">+export function dispatchEventForPluginEventSystem(</span>
<span class="hljs-addition">+  domEventName,</span>
<span class="hljs-addition">+  eventSystemFlags,</span>
<span class="hljs-addition">+  nativeEvent,</span>
<span class="hljs-addition">+  targetInst,</span>
<span class="hljs-addition">+  targetContainer</span>
<span class="hljs-addition">+) {</span>
<span class="hljs-addition">+  dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {</span>
<span class="hljs-addition">+  const nativeEventTarget = getEventTarget(nativeEvent);</span>
<span class="hljs-addition">+  const dispatchQueue = [];</span>
<span class="hljs-addition">+  extractEvents(</span>
<span class="hljs-addition">+    dispatchQueue,</span>
<span class="hljs-addition">+    domEventName,</span>
<span class="hljs-addition">+    targetInst,</span>
<span class="hljs-addition">+    nativeEvent,</span>
<span class="hljs-addition">+    nativeEventTarget,</span>
<span class="hljs-addition">+    eventSystemFlags,</span>
<span class="hljs-addition">+    targetContainer</span>
<span class="hljs-addition">+  );</span>
<span class="hljs-addition">+  console.log("dispatchQueue", dispatchQueue);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function extractEvents(</span>
<span class="hljs-addition">+  dispatchQueue,</span>
<span class="hljs-addition">+  domEventName,</span>
<span class="hljs-addition">+  targetInst,</span>
<span class="hljs-addition">+  nativeEvent,</span>
<span class="hljs-addition">+  nativeEventTarget,</span>
<span class="hljs-addition">+  eventSystemFlags,</span>
<span class="hljs-addition">+  targetContainer</span>
<span class="hljs-addition">+) {</span>
<span class="hljs-addition">+  SimpleEventPlugin.extractEvents(</span>
<span class="hljs-addition">+    dispatchQueue,</span>
<span class="hljs-addition">+    domEventName,</span>
<span class="hljs-addition">+    targetInst,</span>
<span class="hljs-addition">+    nativeEvent,</span>
<span class="hljs-addition">+    nativeEventTarget,</span>
<span class="hljs-addition">+    eventSystemFlags,</span>
<span class="hljs-addition">+    targetContainer</span>
<span class="hljs-addition">+  );</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase) {</span>
<span class="hljs-addition">+  const captureName = reactName + "Capture";</span>
<span class="hljs-addition">+  const reactEventName = inCapturePhase ? captureName : reactName;</span>
<span class="hljs-addition">+  const listeners = [];</span>
<span class="hljs-addition">+  let instance = targetFiber;</span>
<span class="hljs-addition">+  while (instance !== null) {</span>
<span class="hljs-addition">+    const { stateNode, tag } = instance;</span>
<span class="hljs-addition">+    if (tag === HostComponent &amp;&amp; stateNode !== null) {</span>
<span class="hljs-addition">+      if (reactEventName !== null) {</span>
<span class="hljs-addition">+        const listener = getListener(instance, reactEventName);</span>
<span class="hljs-addition">+        if (listener !== null &amp;&amp; listener !== undefined) {</span>
<span class="hljs-addition">+          listeners.push(createDispatchListener(instance, listener, stateNode));</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    instance = instance.return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return listeners;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function createDispatchListener(instance, listener, currentTarget) {</span>
<span class="hljs-addition">+  return {</span>
<span class="hljs-addition">+    instance,</span>
<span class="hljs-addition">+    listener,</span>
<span class="hljs-addition">+    currentTarget,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t16318.5 getListener.js">18.5 getListener.js <a href="#t16318.5 getListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\getListener.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { getFiberCurrentPropsFromNode } <span class="hljs-keyword">from</span> <span class="hljs-string">"../client/ReactDOMComponentTree"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListener</span>(<span class="hljs-params">inst, registrationName</span>) </span>{
  <span class="hljs-keyword">const</span> stateNode = inst.stateNode;
  <span class="hljs-keyword">if</span> (stateNode === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">const</span> props = getFiberCurrentPropsFromNode(stateNode);
  <span class="hljs-keyword">if</span> (props === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">const</span> listener = props[registrationName];
  <span class="hljs-keyword">return</span> listener;
}
</code></pre>
<h3 id="t16418.6 SimpleEventPlugin.js">18.6 SimpleEventPlugin.js <a href="#t16418.6 SimpleEventPlugin.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\plugins\SimpleEventPlugin.js</p>
<pre><code class="lang-diff">import { registerSimpleEvents, topLevelEventsToReactNames } from "../DOMEventProperties";
import { SyntheticMouseEvent } from "../SyntheticEvent";
import { IS_CAPTURE_PHASE } from "../EventSystemFlags";
import { accumulateSinglePhaseListeners } from "../DOMPluginEventSystem";

<span class="hljs-addition">+function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {</span>
<span class="hljs-addition">+  const reactName = topLevelEventsToReactNames.get(domEventName);</span>
<span class="hljs-addition">+  let SyntheticEventCtor;</span>
<span class="hljs-addition">+  switch (domEventName) {</span>
<span class="hljs-addition">+    case "click":</span>
<span class="hljs-addition">+      SyntheticEventCtor = SyntheticMouseEvent;</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== 0;</span>
<span class="hljs-addition">+  const listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase);</span>
<span class="hljs-addition">+  if (listeners.length &gt; 0) {</span>
<span class="hljs-addition">+    const event = new SyntheticEventCtor(reactName, domEventName, targetInst, nativeEvent, nativeEventTarget);</span>
<span class="hljs-addition">+    dispatchQueue.push({</span>
<span class="hljs-addition">+      event,</span>
<span class="hljs-addition">+      listeners,</span>
<span class="hljs-addition">+    });</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export { registerSimpleEvents as registerEvents, extractEvents };</span>
</code></pre>
<h3 id="t16518.7 SyntheticEvent.js">18.7 SyntheticEvent.js <a href="#t16518.7 SyntheticEvent.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\SyntheticEvent.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> assign <span class="hljs-keyword">from</span> <span class="hljs-string">"shared/assign"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionThatReturnsTrue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionThatReturnsFalse</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
<span class="hljs-keyword">const</span> MouseEventInterface = {
  <span class="hljs-attr">clientX</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">clientY</span>: <span class="hljs-number">0</span>,
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSyntheticEvent</span>(<span class="hljs-params">Interface</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SyntheticBaseEvent</span>(<span class="hljs-params">reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget</span>) </span>{
    <span class="hljs-keyword">this</span>._reactName = reactName;
    <span class="hljs-keyword">this</span>.type = reactEventType;
    <span class="hljs-keyword">this</span>._targetInst = targetInst;
    <span class="hljs-keyword">this</span>.nativeEvent = nativeEvent;
    <span class="hljs-keyword">this</span>.target = nativeEventTarget;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propName <span class="hljs-keyword">in</span> Interface) {
      <span class="hljs-keyword">if</span> (!Interface.hasOwnProperty(propName)) {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">this</span>[propName] = nativeEvent[propName];
    }
    <span class="hljs-keyword">this</span>.isDefaultPrevented = functionThatReturnsFalse;
    <span class="hljs-keyword">this</span>.isPropagationStopped = functionThatReturnsFalse;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  assign(SyntheticBaseEvent.prototype, {
    preventDefault() {
      <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">this</span>.nativeEvent;
      <span class="hljs-keyword">if</span> (event.preventDefault) {
        event.preventDefault();
      } <span class="hljs-keyword">else</span> {
        event.returnValue = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">this</span>.isDefaultPrevented = functionThatReturnsTrue;
    },
    stopPropagation() {
      <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">this</span>.nativeEvent;
      <span class="hljs-keyword">if</span> (event.stopPropagation) {
        event.stopPropagation();
      } <span class="hljs-keyword">else</span> {
        event.cancelBubble = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">this</span>.isPropagationStopped = functionThatReturnsTrue;
    },
  });
  <span class="hljs-keyword">return</span> SyntheticBaseEvent;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
</code></pre>
<h3 id="t16618.8 ReactDOMHostConfig.js">18.8 ReactDOMHostConfig.js <a href="#t16618.8 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff">import { setInitialProperties } from "./ReactDOMComponent";
<span class="hljs-addition">+import { precacheFiberNode, updateFiberProps } from "./ReactDOMComponentTree";</span>

export function shouldSetTextContent(type, props) {
  return typeof props.children <span class="hljs-comment">=== "string" || typeof props.children === "number";</span>
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
<span class="hljs-addition">+ precacheFiberNode(internalInstanceHandle, domElement);</span>
<span class="hljs-addition">+ updateFiberProps(domElement, props);</span>
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
export function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
export function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}
</code></pre>
<h3 id="t16718.9 DOMEventProperties.js">18.9 DOMEventProperties.js <a href="#t16718.9 DOMEventProperties.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMEventProperties.js</p>
<pre><code class="lang-diff">import { registerTwoPhaseEvent } from "./EventRegistry";
<span class="hljs-addition">+export const topLevelEventsToReactNames = new Map();</span>
const simpleEventPluginEvents = ["click"];
function registerSimpleEvent(domEventName, reactName) {
<span class="hljs-addition">+ topLevelEventsToReactNames.set(domEventName, reactName);</span>
  registerTwoPhaseEvent(reactName, [domEventName]);
}

export function registerSimpleEvents() {
  for (let i = 0; i &lt; simpleEventPluginEvents.length; i++) {
    const eventName = simpleEventPluginEvents[i]; // click
    const domEventName = eventName.toLowerCase(); // click
    const capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1); // Click
    registerSimpleEvent(domEventName, `on${capitalizedEvent}`); // click=&gt;onClick
  }
}

</code></pre>
<h2 id="t16819.processDispatchQueue">19.processDispatchQueue <a href="#t16819.processDispatchQueue"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/processDispatchQueue1_1678679016915.png" alt=""></p>
<h3 id="t16919.1 DOMPluginEventSystem.js">19.1 DOMPluginEventSystem.js <a href="#t16919.1 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-diff">import { allNativeEvents } from "./EventRegistry";
import * as SimpleEventPlugin from "./plugins/SimpleEventPlugin";
import { createEventListenerWrapperWithPriority } from "./ReactDOMEventListener";
import { IS_CAPTURE_PHASE } from "./EventSystemFlags";
import { addEventCaptureListener, addEventBubbleListener } from "./EventListener";
import getEventTarget from "./getEventTarget";
import getListener from "./getListener";
import { HostComponent } from "react-reconciler/src/ReactWorkTags";

SimpleEventPlugin.registerEvents();

export function listenToAllSupportedEvents(rootContainerElement) {
  allNativeEvents.forEach((domEventName) =&gt; {
    listenToNativeEvent(domEventName, true, rootContainerElement);
    listenToNativeEvent(domEventName, false, rootContainerElement);
  });
}

export function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  let eventSystemFlags = 0; // 冒泡 = 0 捕获 = 4
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }
  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
  const listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
  if (isCapturePhaseListener) {
    addEventCaptureListener(targetContainer, domEventName, listener);
  } else {
    addEventBubbleListener(targetContainer, domEventName, listener);
  }
}
export function dispatchEventForPluginEventSystem(
  domEventName,
  eventSystemFlags,
  nativeEvent,
  targetInst,
  targetContainer
) {
  dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer);
}

function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const dispatchQueue = [];
  extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
<span class="hljs-addition">+ processDispatchQueue(dispatchQueue, eventSystemFlags);</span>
}

<span class="hljs-addition">+export function processDispatchQueue(dispatchQueue, eventSystemFlags) {</span>
<span class="hljs-addition">+  const inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== 0;</span>
<span class="hljs-addition">+  for (let i = 0; i &lt; dispatchQueue.length; i++) {</span>
<span class="hljs-addition">+    const { event, listeners } = dispatchQueue[i];</span>
<span class="hljs-addition">+    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {</span>
<span class="hljs-addition">+  if (inCapturePhase) {</span>
<span class="hljs-addition">+    for (let i = dispatchListeners.length - 1; i &gt;= 0; i--) {</span>
<span class="hljs-addition">+      const { currentTarget, listener } = dispatchListeners[i];</span>
<span class="hljs-addition">+      if (event.isPropagationStopped()) {</span>
<span class="hljs-addition">+        return;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      executeDispatch(event, listener, currentTarget);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    for (let i = 0; i &lt; dispatchListeners.length; i++) {</span>
<span class="hljs-addition">+      const { currentTarget, listener } = dispatchListeners[i];</span>
<span class="hljs-addition">+      if (event.isPropagationStopped()) {</span>
<span class="hljs-addition">+        return;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      executeDispatch(event, listener, currentTarget);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function executeDispatch(event, listener, currentTarget) {</span>
<span class="hljs-addition">+  event.currentTarget = currentTarget;</span>
<span class="hljs-addition">+  listener(event);</span>
<span class="hljs-addition">+  event.currentTarget = null;</span>
<span class="hljs-addition">+}</span>
function extractEvents(
  dispatchQueue,
  domEventName,
  targetInst,
  nativeEvent,
  nativeEventTarget,
  eventSystemFlags,
  targetContainer
) {
  SimpleEventPlugin.extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
}

export function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase) {
  const captureName = reactName + "Capture";
  const reactEventName = inCapturePhase ? captureName : reactName;
  const listeners = [];
  let instance = targetFiber;
  while (instance !== null) {
    const { stateNode, tag } = instance;
    if (tag <span class="hljs-comment">=== HostComponent &amp;&amp; stateNode !== null) {</span>
      if (reactEventName !== null) {
        const listener = getListener(instance, reactEventName);
        if (listener !== null &amp;&amp; listener !== undefined) {
          listeners.push(createDispatchListener(instance, listener, stateNode));
        }
      }
    }
    instance = instance.return;
  }

  return listeners;
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance,
    listener,
    currentTarget,
  };
}
</code></pre>
<h2 id="t17020.mountReducer">20.mountReducer <a href="#t17020.mountReducer"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/renderWithHooks_1678680863642.png" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/mountReducer_1678679227351.png" alt=""></p>
<h3 id="t17120.1 src\main.jsx">20.1 src\main.jsx <a href="#t17120.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";
<span class="hljs-addition">+const reducer = (state, action) =&gt; {</span>
<span class="hljs-addition">+  if (action.type === "add") return state + 1;</span>
<span class="hljs-addition">+  return state;</span>
<span class="hljs-addition">+};</span>
function FunctionComponent() {
<span class="hljs-addition">+  const [number, setNumber] = React.useReducer(reducer, 0);</span>
<span class="hljs-addition">+  return &lt;button onClick={() =&gt; setNumber({ type: "add" })}&gt;{number}&lt;/button&gt;;</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);
</code></pre>
<h3 id="t17220.2 ReactFiberHooks.js">20.2 ReactFiberHooks.js <a href="#t17220.2 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import ReactSharedInternals from "shared/ReactSharedInternals";</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+const { ReactCurrentDispatcher } = ReactSharedInternals;</span>
<span class="hljs-addition">+let currentlyRenderingFiber = null;</span>
<span class="hljs-addition">+let workInProgressHook = null;</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function mountWorkInProgressHook() {</span>
<span class="hljs-addition">+  const hook = {</span>
<span class="hljs-addition">+    memoizedState: null,</span>
<span class="hljs-addition">+    queue: null,</span>
<span class="hljs-addition">+    next: null,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  if (workInProgressHook === null) {</span>
<span class="hljs-addition">+    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    workInProgressHook = workInProgressHook.next = hook;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return workInProgressHook;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function dispatchReducerAction(fiber, queue, action) {</span>
<span class="hljs-addition">+  console.log("dispatchReducerAction", action);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+const HooksDispatcherOnMountInDEV = {</span>
<span class="hljs-addition">+  useReducer:mountReducer</span>
<span class="hljs-addition">+};</span>
<span class="hljs-addition">+function useReducer(reducer, initialArg){</span>
<span class="hljs-addition">+    const hook = mountWorkInProgressHook();</span>
<span class="hljs-addition">+    hook.memoizedState = initialArg;</span>
<span class="hljs-addition">+    const queue = {</span>
<span class="hljs-addition">+      pending: null,</span>
<span class="hljs-addition">+      dispatch: null,</span>
<span class="hljs-addition">+    };</span>
<span class="hljs-addition">+    hook.queue = queue;</span>
<span class="hljs-addition">+    const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));</span>
<span class="hljs-addition">+    return [hook.memoizedState, dispatch];</span>
}
export function renderWithHooks(current, workInProgress, Component, props) {
<span class="hljs-addition">+ currentlyRenderingFiber = workInProgress;</span>
<span class="hljs-addition">+ if (current !== null &amp;&amp; current.memoizedState !== null) {</span>
<span class="hljs-addition">+ } else {</span>
<span class="hljs-addition">+   ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;</span>
<span class="hljs-addition">+ }</span>
  const children = Component(props);
<span class="hljs-addition">+ currentlyRenderingFiber = null;</span>
  return children;
}
</code></pre>
<h3 id="t17320.3 react\index.js">20.3 react\index.js <a href="#t17320.3 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">"./src/React"</span>;
</code></pre>
<h3 id="t17420.4 React.js">20.4 React.js <a href="#t17420.4 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactHooks"</span>;
<span class="hljs-keyword">import</span> ReactSharedInternals <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactSharedInternals"</span>;

<span class="hljs-keyword">export</span> { useReducer, ReactSharedInternals <span class="hljs-keyword">as</span> __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED };
</code></pre>
<h3 id="t17520.5 ReactHooks.js">20.5 ReactHooks.js <a href="#t17520.5 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> ReactCurrentDispatcher <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactCurrentDispatcher"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveDispatcher</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> dispatcher = ReactCurrentDispatcher.current;
  <span class="hljs-keyword">return</span> dispatcher;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useReducer</span>(<span class="hljs-params">reducer, initialArg, init</span>) </span>{
  <span class="hljs-keyword">const</span> dispatcher = resolveDispatcher();
  <span class="hljs-keyword">return</span> dispatcher.useReducer(reducer, initialArg, init);
}
</code></pre>
<h3 id="t17620.6 ReactCurrentDispatcher.js">20.6 ReactCurrentDispatcher.js <a href="#t17620.6 ReactCurrentDispatcher.js"> # </a></h3>
<p>src\react\src\ReactCurrentDispatcher.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> ReactCurrentDispatcher = {
  <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>,
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReactCurrentDispatcher;
</code></pre>
<h3 id="t17720.7 ReactSharedInternals.js">20.7 ReactSharedInternals.js <a href="#t17720.7 ReactSharedInternals.js"> # </a></h3>
<p>src\react\src\ReactSharedInternals.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> ReactCurrentDispatcher <span class="hljs-keyword">from</span> <span class="hljs-string">"./ReactCurrentDispatcher"</span>;

<span class="hljs-keyword">const</span> ReactSharedInternals = {
  ReactCurrentDispatcher,
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReactSharedInternals;
</code></pre>
<h3 id="t17820.8 ReactSharedInternals.js">20.8 ReactSharedInternals.js <a href="#t17820.8 ReactSharedInternals.js"> # </a></h3>
<p>src\shared\ReactSharedInternals.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">const</span> ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReactSharedInternals;
</code></pre>
<h2 id="t17921.updateReducer">21.updateReducer <a href="#t17921.updateReducer"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/reacthook_dian_ji_geng_xin_liu_cheng_1678676952144.png" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/useReducers_1678680544728.png" alt=""></p>
<h3 id="t18021.1 ReactFiberHooks.js">21.1 ReactFiberHooks.js <a href="#t18021.1 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from "shared/ReactSharedInternals";
<span class="hljs-addition">+import { enqueueConcurrentHookUpdate } from "./ReactFiberConcurrentUpdates";</span>
<span class="hljs-addition">+import { scheduleUpdateOnFiber } from "./ReactFiberWorkLoop";</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
<span class="hljs-addition">+let currentHook = null;</span>

function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
<span class="hljs-addition">+ const update = {</span>
<span class="hljs-addition">+   action,</span>
<span class="hljs-addition">+   next: null,</span>
<span class="hljs-addition">+ };</span>
<span class="hljs-addition">+ const root = enqueueConcurrentHookUpdate(fiber, queue, update);</span>
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, fiber);</span>
}
const HooksDispatcherOnMountInDEV = {
  useReducer:mountReducer
};
function mountReducer(reducer, initialArg) {
    const hook = mountWorkInProgressHook();
    hook.memoizedState = initialArg;
    const queue = {
      pending: null,
      dispatch: null,
    };
    hook.queue = queue;
    const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
    return [hook.memoizedState, dispatch];
}
<span class="hljs-addition">+function updateWorkInProgressHook() {</span>
<span class="hljs-addition">+  if (currentHook === null) {</span>
<span class="hljs-addition">+    const current = currentlyRenderingFiber.alternate</span>
<span class="hljs-addition">+    currentHook = current.memoizedState</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    currentHook = currentHook.next</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const newHook = {</span>
<span class="hljs-addition">+    memoizedState: currentHook.memoizedState,</span>
<span class="hljs-addition">+    queue: currentHook.queue,</span>
<span class="hljs-addition">+    next: null</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (workInProgressHook === null) {</span>
<span class="hljs-addition">+    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    workInProgressHook = workInProgressHook.next = newHook</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return workInProgressHook</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+const HooksDispatcherOnUpdateInDEV = {</span>
<span class="hljs-addition">+  useReducer：updateReducer</span>
<span class="hljs-addition">+};</span>
<span class="hljs-addition">+function updateReducer(reducer) {</span>
<span class="hljs-addition">+  const hook = updateWorkInProgressHook()</span>
<span class="hljs-addition">+  const queue = hook.queue</span>
<span class="hljs-addition">+  queue.lastRenderedReducer = reducer</span>
<span class="hljs-addition">+  const current = currentHook</span>
<span class="hljs-addition">+  const pendingQueue = queue.pending</span>
<span class="hljs-addition">+  let newState = current.memoizedState</span>
<span class="hljs-addition">+  if (pendingQueue !== null) {</span>
<span class="hljs-addition">+    queue.pending = null</span>
<span class="hljs-addition">+    const first = pendingQueue.next</span>
<span class="hljs-addition">+    let update = first</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      if (update.hasEagerState) {</span>
<span class="hljs-addition">+        newState = update.eagerState</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        const action = update.action</span>
<span class="hljs-addition">+        newState = reducer(newState, action)</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      update = update.next</span>
<span class="hljs-addition">+    } while (update !== null &amp;&amp; update !== first)</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  hook.memoizedState = queue.lastRenderedState = newState</span>
<span class="hljs-addition">+  return [hook.memoizedState, queue.dispatch]</span>
<span class="hljs-addition">+},</span>
export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
<span class="hljs-addition">+   ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;</span>
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
<span class="hljs-addition">+ workInProgressHook = null;</span>
<span class="hljs-addition">+ currentHook = null;</span>
  return children;
}
</code></pre>
<h3 id="t18121.2 ReactFiberConcurrentUpdates.js">21.2 ReactFiberConcurrentUpdates.js <a href="#t18121.2 ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-diff">import { HostRoot } from "./ReactWorkTags";

<span class="hljs-addition">+const concurrentQueues = [];</span>
<span class="hljs-addition">+let concurrentQueuesIndex = 0;</span>

export function markUpdateLaneFromFiberToRoot(sourceFiber) {
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {
    node = parent;
    parent = parent.return;
  }
  if (node.tag <span class="hljs-comment">=== HostRoot) {</span>
    const root = node.stateNode;
    return root;
  }
  return null;
}
<span class="hljs-addition">+export function enqueueConcurrentHookUpdate(fiber, queue, update) {</span>
<span class="hljs-addition">+  enqueueUpdate(fiber, queue, update);</span>
<span class="hljs-addition">+  return getRootForUpdatedFiber(fiber);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function enqueueUpdate(fiber, queue, update) {</span>
<span class="hljs-addition">+  concurrentQueues[concurrentQueuesIndex++] = fiber;</span>
<span class="hljs-addition">+  concurrentQueues[concurrentQueuesIndex++] = queue;</span>
<span class="hljs-addition">+  concurrentQueues[concurrentQueuesIndex++] = update;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getRootForUpdatedFiber(sourceFiber) {</span>
<span class="hljs-addition">+  let node = sourceFiber;</span>
<span class="hljs-addition">+  let parent = node.return;</span>
<span class="hljs-addition">+  while (parent !== null) {</span>
<span class="hljs-addition">+    node = parent;</span>
<span class="hljs-addition">+    parent = node.return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return node.tag === HostRoot ? node.stateNode : null;</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function finishQueueingConcurrentUpdates() {</span>
<span class="hljs-addition">+  const endIndex = concurrentQueuesIndex;</span>
<span class="hljs-addition">+  concurrentQueuesIndex = 0;</span>
<span class="hljs-addition">+  let i = 0;</span>
<span class="hljs-addition">+  while (i &lt; endIndex) {</span>
<span class="hljs-addition">+    const fiber = concurrentQueues[i++];</span>
<span class="hljs-addition">+    const queue = concurrentQueues[i++];</span>
<span class="hljs-addition">+    const update = concurrentQueues[i++];</span>
<span class="hljs-addition">+    if (queue !== null &amp;&amp; update !== null) {</span>
<span class="hljs-addition">+      const pending = queue.pending;</span>
<span class="hljs-addition">+      if (pending === null) {</span>
<span class="hljs-addition">+        update.next = update;</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        update.next = pending.next;</span>
<span class="hljs-addition">+        pending.next = update;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      queue.pending = update;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h3 id="t18221.3 ReactFiberWorkLoop.js">21.3 ReactFiberWorkLoop.js <a href="#t18221.3 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from "scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags } from "./ReactFiberFlags";
import { commitMutationEffectsOnFiber } from "./ReactFiberCommitWork";
<span class="hljs-addition">+import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";</span>

let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function commitRoot(root) {
  const { finishedWork } = root;
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffectsOnFiber(finishedWork, root);
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
<span class="hljs-addition">+ finishQueueingConcurrentUpdates();</span>
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}
</code></pre>
<h3 id="t18321.4 ReactFiberBeginWork.js">21.4 ReactFiberBeginWork.js <a href="#t18321.4 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, IndeterminateComponent, FunctionComponent } from "./ReactWorkTags";
import { processUpdateQueue } from "./ReactFiberClassUpdateQueue";
import { mountChildFibers, reconcileChildFibers } from "./ReactChildFiber";
import { shouldSetTextContent } from "react-dom-bindings/src/client/ReactDOMHostConfig";
import logger, { indent } from "shared/logger";
import { renderWithHooks } from "react-reconciler/src/ReactFiberHooks";
function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
function updateHostRoot(current, workInProgress) {
  processUpdateQueue(workInProgress);
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function mountIndeterminateComponent(_current, workInProgress, Component) {
  const props = workInProgress.pendingProps;
  const value = renderWithHooks(null, workInProgress, Component, props);
  workInProgress.tag = FunctionComponent;
  reconcileChildren(null, workInProgress, value);
  return workInProgress.child;
}
<span class="hljs-addition">+function updateFunctionComponent(current, workInProgress, Component, nextProps) {</span>
<span class="hljs-addition">+  const nextChildren = renderWithHooks(current, workInProgress, Component, nextProps);</span>
<span class="hljs-addition">+  reconcileChildren(current, workInProgress, nextChildren);</span>
<span class="hljs-addition">+  return workInProgress.child;</span>
<span class="hljs-addition">+}</span>
export function beginWork(current, workInProgress) {
  //logger(" ".repeat(indent.number) + "beginWork", workInProgress);
  indent.number += 2;
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      return mountIndeterminateComponent(current, workInProgress, workInProgress.type);
    }
<span class="hljs-addition">+   case FunctionComponent: {</span>
<span class="hljs-addition">+     const Component = workInProgress.type;</span>
<span class="hljs-addition">+     const resolvedProps = workInProgress.pendingProps;</span>
<span class="hljs-addition">+     return updateFunctionComponent(current, workInProgress, Component, resolvedProps);</span>
<span class="hljs-addition">+   }</span>
    case HostRoot:
      return updateHostRoot(current, workInProgress);
    case HostComponent:
      return updateHostComponent(current, workInProgress);
    case HostText:
    default:
      return null;
  }
}
</code></pre>
<h3 id="t18421.5 ReactChildFiber.js">21.5 ReactChildFiber.js <a href="#t18421.5 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from "shared/ReactSymbols";
import isArray from "shared/isArray";
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from "./ReactFiber";
import { Placement } from "./ReactFiberFlags";
import { HostText } from "./ReactWorkTags";
function createChildReconciler(shouldTrackSideEffects) {
<span class="hljs-addition">+ function useFiber(fiber, pendingProps) {</span>
<span class="hljs-addition">+   const clone = createWorkInProgress(fiber, pendingProps);</span>
<span class="hljs-addition">+   clone.index = 0;</span>
<span class="hljs-addition">+   clone.sibling = null;</span>
<span class="hljs-addition">+   return clone;</span>
<span class="hljs-addition">+ }</span>
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
<span class="hljs-addition">+   const key = element.key;</span>
<span class="hljs-addition">+   let child = currentFirstChild;</span>
<span class="hljs-addition">+   while (child !== null) {</span>
<span class="hljs-addition">+     if (child.key === key) {</span>
<span class="hljs-addition">+       const elementType = element.type;</span>
<span class="hljs-addition">+       if (child.type === elementType) {</span>
<span class="hljs-addition">+         const existing = useFiber(child, element.props);</span>
<span class="hljs-addition">+         existing.return = returnFiber;</span>
<span class="hljs-addition">+         return existing;</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     child = child.sibling;</span>
<span class="hljs-addition">+   }</span>
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
<span class="hljs-addition">+   if (shouldTrackSideEffects &amp;&amp; newFiber.alternate === null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== "string" &amp;&amp; newChild !== "") || typeof newChild === "number") {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, newIndex) {
    newFiber.index = newIndex;
    if (shouldTrackSideEffects) newFiber.flags |= Placement;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    for (; newIdx &lt; newChildren.length; newIdx++) {
      const newFiber = createChild(returnFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        continue;
      }
      placeChild(newFiber, newIdx);
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== "string") {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);

</code></pre>
<h3 id="t18521.6 ReactFiberCompleteWork.js">21.6 ReactFiberCompleteWork.js <a href="#t18521.6 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
<span class="hljs-addition">+ prepareUpdate,</span>
} from "react-dom-bindings/src/client/ReactDOMHostConfig";
import { HostComponent, HostRoot, HostText } from "./ReactWorkTags";
<span class="hljs-addition">+import { NoFlags, Update } from "./ReactFiberFlags";</span>
import logger, { indent } from "shared/logger";
function bubbleProperties(completedWork) {
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // 我们只有创建的顶级fiber，但需要递归其子节点来查找所有终端节点
  let node = workInProgress.child;
  while (node !== null) {
    // 如果是原生节点，直接添加到父节点上
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // 再看看第一个节节点是不是原生节点
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // 如果没有弟弟就找父亲的弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // 如果找到了根节点或者回到了原节点结束
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // 下一个弟弟节点
    node = node.sibling;
  }
}
<span class="hljs-addition">+function markUpdate(workInProgress) {</span>
<span class="hljs-addition">+  workInProgress.flags |= Update;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateHostComponent(current, workInProgress, type, newProps) {</span>
<span class="hljs-addition">+  const oldProps = current.memoizedProps;</span>
<span class="hljs-addition">+  const instance = workInProgress.stateNode;</span>
<span class="hljs-addition">+  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);</span>
<span class="hljs-addition">+  workInProgress.updateQueue = updatePayload;</span>
<span class="hljs-addition">+  if (updatePayload) {</span>
<span class="hljs-addition">+    markUpdate(workInProgress);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
export function completeWork(current, workInProgress) {
  indent.number -= 2;
  //logger(" ".repeat(indent.number) + "completeWork", workInProgress);
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
<span class="hljs-addition">+     if (current !== null &amp;&amp; workInProgress.stateNode != null) {</span>
<span class="hljs-addition">+       updateHostComponent(current, workInProgress, type, newProps);</span>
<span class="hljs-addition">+       console.log("updatePayload", workInProgress.updateQueue);</span>
<span class="hljs-addition">+     } else {</span>
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     bubbleProperties(workInProgress);</span>
      break;
    }
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
    default:
      break;
  }
}

</code></pre>
<h3 id="t18621.7 ReactFiberFlags.js">21.7 ReactFiberFlags.js <a href="#t18621.7 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
<span class="hljs-addition">+export const Update = 0b00000000000000000000000100;</span>
<span class="hljs-addition">+export const MutationMask = Placement | Update;</span>
</code></pre>
<h3 id="t18721.8 ReactDOMHostConfig.js">21.8 ReactDOMHostConfig.js <a href="#t18721.8 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { setInitialProperties, diffProperties } from "./ReactDOMComponent";</span>
import { precacheFiberNode, updateFiberProps } from "./ReactDOMComponentTree";

export function shouldSetTextContent(type, props) {
  return typeof props.children <span class="hljs-comment">=== "string" || typeof props.children === "number";</span>
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
export function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
export function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}

<span class="hljs-addition">+export function prepareUpdate(domElement, type, oldProps, newProps) {</span>
<span class="hljs-addition">+  return diffProperties(domElement, type, oldProps, newProps);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t18821.9 ReactDOMComponent.js">21.9 ReactDOMComponent.js <a href="#t18821.9 ReactDOMComponent.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMComponent.js</p>
<pre><code class="lang-diff">import { setValueForStyles } from "./CSSPropertyOperations";
import setTextContent from "./setTextContent";
import { setValueForProperty } from "./DOMPropertyOperations";
const CHILDREN = "children";
const STYLE = "style";
function setInitialDOMProperties(tag, domElement, nextProps) {
  for (const propKey in nextProps) {
    if (nextProps.hasOwnProperty(propKey)) {
      const nextProp = nextProps[propKey];
      if (propKey <span class="hljs-comment">=== STYLE) {</span>
        setValueForStyles(domElement, nextProp);
      } else if (propKey <span class="hljs-comment">=== CHILDREN) {</span>
        if (typeof nextProp <span class="hljs-comment">=== "string") {</span>
          setTextContent(domElement, nextProp);
        } else if (typeof nextProp <span class="hljs-comment">=== "number") {</span>
          setTextContent(domElement, `${nextProp}`);
        }
      } else if (nextProp != null) {
        setValueForProperty(domElement, propKey, nextProp);
      }
    }
  }
}
export function setInitialProperties(domElement, tag, props) {
  setInitialDOMProperties(tag, domElement, props);
}

<span class="hljs-addition">+export function diffProperties(domElement, tag, lastProps, nextProps) {</span>
<span class="hljs-addition">+  let updatePayload = null;</span>
<span class="hljs-addition">+  let propKey;</span>
<span class="hljs-addition">+  let styleName;</span>
<span class="hljs-addition">+  let styleUpdates = null;</span>
<span class="hljs-addition">+  for (propKey in lastProps) {</span>
<span class="hljs-addition">+    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {</span>
<span class="hljs-addition">+      continue;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    if (propKey === STYLE) {</span>
<span class="hljs-addition">+      const lastStyle = lastProps[propKey];</span>
<span class="hljs-addition">+      for (styleName in lastStyle) {</span>
<span class="hljs-addition">+        if (lastStyle.hasOwnProperty(styleName)) {</span>
<span class="hljs-addition">+          if (!styleUpdates) {</span>
<span class="hljs-addition">+            styleUpdates = {};</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+          styleUpdates[styleName] = "";</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      (updatePayload = updatePayload || []).push(propKey, null);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  for (propKey in nextProps) {</span>
<span class="hljs-addition">+    const nextProp = nextProps[propKey];</span>
<span class="hljs-addition">+    const lastProp = lastProps != null ? lastProps[propKey] : undefined;</span>
<span class="hljs-addition">+    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || (nextProp == null &amp;&amp; lastProp == null)) {</span>
<span class="hljs-addition">+      continue;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    if (propKey === STYLE) {</span>
<span class="hljs-addition">+      if (lastProp) {</span>
<span class="hljs-addition">+        for (styleName in lastProp) {</span>
<span class="hljs-addition">+          if (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) {</span>
<span class="hljs-addition">+            if (!styleUpdates) {</span>
<span class="hljs-addition">+              styleUpdates = {};</span>
<span class="hljs-addition">+            }</span>
<span class="hljs-addition">+            styleUpdates[styleName] = "";</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        for (styleName in nextProp) {</span>
<span class="hljs-addition">+          if (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) {</span>
<span class="hljs-addition">+            if (!styleUpdates) {</span>
<span class="hljs-addition">+              styleUpdates = {};</span>
<span class="hljs-addition">+            }</span>
<span class="hljs-addition">+            styleUpdates[styleName] = nextProp[styleName];</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        if (!styleUpdates) {</span>
<span class="hljs-addition">+          if (!updatePayload) {</span>
<span class="hljs-addition">+            updatePayload = [];</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+          updatePayload.push(propKey, styleUpdates);</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        styleUpdates = nextProp;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } else if (propKey === CHILDREN) {</span>
<span class="hljs-addition">+      if (typeof nextProp === "string" || typeof nextProp === "number") {</span>
<span class="hljs-addition">+        (updatePayload = updatePayload || []).push(propKey, "" + nextProp);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      (updatePayload = updatePayload || []).push(propKey, nextProp);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (styleUpdates) {</span>
<span class="hljs-addition">+    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return updatePayload;</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h2 id="t18922.commitUpdate">22.commitUpdate <a href="#t18922.commitUpdate"> # </a></h2>
<h3 id="t19022.1 DOMPluginEventSystem.js">22.1 DOMPluginEventSystem.js <a href="#t19022.1 DOMPluginEventSystem.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\DOMPluginEventSystem.js</p>
<pre><code class="lang-diff">import { allNativeEvents } from "./EventRegistry";
import * as SimpleEventPlugin from "./plugins/SimpleEventPlugin";
import { createEventListenerWrapperWithPriority } from "./ReactDOMEventListener";
import { IS_CAPTURE_PHASE } from "./EventSystemFlags";
import { addEventCaptureListener, addEventBubbleListener } from "./EventListener";
import getEventTarget from "./getEventTarget";
import getListener from "./getListener";
import { HostComponent } from "react-reconciler/src/ReactWorkTags";

SimpleEventPlugin.registerEvents();
<span class="hljs-addition">+const listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);</span>
export function listenToAllSupportedEvents(rootContainerElement) {
<span class="hljs-addition">+ if (!rootContainerElement[listeningMarker]) {</span>
<span class="hljs-addition">+   rootContainerElement[listeningMarker] = true;</span>
    allNativeEvents.forEach((domEventName) =&gt; {
      listenToNativeEvent(domEventName, true, rootContainerElement);
      listenToNativeEvent(domEventName, false, rootContainerElement);
    });
<span class="hljs-addition">+ }</span>
}

export function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  let eventSystemFlags = 0; // 冒泡 = 0 捕获 = 4
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }
  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
  const listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
  if (isCapturePhaseListener) {
    addEventCaptureListener(targetContainer, domEventName, listener);
  } else {
    addEventBubbleListener(targetContainer, domEventName, listener);
  }
}
export function dispatchEventForPluginEventSystem(
  domEventName,
  eventSystemFlags,
  nativeEvent,
  targetInst,
  targetContainer
) {
  dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer);
}

function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const dispatchQueue = [];
  extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}

export function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  const inCapturePhase = (eventSystemFlags &amp; IS_CAPTURE_PHASE) !== 0;
  for (let i = 0; i &lt; dispatchQueue.length; i++) {
    const { event, listeners } = dispatchQueue[i];
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.
  }
}
function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
  if (inCapturePhase) {
    for (let i = dispatchListeners.length - 1; i &gt;= 0; i--) {
      const { currentTarget, listener } = dispatchListeners[i];
      if (event.isPropagationStopped()) {
        return;
      }
      executeDispatch(event, listener, currentTarget);
    }
  } else {
    for (let i = 0; i &lt; dispatchListeners.length; i++) {
      const { currentTarget, listener } = dispatchListeners[i];
      if (event.isPropagationStopped()) {
        return;
      }
      executeDispatch(event, listener, currentTarget);
    }
  }
}
function executeDispatch(event, listener, currentTarget) {
  event.currentTarget = currentTarget;
  listener(event);
  event.currentTarget = null;
}
function extractEvents(
  dispatchQueue,
  domEventName,
  targetInst,
  nativeEvent,
  nativeEventTarget,
  eventSystemFlags,
  targetContainer
) {
  SimpleEventPlugin.extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
}

export function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase) {
  const captureName = reactName + "Capture";
  const reactEventName = inCapturePhase ? captureName : reactName;
  const listeners = [];
  let instance = targetFiber;
  while (instance !== null) {
    const { stateNode, tag } = instance;
    if (tag <span class="hljs-comment">=== HostComponent &amp;&amp; stateNode !== null) {</span>
      if (reactEventName !== null) {
        const listener = getListener(instance, reactEventName);
        if (listener !== null &amp;&amp; listener !== undefined) {
          listeners.push(createDispatchListener(instance, listener, stateNode));
        }
      }
    }
    instance = instance.return;
  }

  return listeners;
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance,
    listener,
    currentTarget,
  };
}

</code></pre>
<h3 id="t19122.2 ReactFiberCompleteWork.js">22.2 ReactFiberCompleteWork.js <a href="#t19122.2 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
  prepareUpdate,
} from "react-dom-bindings/src/client/ReactDOMHostConfig";
<span class="hljs-addition">+import { HostComponent, HostRoot, HostText, FunctionComponent } from "./ReactWorkTags";</span>
import { NoFlags, Update } from "./ReactFiberFlags";
import logger, { indent } from "shared/logger";
function bubbleProperties(completedWork) {
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // 我们只有创建的顶级fiber，但需要递归其子节点来查找所有终端节点
  let node = workInProgress.child;
  while (node !== null) {
    // 如果是原生节点，直接添加到父节点上
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // 再看看第一个节节点是不是原生节点
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // 如果没有弟弟就找父亲的弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // 如果找到了根节点或者回到了原节点结束
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // 下一个弟弟节点
    node = node.sibling;
  }
}
function markUpdate(workInProgress) {
  workInProgress.flags |= Update;
}
function updateHostComponent(current, workInProgress, type, newProps) {
  const oldProps = current.memoizedProps;
  const instance = workInProgress.stateNode;
  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);
  workInProgress.updateQueue = updatePayload;
  if (updatePayload) {
    markUpdate(workInProgress);
  }
}
export function completeWork(current, workInProgress) {
  indent.number -= 2;
  //logger(" ".repeat(indent.number) + "completeWork", workInProgress);
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
      if (current !== null &amp;&amp; workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress, type, newProps);
      } else {
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
      }
      bubbleProperties(workInProgress);
      break;
    }
<span class="hljs-addition">+   case FunctionComponent:</span>
<span class="hljs-addition">+     bubbleProperties(workInProgress);</span>
<span class="hljs-addition">+     break;</span>
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
    default:
      break;
  }
}
</code></pre>
<h3 id="t19222.3 ReactFiberCommitWork.js">22.3 ReactFiberCommitWork.js <a href="#t19222.3 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { HostRoot, HostComponent, HostText, FunctionComponent } from "./ReactWorkTags";</span>
<span class="hljs-addition">+import { MutationMask, Placement, Update } from "./ReactFiberFlags";</span>
<span class="hljs-addition">+import { insertBefore, appendChild, commitUpdate } from "react-dom-bindings/src/client/ReactDOMHostConfig";</span>
function recursivelyTraverseMutationEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // 如果我们没有找到任何东西，让我们试试下一个弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // 如果我们是根Fiber或者父亲是原生节点，我们就是最后的弟弟
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // 如果它不是原生节点，并且，我们可能在其中有一个原生节点
      // 试着向下搜索，直到找到为止
      if (node.flags &amp; Placement) {
        // 如果我们没有孩子，可以试试弟弟
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // 检查此原生节点是否稳定可以放置
    if (!(node.flags &amp; Placement)) {
      // 找到它了!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
<span class="hljs-addition">+ const current = finishedWork.alternate;</span>
<span class="hljs-addition">+ const flags = finishedWork.flags;</span>
  switch (finishedWork.tag) {
<span class="hljs-addition">+    case HostRoot: {</span>
<span class="hljs-addition">+      recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+      commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case FunctionComponent: {</span>
<span class="hljs-addition">+      recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+      commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostComponent: {</span>
<span class="hljs-addition">+      recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+      commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+      if (flags &amp; Update) {</span>
<span class="hljs-addition">+        const instance = finishedWork.stateNode;</span>
<span class="hljs-addition">+        if (instance != null) {</span>
<span class="hljs-addition">+          const newProps = finishedWork.memoizedProps;</span>
<span class="hljs-addition">+          const oldProps = current !== null ? current.memoizedProps : newProps;</span>
<span class="hljs-addition">+          const type = finishedWork.type;</span>
<span class="hljs-addition">+          const updatePayload = finishedWork.updateQueue;</span>
<span class="hljs-addition">+          finishedWork.updateQueue = null;</span>
<span class="hljs-addition">+          if (updatePayload !== null) {</span>
<span class="hljs-addition">+            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);</span>
<span class="hljs-addition">+          }</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostText: {</span>
<span class="hljs-addition">+      recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+      commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
    default: {
      break;
    }
  }
}

</code></pre>
<h3 id="t19322.4 ReactDOMHostConfig.js">22.4 ReactDOMHostConfig.js <a href="#t19322.4 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { setInitialProperties, diffProperties, updateProperties } from "./ReactDOMComponent";</span>
import { precacheFiberNode, updateFiberProps } from "./ReactDOMComponentTree";

export function shouldSetTextContent(type, props) {
  return typeof props.children <span class="hljs-comment">=== "string" || typeof props.children === "number";</span>
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
export function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
export function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}

export function prepareUpdate(domElement, type, oldProps, newProps) {
  return diffProperties(domElement, type, oldProps, newProps);
}

<span class="hljs-addition">+export function commitUpdate(domElement, updatePayload, type, oldProps, newProps) {</span>
<span class="hljs-addition">+  updateProperties(domElement, updatePayload, type, oldProps, newProps);</span>
<span class="hljs-addition">+  updateFiberProps(domElement, newProps);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t19422.5 ReactDOMComponent.js">22.5 ReactDOMComponent.js <a href="#t19422.5 ReactDOMComponent.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMComponent.js</p>
<pre><code class="lang-diff">import { setValueForStyles } from "./CSSPropertyOperations";
import setTextContent from "./setTextContent";
import { setValueForProperty } from "./DOMPropertyOperations";
const CHILDREN = "children";
const STYLE = "style";
function setInitialDOMProperties(tag, domElement, nextProps) {
  for (const propKey in nextProps) {
    if (nextProps.hasOwnProperty(propKey)) {
      const nextProp = nextProps[propKey];
      if (propKey <span class="hljs-comment">=== STYLE) {</span>
        setValueForStyles(domElement, nextProp);
      } else if (propKey <span class="hljs-comment">=== CHILDREN) {</span>
        if (typeof nextProp <span class="hljs-comment">=== "string") {</span>
          setTextContent(domElement, nextProp);
        } else if (typeof nextProp <span class="hljs-comment">=== "number") {</span>
          setTextContent(domElement, `${nextProp}`);
        }
      } else if (nextProp != null) {
        setValueForProperty(domElement, propKey, nextProp);
      }
    }
  }
}
export function setInitialProperties(domElement, tag, props) {
  setInitialDOMProperties(tag, domElement, props);
}

export function diffProperties(domElement, tag, lastProps, nextProps) {
  let updatePayload = null;
  let propKey;
  let styleName;
  let styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey <span class="hljs-comment">=== STYLE) {</span>
      const lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = "";
        }
      }
    } else {
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    const nextProp = nextProps[propKey];
    const lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp <span class="hljs-comment">=== lastProp || (nextProp == null &amp;&amp; lastProp == null)) {</span>
      continue;
    }
    if (propKey <span class="hljs-comment">=== STYLE) {</span>
      if (lastProp) {
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = "";
          }
        }
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey <span class="hljs-comment">=== CHILDREN) {</span>
      if (typeof nextProp <span class="hljs-comment">=== "string" || typeof nextProp === "number") {</span>
        (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
      }
    } else {
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

<span class="hljs-addition">+export function updateProperties(domElement, updatePayload) {</span>
<span class="hljs-addition">+  updateDOMProperties(domElement, updatePayload);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function updateDOMProperties(domElement, updatePayload) {</span>
<span class="hljs-addition">+  for (let i = 0; i &lt; updatePayload.length; i += 2) {</span>
<span class="hljs-addition">+    const propKey = updatePayload[i];</span>
<span class="hljs-addition">+    const propValue = updatePayload[i + 1];</span>
<span class="hljs-addition">+    if (propKey === STYLE) {</span>
<span class="hljs-addition">+      setValueForStyles(domElement, propValue);</span>
<span class="hljs-addition">+    } else if (propKey === CHILDREN) {</span>
<span class="hljs-addition">+      setTextContent(domElement, propValue);</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      setValueForProperty(domElement, propKey, propValue);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h2 id="t19523.useState">23.useState <a href="#t19523.useState"> # </a></h2>
<h3 id="t19623.1 src\main.jsx">23.1 src\main.jsx <a href="#t19623.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function FunctionComponent() {
  console.log("FunctionComponent render");
<span class="hljs-addition">+ const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+ return &lt;button onClick={() =&gt; setNumber(number + 1)}&gt;{number}&lt;/button&gt;;</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);
</code></pre>
<h3 id="t19723.2 react\index.js">23.2 react\index.js <a href="#t19723.2 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+export { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, useReducer, useState } from "./src/React";</span>
</code></pre>
<h3 id="t19823.3 React.js">23.3 React.js <a href="#t19823.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { useReducer, useState } from "./ReactHooks";</span>
import ReactSharedInternals from "./ReactSharedInternals";

<span class="hljs-addition">+export { useReducer, useState, ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED };</span>

</code></pre>
<h3 id="t19923.4 ReactHooks.js">23.4 ReactHooks.js <a href="#t19923.4 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from "./ReactCurrentDispatcher";

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

<span class="hljs-addition">+export function useState(initialState) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useState(initialState);</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h3 id="t20023.5 objectIs.js">23.5 objectIs.js <a href="#t20023.5 objectIs.js"> # </a></h3>
<p>src\shared\objectIs.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> objectIs = <span class="hljs-built_in">Object</span>.is;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> objectIs;
</code></pre>
<h3 id="t20123.6 ReactFiberHooks.js">23.6 ReactFiberHooks.js <a href="#t20123.6 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from "shared/ReactSharedInternals";
import { enqueueConcurrentHookUpdate } from "./ReactFiberConcurrentUpdates";
import { scheduleUpdateOnFiber } from "./ReactFiberWorkLoop";
<span class="hljs-addition">+import is from "shared/objectIs";</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
<span class="hljs-addition">+ useState: mountState,</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
<span class="hljs-addition">+ useState: updateState,</span>
};
<span class="hljs-addition">+function basicStateReducer(state, action) {</span>
<span class="hljs-addition">+  return typeof action === "function" ? action(state) : action;</span>
<span class="hljs-addition">+}</span>
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook()
  const queue = hook.queue
  queue.lastRenderedReducer = reducer
  const current = currentHook
  const pendingQueue = queue.pending
  let newState = current.memoizedState
  if (pendingQueue !== null) {
    queue.pending = null
    const first = pendingQueue.next
    let update = first
    do {
      if (update.hasEagerState) {
        newState = update.eagerState
      } else {
        const action = update.action
        newState = reducer(newState, action)
      }
      update = update.next
    } while (update !== null &amp;&amp; update !== first)
  }
  hook.memoizedState = queue.lastRenderedState = newState
  return [hook.memoizedState, queue.dispatch]
}
<span class="hljs-addition">+function mountState(initialState) {</span>
<span class="hljs-addition">+  const hook = mountWorkInProgressHook();</span>
<span class="hljs-addition">+  hook.memoizedState =  hook.baseState = initialState;</span>
<span class="hljs-addition">+  const queue = {</span>
<span class="hljs-addition">+    pending: null,</span>
<span class="hljs-addition">+    dispatch: null,</span>
<span class="hljs-addition">+    lastRenderedReducer: basicStateReducer,</span>
<span class="hljs-addition">+    lastRenderedState: initialState,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  hook.queue = queue;</span>
<span class="hljs-addition">+  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));</span>
<span class="hljs-addition">+  return [hook.memoizedState, dispatch];</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function dispatchSetState(fiber, queue, action) {</span>
<span class="hljs-addition">+  const update = {</span>
<span class="hljs-addition">+    action,</span>
<span class="hljs-addition">+    hasEagerState: false,</span>
<span class="hljs-addition">+    eagerState: null,</span>
<span class="hljs-addition">+    next: null,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  const lastRenderedReducer = queue.lastRenderedReducer;</span>
<span class="hljs-addition">+  const currentState = queue.lastRenderedState;</span>
<span class="hljs-addition">+  const eagerState = lastRenderedReducer(currentState, action);</span>
<span class="hljs-addition">+  update.hasEagerState = true;</span>
<span class="hljs-addition">+  update.eagerState = eagerState;</span>
<span class="hljs-addition">+  if (is(eagerState, currentState)) {</span>
<span class="hljs-addition">+    return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const root = enqueueConcurrentHookUpdate(fiber, queue, update);</span>
<span class="hljs-addition">+  scheduleUpdateOnFiber(root, fiber);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateState(initialState) {</span>
<span class="hljs-addition">+  return updateReducer(basicStateReducer, initialState);</span>
<span class="hljs-addition">+}</span>
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate
    currentHook = current.memoizedState
  } else {
    currentHook = currentHook.next
  }
  const newHook = {
    memoizedState: currentHook.memoizedState,
    queue: currentHook.queue,
    next: null
  }
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook
  } else {
    workInProgressHook = workInProgressHook.next = newHook
  }
  return workInProgressHook
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}
</code></pre>
<h2 id="t20224.单节点(key 相同,类型相同)">24.单节点(key 相同,类型相同) <a href="#t20224.单节点(key 相同,类型相同)"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/cong_render_dao_zhi_xing_gong_zuo_xun_huan_de_fiber_jia_gou_6_1678677480431.png" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/dan_jie_dian_diff_1678677255463.png" alt=""></p>
<h3 id="t20324.1 src\main.jsx">24.1 src\main.jsx <a href="#t20324.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+  return number === 0 ? (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key="title" id="title"&gt;</span>
<span class="hljs-addition">+      title</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  ) : (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key="title" id="title2"&gt;</span>
<span class="hljs-addition">+      title2</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  );</span>
<span class="hljs-addition">+}</span>
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);
</code></pre>
<h2 id="t20425.单节点 key 不同,类型相同">25.单节点 key 不同,类型相同 <a href="#t20425.单节点 key 不同,类型相同"> # </a></h2>
<ul>
<li>单节点 key 不同,类型相同，删除老节点，添加新节点</li>
</ul>
<h3 id="t20525.1 main.jsx">25.1 main.jsx <a href="#t20525.1 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function FunctionComponent() {
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+  return number === 0 ? (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key="title1" id="title"&gt;</span>
<span class="hljs-addition">+      title</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  ) : (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key="title2" id="title2"&gt;</span>
<span class="hljs-addition">+      title2</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
  );
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);
</code></pre>
<h3 id="t20625.2 ReactFiberFlags.js">25.2 ReactFiberFlags.js <a href="#t20625.2 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
export const Update = 0b00000000000000000000000100;
<span class="hljs-addition">+export const ChildDeletion = 0b00000000000000000000001000;</span>
export const MutationMask = Placement | Update;
</code></pre>
<h3 id="t20725.3 ReactFiber.js">25.3 ReactFiber.js <a href="#t20725.3 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
<span class="hljs-addition">+ this.deletions = null;</span>
  this.alternate = null;
}
</code></pre>
<h3 id="t20825.4 ReactDOMHostConfig.js">25.4 ReactDOMHostConfig.js <a href="#t20825.4 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+export function removeChild(parentInstance, child) {</span>
<span class="hljs-addition">+  parentInstance.removeChild(child);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t20925.5 ReactChildFiber.js">25.5 ReactChildFiber.js <a href="#t20925.5 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from "shared/ReactSymbols";
import isArray from "shared/isArray";
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from "./ReactFiber";
<span class="hljs-addition">+import { Placement, ChildDeletion } from "./ReactFiberFlags";</span>
import { HostText } from "./ReactWorkTags";
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
<span class="hljs-addition">+ function deleteChild(returnFiber, childToDelete) {</span>
<span class="hljs-addition">+   if (!shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     return;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   const deletions = returnFiber.deletions;</span>
<span class="hljs-addition">+   if (deletions === null) {</span>
<span class="hljs-addition">+     returnFiber.deletions = [childToDelete];</span>
<span class="hljs-addition">+     returnFiber.flags |= ChildDeletion;</span>
<span class="hljs-addition">+   } else {</span>
<span class="hljs-addition">+     deletions.push(childToDelete);</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
          const existing = useFiber(child, element.props);
          existing.return = returnFiber;
          return existing;
        }
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       deleteChild(returnFiber, child);</span>
<span class="hljs-addition">+     }</span>
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== "string" &amp;&amp; newChild !== "") || typeof newChild === "number") {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, newIndex) {
    newFiber.index = newIndex;
    if (shouldTrackSideEffects) newFiber.flags |= Placement;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    for (; newIdx &lt; newChildren.length; newIdx++) {
      const newFiber = createChild(returnFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        continue;
      }
      placeChild(newFiber, newIdx);
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== "string") {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);

</code></pre>
<h3 id="t21025.6 ReactFiberCommitWork.js">25.6 ReactFiberCommitWork.js <a href="#t21025.6 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, FunctionComponent } from "./ReactWorkTags";
import { MutationMask, Placement, Update } from "./ReactFiberFlags";
import {
  insertBefore,
  appendChild,
  commitUpdate,
<span class="hljs-addition">+ removeChild,</span>
} from "react-dom-bindings/src/client/ReactDOMHostConfig";
<span class="hljs-addition">+let hostParent = null;</span>
<span class="hljs-addition">+function commitDeletionEffects(root, returnFiber, deletedFiber) {</span>
<span class="hljs-addition">+  let parent = returnFiber;</span>
<span class="hljs-addition">+  findParent: while (parent !== null) {</span>
<span class="hljs-addition">+    switch (parent.tag) {</span>
<span class="hljs-addition">+      case HostComponent: {</span>
<span class="hljs-addition">+        hostParent = parent.stateNode;</span>
<span class="hljs-addition">+        break findParent;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      case HostRoot: {</span>
<span class="hljs-addition">+        hostParent = parent.stateNode.containerInfo;</span>
<span class="hljs-addition">+        break findParent;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      default:</span>
<span class="hljs-addition">+        break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    parent = parent.return;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);</span>
<span class="hljs-addition">+  hostParent = null;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {</span>
<span class="hljs-addition">+  switch (deletedFiber.tag) {</span>
<span class="hljs-addition">+    case HostComponent:</span>
<span class="hljs-addition">+    case HostText: {</span>
<span class="hljs-addition">+      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);</span>
<span class="hljs-addition">+      if (hostParent !== null) {</span>
<span class="hljs-addition">+          removeChild(hostParent, deletedFiber.stateNode);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {</span>
<span class="hljs-addition">+  let child = parent.child;</span>
<span class="hljs-addition">+  while (child !== null) {</span>
<span class="hljs-addition">+    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);</span>
<span class="hljs-addition">+    child = child.sibling;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
function recursivelyTraverseMutationEffects(root, parentFiber) {
<span class="hljs-addition">+ const deletions = parentFiber.deletions;</span>
<span class="hljs-addition">+ if (deletions !== null) {</span>
<span class="hljs-addition">+   for (let i = 0; i &lt; deletions.length; i++) {</span>
<span class="hljs-addition">+     const childToDelete = deletions[i];</span>
<span class="hljs-addition">+     commitDeletionEffects(root, parentFiber, childToDelete);</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // 如果我们没有找到任何东西，让我们试试下一个弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // 如果我们是根Fiber或者父亲是原生节点，我们就是最后的弟弟
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // 如果它不是原生节点，并且，我们可能在其中有一个原生节点
      // 试着向下搜索，直到找到为止
      if (node.flags &amp; Placement) {
        // 如果我们没有孩子，可以试试弟弟
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // 检查此原生节点是否稳定可以放置
    if (!(node.flags &amp; Placement)) {
      // 找到它了!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }
      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}

</code></pre>
<h2 id="t21126.单节点 key 相同,类型不同">26.单节点 key 相同,类型不同 <a href="#t21126.单节点 key 相同,类型不同"> # </a></h2>
<h3 id="t21226.1 src\main.jsx">26.1 src\main.jsx <a href="#t21226.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function FunctionComponent() {
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+  return number === 0 ? (</span>
<span class="hljs-addition">+    &lt;div onClick={() =&gt; setNumber(number + 1)} key="title1" id="title1"&gt;</span>
<span class="hljs-addition">+      title1</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  ) : (</span>
<span class="hljs-addition">+    &lt;p onClick={() =&gt; setNumber(number + 1)} key="title1" id="title1"&gt;</span>
<span class="hljs-addition">+      title1</span>
<span class="hljs-addition">+    &lt;/p&gt;</span>
<span class="hljs-addition">+  );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);

</code></pre>
<h3 id="t21326.2 ReactChildFiber.js">26.2 ReactChildFiber.js <a href="#t21326.2 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from "shared/ReactSymbols";
import isArray from "shared/isArray";
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from "./ReactFiber";
import { Placement, ChildDeletion } from "./ReactFiberFlags";
import { HostText } from "./ReactWorkTags";
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      return;
    }
    const deletions = returnFiber.deletions;
    if (deletions <span class="hljs-comment">=== null) {</span>
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion;
    } else {
      deletions.push(childToDelete);
    }
  }
<span class="hljs-addition">+ function deleteRemainingChildren(returnFiber, currentFirstChild) {</span>
<span class="hljs-addition">+   if (!shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     return null;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   let childToDelete = currentFirstChild;</span>
<span class="hljs-addition">+   while (childToDelete !== null) {</span>
<span class="hljs-addition">+     deleteChild(returnFiber, childToDelete);</span>
<span class="hljs-addition">+     childToDelete = childToDelete.sibling;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   return null;</span>
<span class="hljs-addition">+ }</span>
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
<span class="hljs-addition">+         deleteRemainingChildren(returnFiber, child.sibling);</span>
          const existing = useFiber(child, element.props);
          existing.return = returnFiber;
          return existing;
        }
<span class="hljs-addition">+       deleteRemainingChildren(returnFiber, child);</span>
<span class="hljs-addition">+       break;</span>
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== "string" &amp;&amp; newChild !== "") || typeof newChild === "number") {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, newIndex) {
    newFiber.index = newIndex;
    if (shouldTrackSideEffects) newFiber.flags |= Placement;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    for (; newIdx &lt; newChildren.length; newIdx++) {
      const newFiber = createChild(returnFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        continue;
      }
      placeChild(newFiber, newIdx);
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== "string") {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);

</code></pre>
<h2 id="t21427.原来多个节点，现在只有一个节点">27.原来多个节点，现在只有一个节点 <a href="#t21427.原来多个节点，现在只有一个节点"> # </a></h2>
<ul>
<li>原来多个节点，现在只有一个节点,删除多余节点</li>
</ul>
<h3 id="t21527.1 src\main.jsx">27.1 src\main.jsx <a href="#t21527.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function FunctionComponent() {
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+ return number === 0 ? (</span>
<span class="hljs-addition">+   &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key="A"&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="B" id="B"&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="C"&gt;C&lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ ) : (</span>
<span class="hljs-addition">+   &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key="B" id="B2"&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);

</code></pre>
<h2 id="t21628.多节点 DIFF">28.多节点 DIFF <a href="#t21628.多节点 DIFF"> # </a></h2>
<ul>
<li>DOM DIFF 的三个规则<ul>
<li>只对同级元素进行比较，不同层级不对比</li>
<li>不同的类型对应不同的元素</li>
<li>可以通过 key 来标识同一个节点</li>
</ul>
</li>
<li>第 1 轮遍历<ul>
<li>如果 key 不同则直接结束本轮循环</li>
<li>newChildren 或 oldFiber 遍历完，结束本轮循环</li>
<li>key 相同而 type 不同，标记老的 oldFiber 为删除，继续循环</li>
<li>key 相同而 type 也相同，则可以复用老节 oldFiber 节点，继续循环</li>
</ul>
</li>
<li>第 2 轮遍历<ul>
<li>newChildren 遍历完而 oldFiber 还有，遍历剩下所有的 oldFiber 标记为删除，DIFF 结束</li>
<li>oldFiber 遍历完了，而 newChildren 还有，将剩下的 newChildren 标记为插入，DIFF 结束</li>
<li>newChildren 和 oldFiber 都同时遍历完成，diff 结束</li>
<li>newChildren 和 oldFiber 都没有完成，则进行<code>节点移动</code>的逻辑</li>
</ul>
</li>
<li>第 3 轮遍历<ul>
<li>处理节点移动的情况</li>
</ul>
</li>
</ul>
<h2 id="t21729.多个节点的数量和 key 相同，有的 type 不同">29.多个节点的数量和 key 相同，有的 type 不同 <a href="#t21729.多个节点的数量和 key 相同，有的 type 不同"> # </a></h2>
<ul>
<li>多个节点的数量和 <code>key</code> 相同，有的 <code>type</code> 不同，则更新属性，<code>type</code> 不同的删除老节点，删除新节点</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/duo_jie_dian_diff_1678677736789.png" alt=""></p>
<h3 id="t21829.1 src\main.jsx">29.1 src\main.jsx <a href="#t21829.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function FunctionComponent() {
  console.log("FunctionComponent");
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+ return number === 0 ? (</span>
<span class="hljs-addition">+   &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key="A"&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="B" id="B"&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="C" id="C"&gt;</span>
<span class="hljs-addition">+       C</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ ) : (</span>
<span class="hljs-addition">+   &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key="A"&gt;A2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;p key="B" id="B2"&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/p&gt;</span>
<span class="hljs-addition">+     &lt;li key="C" id="C2"&gt;</span>
<span class="hljs-addition">+       C2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);

</code></pre>
<h3 id="t21929.2 ReactChildFiber.js">29.2 ReactChildFiber.js <a href="#t21929.2 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from "shared/ReactSymbols";
import isArray from "shared/isArray";
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from "./ReactFiber";
import { Placement, ChildDeletion } from "./ReactFiberFlags";
import { HostText } from "./ReactWorkTags";
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      return;
    }
    const deletions = returnFiber.deletions;
    if (deletions <span class="hljs-comment">=== null) {</span>
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion;
    } else {
      deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      return null;
    }
    let childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
          existing.return = returnFiber;
          return existing;
        }
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== "string" &amp;&amp; newChild !== "") || typeof newChild === "number") {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, newIndex) {
<span class="hljs-addition">+   newFiber.index = newIndex;</span>
<span class="hljs-addition">+   if (!shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     return;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   const current = newFiber.alternate;</span>
<span class="hljs-addition">+   if (current !== null) {</span>
<span class="hljs-addition">+     return;</span>
<span class="hljs-addition">+   } else {</span>
<span class="hljs-addition">+     newFiber.flags |= Placement;</span>
<span class="hljs-addition">+   }</span>
  }
<span class="hljs-addition">+ function updateElement(returnFiber, current, element) {</span>
<span class="hljs-addition">+   const elementType = element.type;</span>
<span class="hljs-addition">+   if (current !== null) {</span>
<span class="hljs-addition">+     if (current.type === elementType) {</span>
<span class="hljs-addition">+       const existing = useFiber(current, element.props);</span>
<span class="hljs-addition">+       existing.return = returnFiber;</span>
<span class="hljs-addition">+       return existing;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   const created = createFiberFromElement(element);</span>
<span class="hljs-addition">+   created.return = returnFiber;</span>
<span class="hljs-addition">+   return created;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ function updateSlot(returnFiber, oldFiber, newChild) {</span>
<span class="hljs-addition">+   const key = oldFiber !== null ? oldFiber.key : null;</span>
<span class="hljs-addition">+   if (typeof newChild === "object" &amp;&amp; newChild !== null) {</span>
<span class="hljs-addition">+     switch (newChild.$$typeof) {</span>
<span class="hljs-addition">+       case REACT_ELEMENT_TYPE: {</span>
<span class="hljs-addition">+         if (newChild.key === key) {</span>
<span class="hljs-addition">+           return updateElement(returnFiber, oldFiber, newChild);</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       default:</span>
<span class="hljs-addition">+         return null;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     return null</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
<span class="hljs-addition">+   let oldFiber = currentFirstChild;</span>
<span class="hljs-addition">+   let nextOldFiber = null;</span>
<span class="hljs-addition">+   for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) {</span>
<span class="hljs-addition">+     nextOldFiber = oldFiber.sibling;</span>
<span class="hljs-addition">+     const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx]);</span>
<span class="hljs-addition">+     if (newFiber === null) {</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     if (shouldTrackSideEffects) {</span>
<span class="hljs-addition">+       if (oldFiber &amp;&amp; newFiber.alternate === null) {</span>
<span class="hljs-addition">+         deleteChild(returnFiber, oldFiber);</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     placeChild(newFiber, newIdx);</span>
<span class="hljs-addition">+     if (previousNewFiber === null) {</span>
<span class="hljs-addition">+       resultingFirstChild = newFiber;</span>
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       previousNewFiber.sibling = newFiber;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     previousNewFiber = newFiber;</span>
<span class="hljs-addition">+     oldFiber = nextOldFiber;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   if (newIdx === newChildren.length) {</span>
<span class="hljs-addition">+     deleteRemainingChildren(returnFiber, oldFiber);</span>
<span class="hljs-addition">+     return resultingFirstChild;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   if (oldFiber === null) {</span>
<span class="hljs-addition">+     for (; newIdx &lt; newChildren.length; newIdx++) {</span>
<span class="hljs-addition">+       const newFiber = createChild(returnFiber, newChildren[newIdx]);</span>
<span class="hljs-addition">+       if (newFiber === null) {</span>
<span class="hljs-addition">+         continue;</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       placeChild(newFiber, newIdx);</span>
<span class="hljs-addition">+       if (previousNewFiber === null) {</span>
<span class="hljs-addition">+         resultingFirstChild = newFiber;</span>
<span class="hljs-addition">+       } else {</span>
<span class="hljs-addition">+         previousNewFiber.sibling = newFiber;</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       previousNewFiber = newFiber;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   }</span>
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== "string") {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);

</code></pre>
<h2 id="t22030.多个节点的类型和 key 全部相同，有新增元素">30.多个节点的类型和 key 全部相同，有新增元素 <a href="#t22030.多个节点的类型和 key 全部相同，有新增元素"> # </a></h2>
<h3 id="t22130.1 src\main.jsx">30.1 src\main.jsx <a href="#t22130.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function FunctionComponent() {
  console.log("FunctionComponent");
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+ return number === 0 ? (</span>
<span class="hljs-addition">+   &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key="A"&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="B" id="B"&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="C"&gt;C&lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ ) : (</span>
<span class="hljs-addition">+   &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key="A"&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="B" id="B2"&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="C"&gt;C2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="D"&gt;D&lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);

</code></pre>
<h2 id="t22231.多个节点的类型和 key 全部相同，有删除老元素">31.多个节点的类型和 key 全部相同，有删除老元素 <a href="#t22231.多个节点的类型和 key 全部相同，有删除老元素"> # </a></h2>
<h3 id="t22331.1 src\main.jsx">31.1 src\main.jsx <a href="#t22331.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function FunctionComponent() {
  console.log("FunctionComponent");
  const [number, setNumber] = React.useState(0);
<span class="hljs-addition">+ return number === 0 ? (</span>
<span class="hljs-addition">+   &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key="A"&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="B" id="B"&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="C"&gt;C&lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ ) : (</span>
<span class="hljs-addition">+   &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;</span>
<span class="hljs-addition">+     &lt;li key="A"&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="B" id="B2"&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+   &lt;/ul&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);

</code></pre>
<h2 id="t22432.多个节点数量不同、key 不同">32.多个节点数量不同、key 不同 <a href="#t22432.多个节点数量不同、key 不同"> # </a></h2>
<ul>
<li><a href="https://www.processon.com/diagraming/6193773ef346fb6e38a56734">多个节点数量不同、key 不同</a></li>
<li>第一轮比较 A 和 A，相同可以复用，更新，然后比较 B 和 C，key 不同直接跳出第一个循环</li>
<li>把剩下 oldFiber 的放入 existingChildren 这个 map 中</li>
<li>然后声明一个<code>lastPlacedIndex</code>变量，表示不需要移动的老节点的索引</li>
<li>继续循环剩下的虚拟 DOM 节点</li>
<li>如果能在 map 中找到相同 key 相同 type 的节点则可以复用老 fiber,并把此老 fiber 从 map 中删除</li>
<li>如果能在 map 中找不到相同 key 相同 type 的节点则创建新的 fiber</li>
<li>如果是复用老的 fiber,则判断老 fiber 的索引是否小于 lastPlacedIndex，如果是要移动老 fiber，不变</li>
<li>如果是复用老的 fiber,则判断老 fiber 的索引是否小于 lastPlacedIndex，如果否则更新 lastPlacedIndex 为老 fiber 的 index</li>
<li>把所有的 map 中剩下的 fiber 全部标记为删除</li>
<li>(删除#li#F)=&gt;(添加#li#B)=&gt;(添加#li#G)=&gt;(添加#li#D)=&gt;null</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/duo_ge_jie_dian_shu_liang_bu_tong_key_bu_tong_1_1637057627706.jpg" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/domidff_1665494795901.png" alt=""></p>
<h3 id="t22532.1 src\main.jsx">32.1 src\main.jsx <a href="#t22532.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function FunctionComponent() {
  console.log("FunctionComponent");
  const [number, setNumber] = React.useState(0);
  return number <span class="hljs-comment">=== 0 ? (</span>
    &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;
<span class="hljs-addition">+     &lt;li key="A"&gt;A&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="B" id="b"&gt;</span>
<span class="hljs-addition">+       B</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="C"&gt;C&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="D"&gt;D&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="E"&gt;E&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="F"&gt;F&lt;/li&gt;</span>
    &lt;/ul&gt;
  ) : (
    &lt;ul key="container" onClick={() =&gt; setNumber(number + 1)}&gt;
<span class="hljs-addition">+     &lt;li key="A"&gt;A2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="C"&gt;C2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="E"&gt;E2&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="B" id="b2"&gt;</span>
<span class="hljs-addition">+       B2</span>
<span class="hljs-addition">+     &lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="G"&gt;G&lt;/li&gt;</span>
<span class="hljs-addition">+     &lt;li key="D"&gt;D2&lt;/li&gt;</span>
    &lt;/ul&gt;
  );
}
let element = &lt;FunctionComponent /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);

</code></pre>
<h3 id="t22632.2 ReactFiber.js">32.2 ReactFiber.js <a href="#t22632.2 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.alternate = null;

<span class="hljs-addition">+ this.index = 0;</span>
}
</code></pre>
<h3 id="t22732.3 ReactFiberWorkLoop.js">32.3 ReactFiberWorkLoop.js <a href="#t22732.3 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from "scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags, Placement, Update,ChildDeletion } from "./ReactFiberFlags";
import { commitMutationEffectsOnFiber } from "./ReactFiberCommitWork";
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
import { FunctionComponent, IndeterminateComponent, HostRoot, HostComponent, HostText } from "./ReactWorkTags";

let workInProgress = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
<span class="hljs-addition">+ printFiber(finishedWork);</span>
<span class="hljs-addition">+ console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);</span>
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function commitRoot(root) {
  const { finishedWork } = root;
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffectsOnFiber(finishedWork, root);
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

<span class="hljs-addition">+function printFiber(fiber) {</span>
<span class="hljs-addition">+  /*</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~Forked;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~PlacementDEV;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~Snapshot;</span>
<span class="hljs-addition">+  fiber.flags &amp;= ~PerformedWork;</span>
<span class="hljs-addition">+  */</span>
<span class="hljs-addition">+  if (fiber.flags !== 0) {</span>
<span class="hljs-addition">+    console.log(</span>
<span class="hljs-addition">+      getFlags(fiber.flags),</span>
<span class="hljs-addition">+      getTag(fiber.tag),</span>
<span class="hljs-addition">+      typeof fiber.type === "function" ? fiber.type.name : fiber.type,</span>
<span class="hljs-addition">+      fiber.memoizedProps</span>
<span class="hljs-addition">+    );</span>
<span class="hljs-addition">+    if (fiber.deletions) {</span>
<span class="hljs-addition">+      for (let i = 0; i &lt; fiber.deletions.length; i++) {</span>
<span class="hljs-addition">+        const childToDelete = fiber.deletions[i];</span>
<span class="hljs-addition">+        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.+memoizedProps);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  let child = fiber.child;</span>
<span class="hljs-addition">+  while (child) {</span>
<span class="hljs-addition">+    printFiber(child);</span>
<span class="hljs-addition">+    child = child.sibling;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getTag(tag) {</span>
<span class="hljs-addition">+  switch (tag) {</span>
<span class="hljs-addition">+    case FunctionComponent:</span>
<span class="hljs-addition">+      return `FunctionComponent`;</span>
<span class="hljs-addition">+    case HostRoot:</span>
<span class="hljs-addition">+      return `HostRoot`;</span>
<span class="hljs-addition">+    case HostComponent:</span>
<span class="hljs-addition">+      return `HostComponent`;</span>
<span class="hljs-addition">+    case HostText:</span>
<span class="hljs-addition">+      return HostText;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return tag;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function getFlags(flags) {</span>
<span class="hljs-addition">+  if (flags === (Update | Placement | ChildDeletion)) {</span>
<span class="hljs-addition">+    return `自己移动和子元素有删除`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === (ChildDeletion | Update)) {</span>
<span class="hljs-addition">+    return `自己有更新和子元素有删除`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === ChildDeletion) {</span>
<span class="hljs-addition">+    return `子元素有删除`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === (Placement | Update)) {</span>
<span class="hljs-addition">+    return `移动并更新`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === Placement) {</span>
<span class="hljs-addition">+    return `插入`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (flags === Update) {</span>
<span class="hljs-addition">+    return `更新`;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return flags;</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h3 id="t22832.4 ReactChildFiber.js">32.4 ReactChildFiber.js <a href="#t22832.4 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from "shared/ReactSymbols";
import isArray from "shared/isArray";
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from "./ReactFiber";
import { Placement, ChildDeletion } from "./ReactFiberFlags";
import { HostText } from "./ReactWorkTags";
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      return;
    }
    const deletions = returnFiber.deletions;
    if (deletions <span class="hljs-comment">=== null) {</span>
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion;
    } else {
      deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      return null;
    }
    let childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
          existing.return = returnFiber;
          return existing;
        }
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== "string" &amp;&amp; newChild !== "") || typeof newChild === "number") {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
<span class="hljs-addition">+ function placeChild(newFiber, lastPlacedIndex, newIndex) {</span>
<span class="hljs-addition">+   newFiber.index = newIndex;</span>
<span class="hljs-addition">+   if (!shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     return lastPlacedIndex;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   const current = newFiber.alternate;</span>
<span class="hljs-addition">+   if (current !== null) {</span>
<span class="hljs-addition">+     const oldIndex = current.index;</span>
<span class="hljs-addition">+     if (oldIndex &lt; lastPlacedIndex) {</span>
<span class="hljs-addition">+       newFiber.flags |= Placement;</span>
<span class="hljs-addition">+       return lastPlacedIndex;</span>
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       return oldIndex;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   } else {</span>
<span class="hljs-addition">+     newFiber.flags |= Placement;</span>
<span class="hljs-addition">+     return lastPlacedIndex;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  function updateElement(returnFiber, current, element) {
    const elementType = element.type;
    if (current !== null) {
      if (current.type <span class="hljs-comment">=== elementType) {</span>
        const existing = useFiber(current, element.props);
        existing.return = returnFiber;
        return existing;
      }
    }
    const created = createFiberFromElement(element);
    created.return = returnFiber;
    return created;
  }
  function updateSlot(returnFiber, oldFiber, newChild) {
    const key = oldFiber !== null ? oldFiber.key : null;
    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          if (newChild.key <span class="hljs-comment">=== key) {</span>
            return updateElement(returnFiber, oldFiber, newChild);
          } else {
            return null;
          }
        }
        default:
          return null;
      }
    }
  }
<span class="hljs-addition">+ function mapRemainingChildren(returnFiber, currentFirstChild) {</span>
<span class="hljs-addition">+   const existingChildren = new Map();</span>
<span class="hljs-addition">+   let existingChild = currentFirstChild;</span>
<span class="hljs-addition">+   while (existingChild !== null) {</span>
<span class="hljs-addition">+     if (existingChild.key !== null) {</span>
<span class="hljs-addition">+       existingChildren.set(existingChild.key, existingChild);</span>
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       existingChildren.set(existingChild.index, existingChild);</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     existingChild = existingChild.sibling;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   return existingChildren;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ function updateTextNode(returnFiber, current, textContent) {</span>
<span class="hljs-addition">+   if (current === null || current.tag !== HostText) {</span>
<span class="hljs-addition">+     const created = createFiberFromText(textContent);</span>
<span class="hljs-addition">+     created.return = returnFiber;</span>
<span class="hljs-addition">+     return created;</span>
<span class="hljs-addition">+   } else {</span>
<span class="hljs-addition">+     const existing = useFiber(current, textContent);</span>
<span class="hljs-addition">+     existing.return = returnFiber;</span>
<span class="hljs-addition">+     return existing;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ function updateFromMap(existingChildren, returnFiber, newIdx, newChild) {</span>
<span class="hljs-addition">+   if ((typeof newChild === "string" &amp;&amp; newChild !== "") || typeof newChild === "number") {</span>
<span class="hljs-addition">+     const matchedFiber = existingChildren.get(newIdx) || null;</span>
<span class="hljs-addition">+     return updateTextNode(returnFiber, matchedFiber, "" + newChild);</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   if (typeof newChild === "object" &amp;&amp; newChild !== null) {</span>
<span class="hljs-addition">+     switch (newChild.$$typeof) {</span>
<span class="hljs-addition">+       case REACT_ELEMENT_TYPE: {</span>
<span class="hljs-addition">+         const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;</span>
<span class="hljs-addition">+         return updateElement(returnFiber, matchedFiber, newChild);</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   return null;</span>
<span class="hljs-addition">+ }</span>
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    let oldFiber = currentFirstChild;
    let nextOldFiber = null;
<span class="hljs-addition">+   let lastPlacedIndex = 0;</span>
    for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) {
      nextOldFiber = oldFiber.sibling;
      const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
          deleteChild(returnFiber, oldFiber);
        }
      }
<span class="hljs-addition">+     lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx <span class="hljs-comment">=== newChildren.length) {</span>
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }
    if (oldFiber <span class="hljs-comment">=== null) {</span>
      for (; newIdx &lt; newChildren.length; newIdx++) {
        const newFiber = createChild(returnFiber, newChildren[newIdx]);
        if (newFiber <span class="hljs-comment">=== null) {</span>
          continue;
        }
<span class="hljs-addition">+       lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>
        if (previousNewFiber <span class="hljs-comment">=== null) {</span>
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }
<span class="hljs-addition">+   const existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span>
<span class="hljs-addition">+   for (; newIdx &lt; newChildren.length; newIdx++) {</span>
<span class="hljs-addition">+     const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx]);</span>
<span class="hljs-addition">+     if (newFiber !== null) {</span>
<span class="hljs-addition">+       if (shouldTrackSideEffects) {</span>
<span class="hljs-addition">+         if (newFiber.alternate !== null) {</span>
<span class="hljs-addition">+           existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>
<span class="hljs-addition">+       if (previousNewFiber === null) {</span>
<span class="hljs-addition">+         resultingFirstChild = newFiber;</span>
<span class="hljs-addition">+       } else {</span>
<span class="hljs-addition">+         previousNewFiber.sibling = newFiber;</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+       previousNewFiber = newFiber;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   if (shouldTrackSideEffects) {</span>
<span class="hljs-addition">+     existingChildren.forEach((child) =&gt; deleteChild(returnFiber, child));</span>
<span class="hljs-addition">+   }</span>
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== "string") {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);
</code></pre>
<h2 id="t22933.useEffect">33.useEffect <a href="#t22933.useEffect"> # </a></h2>
<ul>
<li>在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性</li>
<li>使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道</li>
<li>useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API</li>
<li>该 Hook 接收一个包含命令式、且可能有副作用代码的函数</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/useLayoutEffect_1678680985828.jpg" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/updateEffectMount2_1666851226558.jpg" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/flushPassiveEffects_1666783551920.jpg" alt=""></p>
<h3 id="t23033.1 src\main.jsx">33.1 src\main.jsx <a href="#t23033.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function Counter() {
<span class="hljs-addition">+ const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+ React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+   console.log("useEffect1");</span>
<span class="hljs-addition">+   return () =&gt; {</span>
<span class="hljs-addition">+     console.log("destroy useEffect1");</span>
<span class="hljs-addition">+   };</span>
<span class="hljs-addition">+ });</span>
<span class="hljs-addition">+ React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+   console.log("useEffect2");</span>
<span class="hljs-addition">+   return () =&gt; {</span>
<span class="hljs-addition">+     console.log("destroy useEffect2");</span>
<span class="hljs-addition">+   };</span>
<span class="hljs-addition">+ });</span>
<span class="hljs-addition">+ React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+   console.log("useEffect3");</span>
<span class="hljs-addition">+   return () =&gt; {</span>
<span class="hljs-addition">+     console.log("destroy useEffect3");</span>
<span class="hljs-addition">+   };</span>
<span class="hljs-addition">+ });</span>
<span class="hljs-addition">+ return (</span>
<span class="hljs-addition">+   &lt;div</span>
<span class="hljs-addition">+     onClick={() =&gt; {</span>
<span class="hljs-addition">+       setNumber(number + 1);</span>
<span class="hljs-addition">+     }}</span>
<span class="hljs-addition">+   &gt;</span>
<span class="hljs-addition">+     {number}</span>
<span class="hljs-addition">+   &lt;/div&gt;</span>
<span class="hljs-addition">+ );</span>
}
let element = &lt;Counter /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);
</code></pre>
<h3 id="t23133.2 react\index.js">33.2 react\index.js <a href="#t23133.2 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+export { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, useReducer, useState, useEffect } from "./src/React";</span>
</code></pre>
<h3 id="t23233.3 React.js">33.3 React.js <a href="#t23233.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { useReducer, useState, useEffect } from "./ReactHooks";</span>
import ReactSharedInternals from "./ReactSharedInternals";

<span class="hljs-addition">+export { useReducer, useState, useEffect, ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED };</span>
</code></pre>
<h3 id="t23333.4 ReactHooks.js">33.4 ReactHooks.js <a href="#t23333.4 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from "./ReactCurrentDispatcher";

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

export function useState(initialState) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

<span class="hljs-addition">+export function useEffect(create,deps) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useEffect(create,deps);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t23433.5 ReactHookEffectTags.js">33.5 ReactHookEffectTags.js <a href="#t23433.5 ReactHookEffectTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactHookEffectTags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HasEffect = <span class="hljs-number">0b0001</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Passive = <span class="hljs-number">0b1000</span>;
</code></pre>
<h3 id="t23533.6 ReactFiberFlags.js">33.6 ReactFiberFlags.js <a href="#t23533.6 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
export const Update = 0b00000000000000000000000100;
export const ChildDeletion = 0b00000000000000000000001000;
export const MutationMask = Placement | Update;
<span class="hljs-addition">+export const Passive = 0b00000000000000010000000000;</span>
</code></pre>
<h3 id="t23633.7 ReactFiberHooks.js">33.7 ReactFiberHooks.js <a href="#t23633.7 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from "shared/ReactSharedInternals";
import { enqueueConcurrentHookUpdate } from "./ReactFiberConcurrentUpdates";
import { scheduleUpdateOnFiber } from "./ReactFiberWorkLoop";
import is from "shared/objectIs";
<span class="hljs-addition">+import { Passive as PassiveEffect } from "./ReactFiberFlags";</span>
<span class="hljs-addition">+import { HasEffect as HookHasEffect, Passive as HookPassive } from "./ReactHookEffectTags";</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
<span class="hljs-addition">+ useEffect: mountEffect,</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
<span class="hljs-addition">+ useEffect: updateEffect,</span>
};
<span class="hljs-addition">+function updateEffect(create, deps) {</span>
<span class="hljs-addition">+  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
<span class="hljs-addition">+  const hook = updateWorkInProgressHook();</span>
<span class="hljs-addition">+  const nextDeps = deps === undefined ? null : deps;</span>
<span class="hljs-addition">+  let destroy;</span>
<span class="hljs-addition">+  if (currentHook !== null) {</span>
<span class="hljs-addition">+    const prevEffect = currentHook.memoizedState;</span>
<span class="hljs-addition">+    destroy = prevEffect.destroy;</span>
<span class="hljs-addition">+    if (nextDeps !== null) {</span>
<span class="hljs-addition">+      const prevDeps = prevEffect.deps;</span>
<span class="hljs-addition">+      if (areHookInputsEqual(nextDeps, prevDeps)) {</span>
<span class="hljs-addition">+        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</span>
<span class="hljs-addition">+        return;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  currentlyRenderingFiber.flags |= fiberFlags;</span>
<span class="hljs-addition">+  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function areHookInputsEqual(nextDeps, prevDeps) {</span>
<span class="hljs-addition">+  if (prevDeps === null) {</span>
<span class="hljs-addition">+    return false;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {</span>
<span class="hljs-addition">+    if (is(nextDeps[i], prevDeps[i])) {</span>
<span class="hljs-addition">+      continue;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    return false;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+  return true;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function mountEffect(create, deps) {</span>
<span class="hljs-addition">+  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function mountEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
<span class="hljs-addition">+  const hook = mountWorkInProgressHook();</span>
<span class="hljs-addition">+  const nextDeps = deps === undefined ? null : deps;</span>
<span class="hljs-addition">+  currentlyRenderingFiber.flags |= fiberFlags;</span>
<span class="hljs-addition">+  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function pushEffect(tag, create, destroy, deps) {</span>
<span class="hljs-addition">+  const effect = {</span>
<span class="hljs-addition">+    tag,</span>
<span class="hljs-addition">+    create,</span>
<span class="hljs-addition">+    destroy,</span>
<span class="hljs-addition">+    deps,</span>
<span class="hljs-addition">+    next: null,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;</span>
<span class="hljs-addition">+  if (componentUpdateQueue === null) {</span>
<span class="hljs-addition">+    componentUpdateQueue = createFunctionComponentUpdateQueue();</span>
<span class="hljs-addition">+    currentlyRenderingFiber.updateQueue = componentUpdateQueue;</span>
<span class="hljs-addition">+    componentUpdateQueue.lastEffect = effect.next = effect;</span>
<span class="hljs-addition">+  } else {</span>
<span class="hljs-addition">+    const lastEffect = componentUpdateQueue.lastEffect;</span>
<span class="hljs-addition">+    if (lastEffect === null) {</span>
<span class="hljs-addition">+      componentUpdateQueue.lastEffect = effect.next = effect;</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      const firstEffect = lastEffect.next;</span>
<span class="hljs-addition">+      lastEffect.next = effect;</span>
<span class="hljs-addition">+      effect.next = firstEffect;</span>
<span class="hljs-addition">+      componentUpdateQueue.lastEffect = effect;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return effect;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function createFunctionComponentUpdateQueue() {</span>
<span class="hljs-addition">+  return {</span>
<span class="hljs-addition">+    lastEffect: null,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+}</span>
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== "function" ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const update = {
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const lastRenderedReducer = queue.lastRenderedReducer;
  const currentState = queue.lastRenderedState;
  const eagerState = lastRenderedReducer(currentState, action);
  update.hasEagerState = true;
  update.eagerState = eagerState;
  if (is(eagerState, currentState)) {
    return;
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
<span class="hljs-addition">+ workInProgress.updateQueue = null;</span>
<span class="hljs-addition">+ workInProgress.memoizedState = null;</span>
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}

</code></pre>
<h3 id="t23733.8 ReactFiberWorkLoop.js">33.8 ReactFiberWorkLoop.js <a href="#t23733.8 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from "scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
<span class="hljs-addition">+import { MutationMask, NoFlags, Placement, Update, ChildDeletion, Passive } from "./ReactFiberFlags";</span>
<span class="hljs-addition">+import { commitMutationEffects, commitPassiveUnmountEffects, commitPassiveMountEffects } from "./ReactFiberCommitWork";</span>
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
import { FunctionComponent, IndeterminateComponent, HostRoot, HostComponent, HostText } from "./ReactWorkTags";

let workInProgress = null;
<span class="hljs-addition">+let rootDoesHavePassiveEffects = false;</span>
<span class="hljs-addition">+let rootWithPendingPassiveEffects = null;</span>
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  printFiber(finishedWork);
  console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);
  root.finishedWork = finishedWork;
  commitRoot(root);
}
<span class="hljs-addition">+export function flushPassiveEffects() {</span>
<span class="hljs-addition">+  if (rootWithPendingPassiveEffects !== null) {</span>
<span class="hljs-addition">+    const root = rootWithPendingPassiveEffects;</span>
<span class="hljs-addition">+    commitPassiveUnmountEffects(root.current);</span>
<span class="hljs-addition">+    commitPassiveMountEffects(root, root.current);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
function commitRoot(root) {
  const { finishedWork } = root;
<span class="hljs-addition">+  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {</span>
<span class="hljs-addition">+   if (!rootDoesHavePassiveEffects) {</span>
<span class="hljs-addition">+     rootDoesHavePassiveEffects = true;</span>
<span class="hljs-addition">+     scheduleCallback(flushPassiveEffects);</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
<span class="hljs-addition">+   commitMutationEffects(finishedWork, root);</span>
<span class="hljs-addition">+   root.current = finishedWork;</span>
<span class="hljs-addition">+   if (rootDoesHavePassiveEffects) {</span>
<span class="hljs-addition">+     rootDoesHavePassiveEffects = false;</span>
<span class="hljs-addition">+     rootWithPendingPassiveEffects = root;</span>
<span class="hljs-addition">+   }</span>
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

function printFiber(fiber) {
  /*
  fiber.flags &amp;= ~Forked;
  fiber.flags &amp;= ~PlacementDEV;
  fiber.flags &amp;= ~Snapshot;
  fiber.flags &amp;= ~PerformedWork;
  */
  if (fiber.flags !== 0) {
    console.log(
      getFlags(fiber.flags),
      getTag(fiber.tag),
      typeof fiber.type <span class="hljs-comment">=== "function" ? fiber.type.name : fiber.type,</span>
      fiber.memoizedProps
    );
    if (fiber.deletions) {
      for (let i = 0; i &lt; fiber.deletions.length; i++) {
        const childToDelete = fiber.deletions[i];
        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.memoizedProps);
      }
    }
  }
  let child = fiber.child;
  while (child) {
    printFiber(child);
    child = child.sibling;
  }
}
function getTag(tag) {
  switch (tag) {
    case FunctionComponent:
      return `FunctionComponent`;
    case HostRoot:
      return `HostRoot`;
    case HostComponent:
      return `HostComponent`;
    case HostText:
      return HostText;
    default:
      return tag;
  }
}
function getFlags(flags) {
  if (flags <span class="hljs-comment">=== (Update | Placement | ChildDeletion)) {</span>
    return `自己移动和子元素有删除`;
  }
  if (flags <span class="hljs-comment">=== (ChildDeletion | Update)) {</span>
    return `自己有更新和子元素有删除`;
  }
  if (flags <span class="hljs-comment">=== ChildDeletion) {</span>
    return `子元素有删除`;
  }
  if (flags <span class="hljs-comment">=== (Placement | Update)) {</span>
    return `移动并更新`;
  }
  if (flags <span class="hljs-comment">=== Placement) {</span>
    return `插入`;
  }
  if (flags <span class="hljs-comment">=== Update) {</span>
    return `更新`;
  }
  return flags;
}
</code></pre>
<h3 id="t23833.9 ReactFiberCommitWork.js">33.9 ReactFiberCommitWork.js <a href="#t23833.9 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, FunctionComponent } from "./ReactWorkTags";
<span class="hljs-addition">+import { MutationMask, Placement, Update, Passive } from "./ReactFiberFlags";</span>
import { insertBefore, appendChild, commitUpdate, removeChild } from "react-dom-bindings/src/client/ReactDOMHostConfig";
<span class="hljs-addition">+import { HasEffect as HookHasEffect, Passive as HookPassive } from "./ReactHookEffectTags";</span>

<span class="hljs-addition">+export function commitMutationEffects(finishedWork, root) {</span>
<span class="hljs-addition">+  commitMutationEffectsOnFiber(finishedWork, root);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function commitPassiveUnmountEffects(finishedWork) {</span>
<span class="hljs-addition">+  commitPassiveUnmountOnFiber(finishedWork);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitPassiveUnmountOnFiber(finishedWork) {</span>
<span class="hljs-addition">+  switch (finishedWork.tag) {</span>
<span class="hljs-addition">+    case FunctionComponent: {</span>
<span class="hljs-addition">+      recursivelyTraversePassiveUnmountEffects(finishedWork);</span>
<span class="hljs-addition">+      if (finishedWork.flags &amp; Passive) {</span>
<span class="hljs-addition">+        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive | HookHasEffect);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default: {</span>
<span class="hljs-addition">+      recursivelyTraversePassiveUnmountEffects(finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function recursivelyTraversePassiveUnmountEffects(parentFiber) {</span>
<span class="hljs-addition">+  if (parentFiber.subtreeFlags &amp; Passive) {</span>
<span class="hljs-addition">+    let child = parentFiber.child;</span>
<span class="hljs-addition">+    while (child !== null) {</span>
<span class="hljs-addition">+      commitPassiveUnmountOnFiber(child);</span>
<span class="hljs-addition">+      child = child.sibling;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, +hookFlags) {</span>
<span class="hljs-addition">+  commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function commitHookEffectListUnmount(flags, finishedWork) {</span>
<span class="hljs-addition">+  const updateQueue = finishedWork.updateQueue;</span>
<span class="hljs-addition">+  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;</span>
<span class="hljs-addition">+  if (lastEffect !== null) {</span>
<span class="hljs-addition">+    const firstEffect = lastEffect.next;</span>
<span class="hljs-addition">+    let effect = firstEffect;</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      if ((effect.tag &amp; flags) === flags) {</span>
<span class="hljs-addition">+        const destroy = effect.destroy;</span>
<span class="hljs-addition">+        effect.destroy = undefined;</span>
<span class="hljs-addition">+        if (destroy !== undefined) {</span>
<span class="hljs-addition">+          destroy();</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      effect = effect.next;</span>
<span class="hljs-addition">+    } while (effect !== firstEffect);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function commitPassiveMountEffects(root, finishedWork) {</span>
<span class="hljs-addition">+  commitPassiveMountOnFiber(root, finishedWork);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitPassiveMountOnFiber(finishedRoot, finishedWork) {</span>
<span class="hljs-addition">+  const flags = finishedWork.flags;</span>
<span class="hljs-addition">+  switch (finishedWork.tag) {</span>
<span class="hljs-addition">+    case FunctionComponent: {</span>
<span class="hljs-addition">+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);</span>
<span class="hljs-addition">+      if (flags &amp; Passive) {</span>
<span class="hljs-addition">+        commitHookPassiveMountEffects(finishedWork, HookPassive | HookHasEffect);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostRoot: {</span>
<span class="hljs-addition">+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitHookPassiveMountEffects(finishedWork, hookFlags) {</span>
<span class="hljs-addition">+  commitHookEffectListMount(hookFlags, finishedWork);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitHookEffectListMount(flags, finishedWork) {</span>
<span class="hljs-addition">+  const updateQueue = finishedWork.updateQueue;</span>
<span class="hljs-addition">+  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;</span>
<span class="hljs-addition">+  if (lastEffect !== null) {</span>
<span class="hljs-addition">+    const firstEffect = lastEffect.next;</span>
<span class="hljs-addition">+    let effect = firstEffect;</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      if ((effect.tag &amp; flags) === flags) {</span>
<span class="hljs-addition">+        const create = effect.create;</span>
<span class="hljs-addition">+        effect.destroy = create();</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      effect = effect.next;</span>
<span class="hljs-addition">+    } while (effect !== firstEffect);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function recursivelyTraversePassiveMountEffects(root, parentFiber) {</span>
<span class="hljs-addition">+  if (parentFiber.subtreeFlags &amp; Passive) {</span>
<span class="hljs-addition">+    let child = parentFiber.child;</span>
<span class="hljs-addition">+    while (child !== null) {</span>
<span class="hljs-addition">+      commitPassiveMountOnFiber(root, child);</span>
<span class="hljs-addition">+      child = child.sibling;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
let hostParent = null;
function commitDeletionEffects(root, returnFiber, deletedFiber) {
  let parent = returnFiber;
  findParent: while (parent !== null) {
    switch (parent.tag) {
      case HostComponent: {
        hostParent = parent.stateNode;
        break findParent;
      }
      case HostRoot: {
        hostParent = parent.stateNode.containerInfo;
        break findParent;
      }
      default:
        break;
    }
    parent = parent.return;
  }
  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
  hostParent = null;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  switch (deletedFiber.tag) {
    case HostComponent:
    case HostText: {
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      if (hostParent !== null) {
        removeChild(hostParent, deletedFiber.stateNode);
      }
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  let child = parent.child;
  while (child !== null) {
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
    child = child.sibling;
  }
}
function recursivelyTraverseMutationEffects(root, parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i &lt; deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // 如果我们没有找到任何东西，让我们试试下一个弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // 如果我们是根Fiber或者父亲是原生节点，我们就是最后的弟弟
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // 如果它不是原生节点，并且，我们可能在其中有一个原生节点
      // 试着向下搜索，直到找到为止
      if (node.flags &amp; Placement) {
        // 如果我们没有孩子，可以试试弟弟
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // 检查此原生节点是否稳定可以放置
    if (!(node.flags &amp; Placement)) {
      // 找到它了!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }
      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}
</code></pre>
<h2 id="t23934.useLayoutEffect">34.useLayoutEffect <a href="#t23934.useLayoutEffect"> # </a></h2>
<ul>
<li>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect</li>
<li>useEffect不会阻塞浏览器渲染，而 useLayoutEffect 会浏览器渲染</li>
<li>useEffect会在浏览器渲染结束后执行,useLayoutEffect 则是在 DOM 更新完成后,浏览器绘制之前执行</li>
</ul>
<p><img src="https://static.zhufengpeixun.com/useLayoutEffect_1666851036689.jpg" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/commitLayoutEffects_1666852870852.jpg" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/useLayoutEffect_1665571672818.png" alt="useLayoutEffect"></p>
<h3 id="t24034.1 src\main.jsx">34.1 src\main.jsx <a href="#t24034.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function Counter() {
  const [number, setNumber] = React.useState(0);
  React.useEffect(() =&gt; {
    console.log("useEffect1");
    return () =&gt; {
      console.log("destroy useEffect1");
    };
  });
<span class="hljs-addition">+ React.useLayoutEffect(() =&gt; {</span>
<span class="hljs-addition">+   console.log("useLayoutEffect2");</span>
<span class="hljs-addition">+   return () =&gt; {</span>
<span class="hljs-addition">+     console.log("destroy useLayoutEffect2");</span>
<span class="hljs-addition">+   };</span>
<span class="hljs-addition">+ });</span>
  React.useEffect(() =&gt; {
    console.log("useEffect3");
    return () =&gt; {
      console.log("destroy useEffect3");
    };
  });
  return (
    &lt;div
      onClick={() =&gt; {
        setNumber(number + 1);
      }}
    &gt;
      {number}
    &lt;/div&gt;
  );
}
let element = &lt;Counter /&gt;;
const root = createRoot(document.getElementById("root"));
root.render(element);

</code></pre>
<h3 id="t24133.2 react\index.js">33.2 react\index.js <a href="#t24133.2 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff">export {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  useReducer,
  useState,
  useEffect,
<span class="hljs-addition">+ useLayoutEffect,</span>
} from "./src/React";
</code></pre>
<h3 id="t24234.3 React.js">34.3 React.js <a href="#t24234.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff">import { useReducer, useState, useEffect, useLayoutEffect } from "./ReactHooks";
import ReactSharedInternals from "./ReactSharedInternals";

export {
  useReducer,
  useState,
  useEffect,
<span class="hljs-addition">+ useLayoutEffect,</span>
  ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
};
</code></pre>
<h3 id="t24334.4 ReactHooks.js">34.4 ReactHooks.js <a href="#t24334.4 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from "./ReactCurrentDispatcher";

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

export function useState(initialState) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

export function useEffect(create,deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create,deps);
}
<span class="hljs-addition">+export function useLayoutEffect(create,deps) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useLayoutEffect(create,deps);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t24434.5 ReactHookEffectTags.js">34.5 ReactHookEffectTags.js <a href="#t24434.5 ReactHookEffectTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactHookEffectTags.js</p>
<pre><code class="lang-diff">export const HasEffect = 0b0001;
export const Passive = 0b1000;
<span class="hljs-addition">+export const Layout = 0b0100;</span>
</code></pre>
<h3 id="t24534.6 ReactFiberFlags.js">34.6 ReactFiberFlags.js <a href="#t24534.6 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
export const Update = 0b00000000000000000000000100;
export const ChildDeletion = 0b00000000000000000000001000;
export const MutationMask = Placement | Update;
export const Passive = 0b00000000000000010000000000;
<span class="hljs-addition">+export const LayoutMask = Update;</span>
</code></pre>
<h3 id="t24634.7 ReactFiberHooks.js">34.7 ReactFiberHooks.js <a href="#t24634.7 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from "shared/ReactSharedInternals";
import { enqueueConcurrentHookUpdate } from "./ReactFiberConcurrentUpdates";
import { scheduleUpdateOnFiber } from "./ReactFiberWorkLoop";
import is from "shared/objectIs";
<span class="hljs-addition">+import { Passive as PassiveEffect, Update as UpdateEffect } from "./ReactFiberFlags";</span>
<span class="hljs-addition">+import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from "./ReactHookEffectTags";</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
<span class="hljs-addition">+ useLayoutEffect: mountLayoutEffect,</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
<span class="hljs-addition">+ useLayoutEffect: updateLayoutEffect,</span>
};
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
<span class="hljs-addition">+function updateLayoutEffect(create, deps) {</span>
<span class="hljs-addition">+  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function mountLayoutEffect(create, deps) {</span>
<span class="hljs-addition">+  const fiberFlags = UpdateEffect;</span>
<span class="hljs-addition">+  return mountEffectImpl(fiberFlags, HookLayout, create, deps);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateEffect(create, deps) {</span>
<span class="hljs-addition">+  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span>
<span class="hljs-addition">+}</span>
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== "function" ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const update = {
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const lastRenderedReducer = queue.lastRenderedReducer;
  const currentState = queue.lastRenderedState;
  const eagerState = lastRenderedReducer(currentState, action);
  update.hasEagerState = true;
  update.eagerState = eagerState;
  if (is(eagerState, currentState)) {
    return;
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}

</code></pre>
<h3 id="t24734.8 ReactFiberWorkLoop.js">34.8 ReactFiberWorkLoop.js <a href="#t24734.8 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import { scheduleCallback } from "scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags, Placement, Update, ChildDeletion, Passive } from "./ReactFiberFlags";
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
<span class="hljs-addition">+  commitLayoutEffects,</span>
} from "./ReactFiberCommitWork";
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
import { FunctionComponent, IndeterminateComponent, HostRoot, HostComponent, HostText } from "./ReactWorkTags";

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  printFiber(finishedWork);
  console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);
  root.finishedWork = finishedWork;
  commitRoot(root);
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const { finishedWork } = root;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      scheduleCallback(flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
<span class="hljs-addition">+   commitLayoutEffects(finishedWork, root);</span>
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

function printFiber(fiber) {
  /*
  fiber.flags &amp;= ~Forked;
  fiber.flags &amp;= ~PlacementDEV;
  fiber.flags &amp;= ~Snapshot;
  fiber.flags &amp;= ~PerformedWork;
  */
  if (fiber.flags !== 0) {
    console.log(
      getFlags(fiber.flags),
      getTag(fiber.tag),
      typeof fiber.type <span class="hljs-comment">=== "function" ? fiber.type.name : fiber.type,</span>
      fiber.memoizedProps
    );
    if (fiber.deletions) {
      for (let i = 0; i &lt; fiber.deletions.length; i++) {
        const childToDelete = fiber.deletions[i];
        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.memoizedProps);
      }
    }
  }
  let child = fiber.child;
  while (child) {
    printFiber(child);
    child = child.sibling;
  }
}
function getTag(tag) {
  switch (tag) {
    case FunctionComponent:
      return `FunctionComponent`;
    case HostRoot:
      return `HostRoot`;
    case HostComponent:
      return `HostComponent`;
    case HostText:
      return HostText;
    default:
      return tag;
  }
}
function getFlags(flags) {
  if (flags <span class="hljs-comment">=== (Update | Placement | ChildDeletion)) {</span>
    return `自己移动和子元素有删除`;
  }
  if (flags <span class="hljs-comment">=== (ChildDeletion | Update)) {</span>
    return `自己有更新和子元素有删除`;
  }
  if (flags <span class="hljs-comment">=== ChildDeletion) {</span>
    return `子元素有删除`;
  }
  if (flags <span class="hljs-comment">=== (Placement | Update)) {</span>
    return `移动并更新`;
  }
  if (flags <span class="hljs-comment">=== Placement) {</span>
    return `插入`;
  }
  if (flags <span class="hljs-comment">=== Update) {</span>
    return `更新`;
  }
  return flags;
}

</code></pre>
<h3 id="t24834.9 ReactFiberCommitWork.js">34.9 ReactFiberCommitWork.js <a href="#t24834.9 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, FunctionComponent } from "./ReactWorkTags";
<span class="hljs-addition">+import { Passive, MutationMask, Placement, Update, LayoutMask } from "./ReactFiberFlags";</span>
import { insertBefore, appendChild, commitUpdate, removeChild } from "react-dom-bindings/src/client/ReactDOMHostConfig";
<span class="hljs-addition">+import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from "./ReactHookEffectTags";</span>

export function commitMutationEffects(finishedWork, root) {
  commitMutationEffectsOnFiber(finishedWork, root);
}
export function commitPassiveUnmountEffects(finishedWork) {
  commitPassiveUnmountOnFiber(finishedWork);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      if (finishedWork.flags &amp; Passive) {
        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive | HookHasEffect);
      }
      break;
    }
    default: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    }
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveUnmountOnFiber(child);
      child = child.sibling;
    }
  }
}
function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
  commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
}

function commitHookEffectListUnmount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const destroy = effect.destroy;
        effect.destroy = undefined;
        if (destroy !== undefined) {
          destroy();
        }
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

export function commitPassiveMountEffects(root, finishedWork) {
  commitPassiveMountOnFiber(root, finishedWork);
}
function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      if (flags &amp; Passive) {
        commitHookPassiveMountEffects(finishedWork, HookPassive | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function commitHookPassiveMountEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}
function commitHookEffectListMount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const create = effect.create;
        effect.destroy = create();
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
function recursivelyTraversePassiveMountEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveMountOnFiber(root, child);
      child = child.sibling;
    }
  }
}
let hostParent = null;
function commitDeletionEffects(root, returnFiber, deletedFiber) {
  let parent = returnFiber;
  findParent: while (parent !== null) {
    switch (parent.tag) {
      case HostComponent: {
        hostParent = parent.stateNode;
        break findParent;
      }
      case HostRoot: {
        hostParent = parent.stateNode.containerInfo;
        break findParent;
      }
      default:
        break;
    }
    parent = parent.return;
  }
  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
  hostParent = null;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  switch (deletedFiber.tag) {
    case HostComponent:
    case HostText: {
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      if (hostParent !== null) {
        removeChild(hostParent, deletedFiber.stateNode);
      }
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  let child = parent.child;
  while (child !== null) {
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
    child = child.sibling;
  }
}
function recursivelyTraverseMutationEffects(root, parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i &lt; deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // 如果我们没有找到任何东西，让我们试试下一个弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // 如果我们是根Fiber或者父亲是原生节点，我们就是最后的弟弟
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // 如果它不是原生节点，并且，我们可能在其中有一个原生节点
      // 试着向下搜索，直到找到为止
      if (node.flags &amp; Placement) {
        // 如果我们没有孩子，可以试试弟弟
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // 检查此原生节点是否稳定可以放置
    if (!(node.flags &amp; Placement)) {
      // 找到它了!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
<span class="hljs-addition">+     if (flags &amp; Update) {</span>
<span class="hljs-addition">+       commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);</span>
<span class="hljs-addition">+     }</span>
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }
      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}

<span class="hljs-addition">+export function commitLayoutEffects(finishedWork, root) {</span>
<span class="hljs-addition">+  const current = finishedWork.alternate;</span>
<span class="hljs-addition">+  commitLayoutEffectOnFiber(root, current, finishedWork);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {</span>
<span class="hljs-addition">+  const flags = finishedWork.flags;</span>
<span class="hljs-addition">+  switch (finishedWork.tag) {</span>
<span class="hljs-addition">+    case FunctionComponent: {</span>
<span class="hljs-addition">+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
<span class="hljs-addition">+      if (flags &amp; Update) {</span>
<span class="hljs-addition">+        commitHookLayoutEffects(finishedWork, HookLayout | HookHasEffect);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    case HostRoot: {</span>
<span class="hljs-addition">+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      break;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function recursivelyTraverseLayoutEffects(root, parentFiber) {</span>
<span class="hljs-addition">+  if (parentFiber.subtreeFlags &amp; LayoutMask) {</span>
<span class="hljs-addition">+    let child = parentFiber.child;</span>
<span class="hljs-addition">+    while (child !== null) {</span>
<span class="hljs-addition">+      const current = child.alternate;</span>
<span class="hljs-addition">+      commitLayoutEffectOnFiber(root, current, child);</span>
<span class="hljs-addition">+      child = child.sibling;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitHookLayoutEffects(finishedWork, hookFlags) {</span>
<span class="hljs-addition">+  commitHookEffectListMount(hookFlags, finishedWork);</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h2 id="t24935.Scheduler_scheduleCallback">35.Scheduler_scheduleCallback <a href="#t24935.Scheduler_scheduleCallback"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/shi_jian_qie_pian_diao_du_1643278352662.jpg" alt=""></p>
<p><img src="https://static.zhufengpeixun.com/duo_ge_ren_wu_1643279818108.jpg" alt=""></p>
<h3 id="t25035.1 ReactFiberWorkLoop.js">35.1 ReactFiberWorkLoop.js <a href="#t25035.1 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { NormalPriority as NormalSchedulerPriority, scheduleCallback as Scheduler_scheduleCallback } from "./Scheduler";</span>
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags, Placement, Update, ChildDeletion, Passive } from "./ReactFiberFlags";
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from "./ReactFiberCommitWork";
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
import { FunctionComponent, IndeterminateComponent, HostRoot, HostComponent, HostText } from "./ReactWorkTags";

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
export function scheduleUpdateOnFiber(root) {
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
<span class="hljs-addition">+ Scheduler_scheduleCallback(NormalSchedulerPriority, performConcurrentWorkOnRoot.bind(null, root));</span>
}
function performConcurrentWorkOnRoot(root) {
  renderRootSync(root);
  const finishedWork = root.current.alternate;
  printFiber(finishedWork);
  console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`);
  root.finishedWork = finishedWork;
  commitRoot(root);
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const { finishedWork } = root;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
<span class="hljs-addition">+     Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);</span>
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, null);
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root) {
  prepareFreshStack(root);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

function printFiber(fiber) {
  /*
  fiber.flags &amp;= ~Forked;
  fiber.flags &amp;= ~PlacementDEV;
  fiber.flags &amp;= ~Snapshot;
  fiber.flags &amp;= ~PerformedWork;
  */
  if (fiber.flags !== 0) {
    console.log(
      getFlags(fiber.flags),
      getTag(fiber.tag),
      typeof fiber.type <span class="hljs-comment">=== "function" ? fiber.type.name : fiber.type,</span>
      fiber.memoizedProps
    );
    if (fiber.deletions) {
      for (let i = 0; i &lt; fiber.deletions.length; i++) {
        const childToDelete = fiber.deletions[i];
        console.log(getTag(childToDelete.tag), childToDelete.type, childToDelete.memoizedProps);
      }
    }
  }
  let child = fiber.child;
  while (child) {
    printFiber(child);
    child = child.sibling;
  }
}
function getTag(tag) {
  switch (tag) {
    case FunctionComponent:
      return `FunctionComponent`;
    case HostRoot:
      return `HostRoot`;
    case HostComponent:
      return `HostComponent`;
    case HostText:
      return HostText;
    default:
      return tag;
  }
}
function getFlags(flags) {
  if (flags <span class="hljs-comment">=== (Update | Placement | ChildDeletion)) {</span>
    return `自己移动和子元素有删除`;
  }
  if (flags <span class="hljs-comment">=== (ChildDeletion | Update)) {</span>
    return `自己有更新和子元素有删除`;
  }
  if (flags <span class="hljs-comment">=== ChildDeletion) {</span>
    return `子元素有删除`;
  }
  if (flags <span class="hljs-comment">=== (Placement | Update)) {</span>
    return `移动并更新`;
  }
  if (flags <span class="hljs-comment">=== Placement) {</span>
    return `插入`;
  }
  if (flags <span class="hljs-comment">=== Update) {</span>
    return `更新`;
  }
  return flags;
}

</code></pre>
<h3 id="t25135.2 Scheduler.js">35.2 Scheduler.js <a href="#t25135.2 Scheduler.js"> # </a></h3>
<p>src\react-reconciler\src\Scheduler.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Scheduler <span class="hljs-keyword">from</span> <span class="hljs-string">"scheduler"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> scheduleCallback = Scheduler.unstable_scheduleCallback;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NormalPriority = Scheduler.unstable_NormalPriority;
</code></pre>
<h3 id="t25235.3 Scheduler.js">35.3 Scheduler.js <a href="#t25235.3 Scheduler.js"> # </a></h3>
<p>src\scheduler\src\forks\Scheduler.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {
  ImmediatePriority,
  UserBlockingPriority,
  NormalPriority,
  LowPriority,
  IdlePriority,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"../SchedulerPriorities"</span>;
<span class="hljs-keyword">import</span> { push, pop, peek } <span class="hljs-keyword">from</span> <span class="hljs-string">"../SchedulerMinHeap"</span>;
<span class="hljs-keyword">import</span> { frameYieldMs } <span class="hljs-keyword">from</span> <span class="hljs-string">"../SchedulerFeatureFlags"</span>;

<span class="hljs-keyword">const</span> maxSigned31BitInt = <span class="hljs-number">1073741823</span>;
<span class="hljs-keyword">const</span> IMMEDIATE_PRIORITY_TIMEOUT = <span class="hljs-number">-1</span>;
<span class="hljs-keyword">const</span> USER_BLOCKING_PRIORITY_TIMEOUT = <span class="hljs-number">250</span>;
<span class="hljs-keyword">const</span> NORMAL_PRIORITY_TIMEOUT = <span class="hljs-number">5000</span>;
<span class="hljs-keyword">const</span> LOW_PRIORITY_TIMEOUT = <span class="hljs-number">10000</span>;
<span class="hljs-keyword">const</span> IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;

<span class="hljs-keyword">const</span> taskQueue = [];
<span class="hljs-keyword">let</span> taskIdCounter = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> scheduledHostCallback = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> startTime = <span class="hljs-number">-1</span>;
<span class="hljs-keyword">let</span> currentTask = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">const</span> frameInterval = frameYieldMs;
<span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> MessageChannel();
<span class="hljs-keyword">const</span> port = channel.port2;

<span class="hljs-keyword">const</span> getCurrentTime = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> performance.now();
channel.port1.onmessage = performWorkUntilDeadline;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">schedulePerformWorkUntilDeadline</span>(<span class="hljs-params"></span>) </span>{
  port.postMessage(<span class="hljs-literal">null</span>);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performWorkUntilDeadline</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (scheduledHostCallback !== <span class="hljs-literal">null</span>) {
    startTime = getCurrentTime();
    <span class="hljs-keyword">let</span> hasMoreWork = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">try</span> {
      hasMoreWork = scheduledHostCallback(startTime);
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-keyword">if</span> (hasMoreWork) {
        schedulePerformWorkUntilDeadline();
      } <span class="hljs-keyword">else</span> {
        scheduledHostCallback = <span class="hljs-literal">null</span>;
      }
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestHostCallback</span>(<span class="hljs-params">callback</span>) </span>{
  scheduledHostCallback = callback;
  schedulePerformWorkUntilDeadline();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_scheduleCallback</span>(<span class="hljs-params">priorityLevel, callback</span>) </span>{
  <span class="hljs-keyword">const</span> currentTime = getCurrentTime();
  <span class="hljs-keyword">const</span> startTime = currentTime;
  <span class="hljs-keyword">let</span> timeout;
  <span class="hljs-keyword">switch</span> (priorityLevel) {
    <span class="hljs-keyword">case</span> ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> NormalPriority:
    <span class="hljs-keyword">default</span>:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">const</span> expirationTime = startTime + timeout;
  <span class="hljs-keyword">const</span> newTask = {
    <span class="hljs-attr">id</span>: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">-1</span>,
  };
  newTask.sortIndex = expirationTime;
  push(taskQueue, newTask);
  requestHostCallback(flushWork);
  <span class="hljs-keyword">return</span> newTask;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushWork</span>(<span class="hljs-params">initialTime</span>) </span>{
  <span class="hljs-keyword">return</span> workLoop(initialTime);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldYieldToHost</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> timeElapsed = getCurrentTime() - startTime;
  <span class="hljs-keyword">if</span> (timeElapsed &lt; frameInterval) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoop</span>(<span class="hljs-params">initialTime</span>) </span>{
  <span class="hljs-keyword">let</span> currentTime = initialTime;
  currentTask = peek(taskQueue);
  <span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) {
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">const</span> callback = currentTask.callback;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">"function"</span>) {
      currentTask.callback = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">const</span> didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
      <span class="hljs-keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> continuationCallback === <span class="hljs-string">"function"</span>) {
        currentTask.callback = continuationCallback;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span> (currentTask === peek(taskQueue)) {
        pop(taskQueue);
      }
    } <span class="hljs-keyword">else</span> {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
  }
  <span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">export</span> { NormalPriority <span class="hljs-keyword">as</span> unstable_NormalPriority, unstable_scheduleCallback };
</code></pre>
<h3 id="t25335.4 SchedulerFeatureFlags.js">35.4 SchedulerFeatureFlags.js <a href="#t25335.4 SchedulerFeatureFlags.js"> # </a></h3>
<p>src\scheduler\src\SchedulerFeatureFlags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> frameYieldMs = <span class="hljs-number">5</span>;
</code></pre>
<h3 id="t25435.5 SchedulerMinHeap.js">35.5 SchedulerMinHeap.js <a href="#t25435.5 SchedulerMinHeap.js"> # </a></h3>
<p>src\scheduler\src\SchedulerMinHeap.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">heap, node</span>) </span>{
  <span class="hljs-keyword">const</span> index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peek</span>(<span class="hljs-params">heap</span>) </span>{
  <span class="hljs-keyword">return</span> heap.length === <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : heap[<span class="hljs-number">0</span>];
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params">heap</span>) </span>{
  <span class="hljs-keyword">if</span> (heap.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">const</span> first = heap[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">const</span> last = heap.pop();
  <span class="hljs-keyword">if</span> (last !== first) {
    heap[<span class="hljs-number">0</span>] = last;
    siftDown(heap, last, <span class="hljs-number">0</span>);
  }
  <span class="hljs-keyword">return</span> first;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftUp</span>(<span class="hljs-params">heap, node, i</span>) </span>{
  <span class="hljs-keyword">let</span> index = i;
  <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> parentIndex = (index - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> parent = heap[parentIndex];
    <span class="hljs-keyword">if</span> (compare(parent, node) &gt; <span class="hljs-number">0</span>) {
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>;
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftDown</span>(<span class="hljs-params">heap, node, i</span>) </span>{
  <span class="hljs-keyword">let</span> index = i;
  <span class="hljs-keyword">const</span> length = heap.length;
  <span class="hljs-keyword">const</span> halfLength = length &gt;&gt;&gt; <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (index &lt; halfLength) {
    <span class="hljs-keyword">const</span> leftIndex = (index + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> left = heap[leftIndex];
    <span class="hljs-keyword">const</span> rightIndex = leftIndex + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> right = heap[rightIndex];
    <span class="hljs-keyword">if</span> (compare(left, node) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, left) &lt; <span class="hljs-number">0</span>) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } <span class="hljs-keyword">else</span> {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightIndex &lt; length &amp;&amp; compare(right, node) &lt; <span class="hljs-number">0</span>) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>;
    }
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">const</span> diff = a.sortIndex - b.sortIndex;
  <span class="hljs-keyword">return</span> diff !== <span class="hljs-number">0</span> ? diff : a.id - b.id;
}
</code></pre>
<h3 id="t25535.6 SchedulerPriorities.js">35.6 SchedulerPriorities.js <a href="#t25535.6 SchedulerPriorities.js"> # </a></h3>
<p>src\scheduler\src\SchedulerPriorities.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoPriority = <span class="hljs-number">0</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ImmediatePriority = <span class="hljs-number">1</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> UserBlockingPriority = <span class="hljs-number">2</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NormalPriority = <span class="hljs-number">3</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> LowPriority = <span class="hljs-number">4</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IdlePriority = <span class="hljs-number">5</span>;
</code></pre>
<h2 id="t25636.初次渲染">36.初次渲染 <a href="#t25636.初次渲染"> # </a></h2>
<p><img src="https://static.zhufengpeixun.com/scheduleUpdateOnFiber1_1667713205987.jpg" alt=""></p>
<h3 id="t25736.1 src\main.jsx">36.1 src\main.jsx <a href="#t25736.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";
<span class="hljs-addition">+let element = &lt;h1&gt;hello&lt;/h1&gt;;</span>
const root = createRoot(document.getElementById("root"));
root.render(element);
</code></pre>
<h3 id="t25836.2  ReactFiberReconciler.js">36.2  ReactFiberReconciler.js <a href="#t25836.2  ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-diff">import { createFiberRoot } from "./ReactFiberRoot";
import { createUpdate, enqueueUpdate } from "./ReactFiberClassUpdateQueue";
<span class="hljs-addition">+import { scheduleUpdateOnFiber, requestUpdateLane } from "./ReactFiberWorkLoop";</span>
export function createContainer(containerInfo) {
  return createFiberRoot(containerInfo);
}
export function updateContainer(element, container) {
  const current = container.current;
<span class="hljs-addition">+ const lane = requestUpdateLane(current);</span>
<span class="hljs-addition">+ const update = createUpdate(lane);</span>
  update.payload = { element };
<span class="hljs-addition">+ const root = enqueueUpdate(current, update, lane);</span>
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, current, lane);</span>
}
</code></pre>
<h3 id="t25936.3  ReactFiberClassUpdateQueue.js">36.3  ReactFiberClassUpdateQueue.js <a href="#t25936.3  ReactFiberClassUpdateQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberClassUpdateQueue.js</p>
<pre><code class="lang-diff">import assign from "shared/assign";
<span class="hljs-addition">+import { enqueueConcurrentClassUpdate } from './ReactFiberConcurrentUpdates'</span>
<span class="hljs-addition">+import { mergeLanes, NoLanes, NoLane, isSubsetOfLanes } from './ReactFiberLane';</span>

export const UpdateState = 0;
export function initializeUpdateQueue(fiber) {
  const queue = {
<span class="hljs-addition">+   baseState: fiber.memoizedState,</span>
<span class="hljs-addition">+   firstBaseUpdate: null,</span>
<span class="hljs-addition">+   lastBaseUpdate: null,</span>
    shared: {
      pending: null,
    },
  };
  fiber.updateQueue = queue;
}
<span class="hljs-addition">+export function createUpdate(lane) {</span>
<span class="hljs-addition">+ const update = { tag: UpdateState, lane, next: null };</span>
  return update;
}
<span class="hljs-addition">+export function enqueueUpdate(fiber, update, lane) {</span>
<span class="hljs-addition">+  const updateQueue = fiber.updateQueue</span>
<span class="hljs-addition">+  const sharedQueue = updateQueue.shared</span>
<span class="hljs-addition">+  return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);</span>
<span class="hljs-addition">+}</span>

function getStateFromUpdate(update, prevState, nextProps) {
  switch (update.tag) {
    case UpdateState: {
      const { payload } = update;
<span class="hljs-addition">+     let partialState;</span>
<span class="hljs-addition">+     if (typeof payload === 'function') {</span>
<span class="hljs-addition">+       partialState = payload.call(null, prevState, nextProps);</span>
<span class="hljs-addition">+     } else {</span>
<span class="hljs-addition">+       partialState = payload;</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+     return assign({}, prevState, partialState);</span>
    }
    default:
      return prevState;
  }
}
<span class="hljs-addition">+export const processUpdateQueue = (workInProgress, props, workInProgressRootRenderLanes) =&gt; {</span>
<span class="hljs-addition">+  // 获取新的更新队列</span>
<span class="hljs-addition">+  const queue = workInProgress.updateQueue</span>
<span class="hljs-addition">+  // 第一个跳过的更新</span>
<span class="hljs-addition">+  let firstBaseUpdate = queue.firstBaseUpdate;</span>
<span class="hljs-addition">+  // 最后一个跳过的更新</span>
<span class="hljs-addition">+  let lastBaseUpdate = queue.lastBaseUpdate;</span>
<span class="hljs-addition">+  // 获取待生效的队列</span>
<span class="hljs-addition">+  const pendingQueue = queue.shared.pending</span>
<span class="hljs-addition">+  /**   如果有新链表合并新旧链表开始  */</span>
<span class="hljs-addition">+  // 如果有新的待生效的队列</span>
<span class="hljs-addition">+  if (pendingQueue !== null) {</span>
<span class="hljs-addition">+    // 先清空待生效的队列</span>
<span class="hljs-addition">+    queue.shared.pending = null</span>
<span class="hljs-addition">+    // 最后一个待生效的更新</span>
<span class="hljs-addition">+    const lastPendingUpdate = pendingQueue</span>
<span class="hljs-addition">+    // 第一个待生效的更新</span>
<span class="hljs-addition">+    const firstPendingUpdate = lastPendingUpdate.next</span>
<span class="hljs-addition">+    // 把环状链表剪开</span>
<span class="hljs-addition">+    lastPendingUpdate.next = null</span>
<span class="hljs-addition">+    // 如果没有老的更新队列</span>
<span class="hljs-addition">+    if (lastBaseUpdate === null) {</span>
<span class="hljs-addition">+      // 第一个基本更新就是待生效队列的第一个更新</span>
<span class="hljs-addition">+      firstBaseUpdate = firstPendingUpdate;</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      // 否则把待生效更新队列添加到基本更新的尾部</span>
<span class="hljs-addition">+      lastBaseUpdate.next = firstPendingUpdate;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    // 最后一个基本更新肯定就是最后一个待生效的更新</span>
<span class="hljs-addition">+    lastBaseUpdate = lastPendingUpdate;</span>
<span class="hljs-addition">+    /**  合并新旧链表结束  */</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+  // 如果有更新</span>
<span class="hljs-addition">+  if (firstBaseUpdate !== null) {</span>
<span class="hljs-addition">+    // 基本状态</span>
<span class="hljs-addition">+    let newState = queue.baseState;</span>
<span class="hljs-addition">+    // 新的车道</span>
<span class="hljs-addition">+    let newLanes = NoLanes;</span>
<span class="hljs-addition">+    // 新的基本状态</span>
<span class="hljs-addition">+    let newBaseState = null;</span>
<span class="hljs-addition">+    // 新的第一个基本更新</span>
<span class="hljs-addition">+    let newFirstBaseUpdate = null;</span>
<span class="hljs-addition">+    // 新的最后一个基本更新 </span>
<span class="hljs-addition">+    let newLastBaseUpdate = null;</span>
<span class="hljs-addition">+    // 第一个更新</span>
<span class="hljs-addition">+    let update = firstBaseUpdate;</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      const updateLane = update.lane;</span>
<span class="hljs-addition">+      const shouldSkipUpdate = !isSubsetOfLanes(workInProgressRootRenderLanes, updateLane);</span>
<span class="hljs-addition">+      // 判断优先级是否足够,如果不够就跳过此更新 </span>
<span class="hljs-addition">+      if (shouldSkipUpdate) {</span>
<span class="hljs-addition">+        // 复制一个新的更新并添加新的基本链表中</span>
<span class="hljs-addition">+        const clone = {</span>
<span class="hljs-addition">+          lane: updateLane,</span>
<span class="hljs-addition">+          tag: update.tag,</span>
<span class="hljs-addition">+          payload: update.payload,</span>
<span class="hljs-addition">+          next: null</span>
<span class="hljs-addition">+        };</span>
<span class="hljs-addition">+        if (newLastBaseUpdate === null) {</span>
<span class="hljs-addition">+          newFirstBaseUpdate = newLastBaseUpdate = clone;</span>
<span class="hljs-addition">+          newBaseState = newState;</span>
<span class="hljs-addition">+        } else {</span>
<span class="hljs-addition">+          newLastBaseUpdate = newLastBaseUpdate.next = clone;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        // 保存此fiber上还剩下的更新车道</span>
<span class="hljs-addition">+        newLanes = mergeLanes(newLanes, updateLane);</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        // 如果已经有跳过的更新了，即使优先级足够也需要添到新的基本链表中</span>
<span class="hljs-addition">+        if (newLastBaseUpdate !== null) {</span>
<span class="hljs-addition">+          const clone = {</span>
<span class="hljs-addition">+            lane: NoLane,</span>
<span class="hljs-addition">+            tag: update.tag,</span>
<span class="hljs-addition">+            payload: update.payload,</span>
<span class="hljs-addition">+            next: null</span>
<span class="hljs-addition">+          };</span>
<span class="hljs-addition">+          newLastBaseUpdate = newLastBaseUpdate.next = clone;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        // 根据更新计算新状态</span>
<span class="hljs-addition">+        newState = getStateFromUpdate(update, newState, props);</span>
<span class="hljs-addition">+        update = update.next;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    } while (update);</span>
<span class="hljs-addition">+    // 如果没有跳过的更新</span>
<span class="hljs-addition">+    if (newLastBaseUpdate === null) {</span>
<span class="hljs-addition">+      newBaseState = newState;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    queue.baseState = newBaseState;</span>
<span class="hljs-addition">+    queue.firstBaseUpdate = newFirstBaseUpdate;</span>
<span class="hljs-addition">+    queue.lastBaseUpdate = newLastBaseUpdate;</span>
<span class="hljs-addition">+    workInProgress.lanes = newLanes;</span>
<span class="hljs-addition">+    workInProgress.memoizedState = newState;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function cloneUpdateQueue(current, workInProgress) {</span>
<span class="hljs-addition">+  const queue = workInProgress.updateQueue;</span>
<span class="hljs-addition">+  const currentQueue = current.updateQueue;</span>
<span class="hljs-addition">+  if (queue === currentQueue) {</span>
<span class="hljs-addition">+    const clone = {</span>
<span class="hljs-addition">+      baseState: currentQueue.baseState,</span>
<span class="hljs-addition">+      firstBaseUpdate: currentQueue.firstBaseUpdate,</span>
<span class="hljs-addition">+      lastBaseUpdate: currentQueue.lastBaseUpdate,</span>
<span class="hljs-addition">+      shared: currentQueue.shared,</span>
<span class="hljs-addition">+    };</span>
<span class="hljs-addition">+    workInProgress.updateQueue = clone;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t26036.4 ReactFiberConcurrentUpdates.js">36.4 ReactFiberConcurrentUpdates.js <a href="#t26036.4 ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-diff">import { HostRoot } from "./ReactWorkTags";

const concurrentQueues = [];
let concurrentQueuesIndex = 0;

export function markUpdateLaneFromFiberToRoot(sourceFiber) {
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {
    node = parent;
    parent = parent.return;
  }
  if (node.tag <span class="hljs-comment">=== HostRoot) {</span>
    const root = node.stateNode;
    return root;
  }
  return null;
}
export function enqueueConcurrentHookUpdate(fiber, queue, update) {
  enqueueUpdate(fiber, queue, update);
  return getRootForUpdatedFiber(fiber);
}
<span class="hljs-addition">+export function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {</span>
<span class="hljs-addition">+  enqueueUpdate(fiber, queue, update, lane);</span>
<span class="hljs-addition">+  return getRootForUpdatedFiber(fiber);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function enqueueUpdate(fiber, queue, update, lane) {</span>
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
<span class="hljs-addition">+ concurrentQueues[concurrentQueuesIndex++] = lane;</span>
}
function getRootForUpdatedFiber(sourceFiber) {
  let node = sourceFiber;
  let parent = node.return;
  while (parent !== null) {
    node = parent;
    parent = node.return;
  }
  return node.tag <span class="hljs-comment">=== HostRoot ? node.stateNode : null;</span>
}

export function finishQueueingConcurrentUpdates() {
  const endIndex = concurrentQueuesIndex;
  concurrentQueuesIndex = 0;
  let i = 0;
  while (i &lt; endIndex) {
    const fiber = concurrentQueues[i++];
    const queue = concurrentQueues[i++];
    const update = concurrentQueues[i++];
<span class="hljs-addition">+   const lane = concurrentQueues[i++]</span>
    if (queue !== null &amp;&amp; update !== null) {
      const pending = queue.pending;
      if (pending <span class="hljs-comment">=== null) {</span>
        update.next = update;
      } else {
        update.next = pending.next;
        pending.next = update;
      }
      queue.pending = update;
    }
  }
}
</code></pre>
<h3 id="t26136.5 ReactFiberWorkLoop.js">36.5 ReactFiberWorkLoop.js <a href="#t26136.5 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import {</span>
<span class="hljs-addition">+  scheduleCallback as Scheduler_scheduleCallback,</span>
<span class="hljs-addition">+  ImmediatePriority as ImmediateSchedulerPriority,</span>
<span class="hljs-addition">+  UserBlockingPriority as UserBlockingSchedulerPriority,</span>
<span class="hljs-addition">+  NormalPriority as NormalSchedulerPriority,</span>
<span class="hljs-addition">+  IdlePriority as IdleSchedulerPriority,</span>
<span class="hljs-addition">+} from "./Scheduler";</span>
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
<span class="hljs-addition">+import { MutationMask, NoFlags, Passive } from "./ReactFiberFlags";</span>
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from "./ReactFiberCommitWork";
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
<span class="hljs-addition">+import {</span>
<span class="hljs-addition">+  NoLane, markRootUpdated, NoLanes,</span>
<span class="hljs-addition">+  getNextLanes, getHighestPriorityLane, SyncLane,</span>
<span class="hljs-addition">+  includesBlockingLane</span>
<span class="hljs-addition">+} from './ReactFiberLane';</span>
<span class="hljs-addition">+import {</span>
<span class="hljs-addition">+  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,</span>
<span class="hljs-addition">+  DefaultEventPriority, IdleEventPriority,</span>
<span class="hljs-addition">+} from './ReactEventPriorities';</span>
<span class="hljs-addition">+import { getCurrentEventPriority } from 'react-dom-bindings/src/client/ReactDOMHostConfig';</span>


let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
<span class="hljs-addition">+let workInProgressRootRenderLanes = NoLanes;</span>

<span class="hljs-addition">+export function scheduleUpdateOnFiber(root, fiber, lane) {</span>
<span class="hljs-addition">+ markRootUpdated(root, lane);</span>
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
<span class="hljs-addition">+ const nextLanes = getNextLanes(root, NoLanes);</span>
<span class="hljs-addition">+ const newCallbackPriority = getHighestPriorityLane(nextLanes);</span>
<span class="hljs-addition">+ if (newCallbackPriority === SyncLane) {</span>
<span class="hljs-addition">+   // TODO</span>
<span class="hljs-addition">+ } else {</span>
<span class="hljs-addition">+   let schedulerPriorityLevel;</span>
<span class="hljs-addition">+   switch (lanesToEventPriority(nextLanes)) {</span>
<span class="hljs-addition">+     case DiscreteEventPriority:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = ImmediateSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     case ContinuousEventPriority:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = UserBlockingSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     case DefaultEventPriority:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = NormalSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     case IdleEventPriority:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = IdleSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+     default:</span>
<span class="hljs-addition">+       schedulerPriorityLevel = NormalSchedulerPriority;</span>
<span class="hljs-addition">+       break;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))</span>
  }
}
<span class="hljs-addition">+function performConcurrentWorkOnRoot(root,didTimeout) {</span>
<span class="hljs-addition">+ const lanes = getNextLanes(root, NoLanes);</span>
<span class="hljs-addition">+ if (lanes === NoLanes) {</span>
<span class="hljs-addition">+   return null;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);</span>
<span class="hljs-addition">+ if (shouldTimeSlice) {</span>
<span class="hljs-addition">+   renderRootConcurrent(root, lanes)</span>
<span class="hljs-addition">+ } else {</span>
<span class="hljs-addition">+   renderRootSync(root, lanes);</span>
<span class="hljs-addition">+ }</span>
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
<span class="hljs-addition">+function renderRootConcurrent(root, lanes) {</span>
<span class="hljs-addition">+  console.log(root, lanes);</span>
<span class="hljs-addition">+}</span>
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const { finishedWork } = root;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
<span class="hljs-addition">+function prepareFreshStack(root, lanes) {</span>
  workInProgress = createWorkInProgress(root.current, null);
<span class="hljs-addition">+ workInProgressRootRenderLanes = lanes;</span>
  finishQueueingConcurrentUpdates();
}
<span class="hljs-addition">+function renderRootSync(root, lanes) {</span>
<span class="hljs-addition">+ prepareFreshStack(root, lanes);</span>
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
<span class="hljs-addition">+ const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);</span>
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

<span class="hljs-addition">+export function requestUpdateLane() {</span>
<span class="hljs-addition">+  const updateLane = getCurrentUpdatePriority();</span>
<span class="hljs-addition">+  if (updateLane !== NoLane) {</span>
<span class="hljs-addition">+    return updateLane;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const eventLane = getCurrentEventPriority();</span>
<span class="hljs-addition">+  return eventLane;</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t26236.6 ReactFiberBeginWork.js">36.6 ReactFiberBeginWork.js <a href="#t26236.6 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, IndeterminateComponent, FunctionComponent } from "./ReactWorkTags";
<span class="hljs-addition">+import { processUpdateQueue, cloneUpdateQueue } from "./ReactFiberClassUpdateQueue";</span>
import { mountChildFibers, reconcileChildFibers } from "./ReactChildFiber";
import { shouldSetTextContent } from "react-dom-bindings/src/client/ReactDOMHostConfig";
import { renderWithHooks } from "react-reconciler/src/ReactFiberHooks";

function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
<span class="hljs-addition">+function updateHostRoot(current, workInProgress, renderLanes) {</span>
<span class="hljs-addition">+ const nextProps = workInProgress.pendingProps;</span>
<span class="hljs-addition">+ cloneUpdateQueue(current, workInProgress);</span>
<span class="hljs-addition">+ processUpdateQueue(workInProgress, nextProps, renderLanes)</span>
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function mountIndeterminateComponent(_current, workInProgress, Component) {
  const props = workInProgress.pendingProps;
  const value = renderWithHooks(null, workInProgress, Component, props);
  workInProgress.tag = FunctionComponent;
  reconcileChildren(null, workInProgress, value);
  return workInProgress.child;
}
function updateFunctionComponent(current, workInProgress, Component, nextProps,workInProgressRootRenderLanes) {
  const nextChildren = renderWithHooks(current, workInProgress, Component, nextProps,workInProgressRootRenderLanes);
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
<span class="hljs-addition">+export function beginWork(current, workInProgress, renderLanes) {</span>
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
<span class="hljs-addition">+     return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);</span>
    }
    case FunctionComponent: {
      const Component = workInProgress.type;
      const resolvedProps = workInProgress.pendingProps;
<span class="hljs-addition">+     return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);</span>
    }
    case HostRoot:
<span class="hljs-addition">+     return updateHostRoot(current, workInProgress, renderLanes);</span>
    case HostComponent:
<span class="hljs-addition">+     return updateHostComponent(current, workInProgress, renderLanes);</span>
    case HostText:
    default:
      return null;
  }
}
</code></pre>
<h3 id="t26336.7 ReactFiberLane.js">36.7 ReactFiberLane.js <a href="#t26336.7 ReactFiberLane.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberLane.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TotalLanes = <span class="hljs-number">31</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoLanes = <span class="hljs-number">0b0000000000000000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoLane = <span class="hljs-number">0b0000000000000000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SyncLane = <span class="hljs-number">0b0000000000000000000000000000001</span>;<span class="hljs-comment">// 1</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> InputContinuousLane = <span class="hljs-number">0b0000000000000000000000000000100</span>;<span class="hljs-comment">// 4</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DefaultLane = <span class="hljs-number">0b0000000000000000000000000010000</span>;<span class="hljs-comment">// 16</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NonIdleLanes = <span class="hljs-number">0b0001111111111111111111111111111</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IdleLane = <span class="hljs-number">0b0100000000000000000000000000000</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeLanes</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a | b;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRootUpdated</span>(<span class="hljs-params">root, updateLane</span>) </span>{
  root.pendingLanes |= updateLane;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextLanes</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">const</span> pendingLanes = root.pendingLanes;
  <span class="hljs-keyword">if</span> (pendingLanes === NoLanes) {
    <span class="hljs-keyword">return</span> NoLanes;
  }
  <span class="hljs-keyword">const</span> nextLanes = getHighestPriorityLanes(pendingLanes);
  <span class="hljs-keyword">return</span> nextLanes;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHighestPriorityLanes</span>(<span class="hljs-params">lanes</span>) </span>{
  <span class="hljs-keyword">return</span> getHighestPriorityLane(lanes);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHighestPriorityLane</span>(<span class="hljs-params">lanes</span>) </span>{
  <span class="hljs-keyword">return</span> lanes &amp; -lanes;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">includesNonIdleWork</span>(<span class="hljs-params">lanes</span>) </span>{
  <span class="hljs-keyword">return</span> (lanes &amp; NonIdleLanes) !== NoLanes;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">includesBlockingLane</span>(<span class="hljs-params">root, lanes</span>) </span>{
  <span class="hljs-keyword">const</span> SyncDefaultLanes = InputContinuousLane | DefaultLane;
  <span class="hljs-keyword">return</span> (lanes &amp; SyncDefaultLanes) !== NoLanes;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSubsetOfLanes</span>(<span class="hljs-params">set, subset</span>) </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">set</span> &amp; subset) === subset;
}
</code></pre>
<h3 id="t26436.8 ReactEventPriorities.js">36.8 ReactEventPriorities.js <a href="#t26436.8 ReactEventPriorities.js"> # </a></h3>
<p>src\react-reconciler\src\ReactEventPriorities.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> {
  NoLane, DefaultLane, getHighestPriorityLane,
  includesNonIdleWork, SyncLane, InputContinuousLane, IdleLane
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./ReactFiberLane'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DefaultEventPriority = DefaultLane;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DiscreteEventPriority = SyncLane;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ContinuousEventPriority = InputContinuousLane;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IdleEventPriority = IdleLane;

<span class="hljs-keyword">let</span> currentUpdatePriority = NoLane;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCurrentUpdatePriority</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> currentUpdatePriority;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCurrentUpdatePriority</span>(<span class="hljs-params">newPriority</span>) </span>{
  currentUpdatePriority = newPriority;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isHigherEventPriority</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a !== <span class="hljs-number">0</span> &amp;&amp; a &lt; b;
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lanesToEventPriority</span>(<span class="hljs-params">lanes</span>) </span>{
  <span class="hljs-keyword">const</span> lane = getHighestPriorityLane(lanes);
  <span class="hljs-keyword">if</span> (!isHigherEventPriority(DiscreteEventPriority, lane)) {
    <span class="hljs-keyword">return</span> DiscreteEventPriority;
  }
  <span class="hljs-keyword">if</span> (!isHigherEventPriority(ContinuousEventPriority, lane)) {
    <span class="hljs-keyword">return</span> ContinuousEventPriority;
  }
  <span class="hljs-keyword">if</span> (includesNonIdleWork(lane)) {
    <span class="hljs-keyword">return</span> DefaultEventPriority;
  }
  <span class="hljs-keyword">return</span> IdleEventPriority;
}
</code></pre>
<h3 id="t26536.9 ReactDOMHostConfig.js">36.9 ReactDOMHostConfig.js <a href="#t26536.9 ReactDOMHostConfig.js"> # </a></h3>
<p>src\react-dom-bindings\src\client\ReactDOMHostConfig.js</p>
<pre><code class="lang-diff">import { setInitialProperties, diffProperties, updateProperties } from "./ReactDOMComponent";
import { precacheFiberNode, updateFiberProps } from "./ReactDOMComponentTree";
<span class="hljs-addition">+import { getEventPriority } from '../events/ReactDOMEventListener';</span>
<span class="hljs-addition">+import { DefaultEventPriority } from 'react-reconciler/src/ReactEventPriorities';</span>

export function shouldSetTextContent(type, props) {
  return typeof props.children <span class="hljs-comment">=== "string" || typeof props.children === "number";</span>
}
export const appendInitialChild = (parent, child) =&gt; {
  parent.appendChild(child);
};
export const createInstance = (type, props, internalInstanceHandle) =&gt; {
  const domElement = document.createElement(type);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
};
export const createTextInstance = (content) =&gt; document.createTextNode(content);
export function finalizeInitialChildren(domElement, type, props) {
  setInitialProperties(domElement, type, props);
}
export function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
export function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}

export function prepareUpdate(domElement, type, oldProps, newProps) {
  return diffProperties(domElement, type, oldProps, newProps);
}

export function commitUpdate(domElement, updatePayload, type, oldProps, newProps) {
  updateProperties(domElement, updatePayload, type, oldProps, newProps);
  updateFiberProps(domElement, newProps);
}
export function removeChild(parentInstance, child) {
  parentInstance.removeChild(child);
}
<span class="hljs-addition">+export function getCurrentEventPriority() {</span>
<span class="hljs-addition">+  const currentEvent = window.event;</span>
<span class="hljs-addition">+  if (currentEvent === undefined) {</span>
<span class="hljs-addition">+    return DefaultEventPriority;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return getEventPriority(currentEvent.type);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t26636.10 ReactDOMEventListener.js">36.10 ReactDOMEventListener.js <a href="#t26636.10 ReactDOMEventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\ReactDOMEventListener.js</p>
<pre><code class="lang-diff">import getEventTarget from "./getEventTarget";
import { getClosestInstanceFromNode } from "../client/ReactDOMComponentTree";
import { dispatchEventForPluginEventSystem } from "./DOMPluginEventSystem";
<span class="hljs-addition">+import { DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority } from 'react-reconciler/src/ReactEventPriorities';</span>

export function createEventListenerWrapperWithPriority(
  targetContainer,
  domEventName,
  eventSystemFlags
) {
  const listenerWrapper = dispatchDiscreteEvent;
  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
}
function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
}
export function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const targetInst = getClosestInstanceFromNode(nativeEventTarget);
  dispatchEventForPluginEventSystem(
    domEventName,
    eventSystemFlags,
    nativeEvent,
    targetInst,
    targetContainer
  );
}
<span class="hljs-addition">+export function getEventPriority(domEventName) {</span>
<span class="hljs-addition">+  switch (domEventName) {</span>
<span class="hljs-addition">+    case 'click':</span>
<span class="hljs-addition">+      return DiscreteEventPriority;</span>
<span class="hljs-addition">+    case 'drag':</span>
<span class="hljs-addition">+      return ContinuousEventPriority;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return DefaultEventPriority;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t26736.11 Scheduler.js">36.11 Scheduler.js <a href="#t26736.11 Scheduler.js"> # </a></h3>
<p>src\react-reconciler\src\Scheduler.js</p>
<pre><code class="lang-diff">import * as Scheduler from 'scheduler'

export const scheduleCallback = Scheduler.unstable_scheduleCallback
export const NormalPriority = Scheduler.unstable_NormalPriority
<span class="hljs-addition">+export const ImmediatePriority = Scheduler.unstable_ImmediatePriority;</span>
<span class="hljs-addition">+export const UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;</span>
<span class="hljs-addition">+export const LowPriority = Scheduler.unstable_LowPriority;</span>
<span class="hljs-addition">+export const IdlePriority = Scheduler.unstable_IdlePriority;</span>
</code></pre>
<h2 id="t26837.更新渲染">37.更新渲染 <a href="#t26837.更新渲染"> # </a></h2>
<h3 id="t26937.1 main.jsx">37.1 main.jsx <a href="#t26937.1 main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";
<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+  return &lt;button onClick={() =&gt; {</span>
<span class="hljs-addition">+    setNumber(number + 1)</span>
<span class="hljs-addition">+  }}&gt;{number}&lt;/button&gt;</span>
<span class="hljs-addition">+}</span>
const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById("root");
const root = createRoot(container);
root.render(element);
</code></pre>
<h3 id="t27037.2 ReactFiberHooks.js">37.2 ReactFiberHooks.js <a href="#t27037.2 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from "shared/ReactSharedInternals";
import { enqueueConcurrentHookUpdate } from "./ReactFiberConcurrentUpdates";
<span class="hljs-addition">+import { scheduleUpdateOnFiber, requestUpdateLane } from "./ReactFiberWorkLoop";</span>
import is from "shared/objectIs";
import { Passive as PassiveEffect, Update as UpdateEffect } from "./ReactFiberFlags";
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from "./ReactHookEffectTags";

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
};
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== "function" ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
<span class="hljs-addition">+ const lane = requestUpdateLane(fiber);</span>
  const update = {
<span class="hljs-addition">+   lane,</span>
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const lastRenderedReducer = queue.lastRenderedReducer;
  const currentState = queue.lastRenderedState;
  const eagerState = lastRenderedReducer(currentState, action);
  update.hasEagerState = true;
  update.eagerState = eagerState;
  if (is(eagerState, currentState)) {
    return;
  }
<span class="hljs-addition">+ const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span>
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, fiber, lane);</span>
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}
export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}
</code></pre>
<h3 id="t27137.3 ReactFiberWorkLoop.js">37.3 ReactFiberWorkLoop.js <a href="#t27137.3 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
} from "./Scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags, Passive } from "./ReactFiberFlags";
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from "./ReactFiberCommitWork";
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
  includesBlockingLane
} from './ReactFiberLane';
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
<span class="hljs-addition">+ DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority</span>
} from './ReactEventPriorities';
import { getCurrentEventPriority } from 'react-dom-bindings/src/client/ReactDOMHostConfig';
<span class="hljs-addition">+import { scheduleSyncCallback, flushSyncCallbacks } from './ReactFiberSyncTaskQueue';</span>

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

export function scheduleUpdateOnFiber(root, fiber, lane) {
  markRootUpdated(root, lane);
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  const nextLanes = getNextLanes(root, NoLanes);
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
<span class="hljs-addition">+   scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));</span>
<span class="hljs-addition">+   queueMicrotask(flushSyncCallbacks);</span>
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
    Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))
  }
}
<span class="hljs-addition">+function performSyncWorkOnRoot(root) {</span>
<span class="hljs-addition">+  const lanes = getNextLanes(root, NoLanes);</span>
<span class="hljs-addition">+  renderRootSync(root, lanes);</span>
<span class="hljs-addition">+  const finishedWork = root.current.alternate</span>
<span class="hljs-addition">+  root.finishedWork = finishedWork</span>
<span class="hljs-addition">+  commitRoot(root)</span>
<span class="hljs-addition">+  return null;//如果没有任务了一定要返回null</span>
<span class="hljs-addition">+}</span>
function performConcurrentWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
  const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);
  if (shouldTimeSlice) {
    renderRootConcurrent(root, lanes)
  } else {
    renderRootSync(root, lanes);
  }
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function renderRootConcurrent(root, lanes) {
  console.log(root, lanes);
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
<span class="hljs-addition">+function commitRoot(root) {</span>
<span class="hljs-addition">+  const previousPriority = getCurrentUpdatePriority();</span>
<span class="hljs-addition">+  try {</span>
<span class="hljs-addition">+    setCurrentUpdatePriority(DiscreteEventPriority);</span>
<span class="hljs-addition">+    commitRootImpl(root);</span>
<span class="hljs-addition">+  } finally {</span>
<span class="hljs-addition">+    setCurrentUpdatePriority(previousPriority);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function commitRootImpl(root) {</span>
  const { finishedWork } = root;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
<span class="hljs-addition">+}</span>
function prepareFreshStack(root, lanes) {
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
  prepareFreshStack(root, lanes);
  workLoopSync();
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}
</code></pre>
<h3 id="t27237.4 ReactFiberSyncTaskQueue.js">37.4 ReactFiberSyncTaskQueue.js <a href="#t27237.4 ReactFiberSyncTaskQueue.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberSyncTaskQueue.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { DiscreteEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority } <span class="hljs-keyword">from</span> <span class="hljs-string">'./ReactEventPriorities'</span>;

<span class="hljs-keyword">let</span> syncQueue = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> isFlushingSyncQueue = <span class="hljs-literal">false</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleSyncCallback</span>(<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">if</span> (syncQueue === <span class="hljs-literal">null</span>) {
    syncQueue = [callback];
  } <span class="hljs-keyword">else</span> {
    syncQueue.push(callback);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSyncCallbacks</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (!isFlushingSyncQueue &amp;&amp; syncQueue !== <span class="hljs-literal">null</span>) {
    isFlushingSyncQueue = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> previousUpdatePriority = getCurrentUpdatePriority();
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> isSync = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">const</span> queue = syncQueue;
      setCurrentUpdatePriority(DiscreteEventPriority);
      <span class="hljs-keyword">for</span> (; i &lt; queue.length; i++) {
        <span class="hljs-keyword">let</span> callback = queue[i];
        <span class="hljs-keyword">do</span> {
          callback = callback(isSync);
        } <span class="hljs-keyword">while</span> (callback !== <span class="hljs-literal">null</span>);
      }
      syncQueue = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">finally</span> {
      setCurrentUpdatePriority(previousUpdatePriority);
      isFlushingSyncQueue = <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<h3 id="t27337.5  ReactFiberConcurrentUpdates.js">37.5  ReactFiberConcurrentUpdates.js <a href="#t27337.5  ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-diff">import { HostRoot } from "./ReactWorkTags";

const concurrentQueues = [];
let concurrentQueuesIndex = 0;

export function markUpdateLaneFromFiberToRoot(sourceFiber) {
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {
    node = parent;
    parent = parent.return;
  }
  if (node.tag <span class="hljs-comment">=== HostRoot) {</span>
    const root = node.stateNode;
    return root;
  }
  return null;
}
<span class="hljs-addition">+export function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {</span>
<span class="hljs-addition">+ enqueueUpdate(fiber, queue, update, lane);</span>
  return getRootForUpdatedFiber(fiber);
}
export function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
  enqueueUpdate(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}

function enqueueUpdate(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
}
function getRootForUpdatedFiber(sourceFiber) {
  let node = sourceFiber;
  let parent = node.return;
  while (parent !== null) {
    node = parent;
    parent = node.return;
  }
  return node.tag <span class="hljs-comment">=== HostRoot ? node.stateNode : null;</span>
}

export function finishQueueingConcurrentUpdates() {
  const endIndex = concurrentQueuesIndex;
  concurrentQueuesIndex = 0;
  let i = 0;
  while (i &lt; endIndex) {
    const fiber = concurrentQueues[i++];
    const queue = concurrentQueues[i++];
    const update = concurrentQueues[i++];
    const lane = concurrentQueues[i++]
    if (queue !== null &amp;&amp; update !== null) {
      const pending = queue.pending;
      if (pending <span class="hljs-comment">=== null) {</span>
        update.next = update;
      } else {
        update.next = pending.next;
        pending.next = update;
      }
      queue.pending = update;
    }
  }
}

</code></pre>
<h3 id="t27437.6 ReactDOMEventListener.js">37.6 ReactDOMEventListener.js <a href="#t27437.6 ReactDOMEventListener.js"> # </a></h3>
<p>src\react-dom-bindings\src\events\ReactDOMEventListener.js</p>
<pre><code class="lang-diff">import getEventTarget from "./getEventTarget";
import { getClosestInstanceFromNode } from "../client/ReactDOMComponentTree";
import { dispatchEventForPluginEventSystem } from "./DOMPluginEventSystem";
import {
  DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority,
<span class="hljs-addition">+ getCurrentUpdatePriority, setCurrentUpdatePriority</span>
} from 'react-reconciler/src/ReactEventPriorities';

export function createEventListenerWrapperWithPriority(
  targetContainer,
  domEventName,
  eventSystemFlags
) {
  const listenerWrapper = dispatchDiscreteEvent;
  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
}
<span class="hljs-addition">+function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {</span>
<span class="hljs-addition">+  const previousPriority = getCurrentUpdatePriority();</span>
<span class="hljs-addition">+  try {</span>
<span class="hljs-addition">+    setCurrentUpdatePriority(DiscreteEventPriority);</span>
     dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent)
<span class="hljs-addition">+  } finally {</span>
<span class="hljs-addition">+    setCurrentUpdatePriority(previousPriority);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
export function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const targetInst = getClosestInstanceFromNode(nativeEventTarget);
  dispatchEventForPluginEventSystem(
    domEventName,
    eventSystemFlags,
    nativeEvent,
    targetInst,
    targetContainer
  );
}


export function getEventPriority(domEventName) {
  switch (domEventName) {
    case 'click':
      return DiscreteEventPriority;
    case 'drag':
      return ContinuousEventPriority;
    default:
      return DefaultEventPriority;
  }
}
</code></pre>
<h2 id="t27538.并发渲染">38.并发渲染 <a href="#t27538.并发渲染"> # </a></h2>
<h3 id="t27638.1  src\main.jsx">38.1  src\main.jsx <a href="#t27638.1  src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  console.log('FunctionComponent');</span>
<span class="hljs-addition">+  const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+  React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+  }, []);</span>
<span class="hljs-addition">+  return (&lt;button onClick={() =&gt; setNumber(number + 1)}&gt;{number}&lt;/button&gt;)</span>
<span class="hljs-addition">+}</span>
const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById("root");
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t27738.2  ReactFiberWorkLoop.js">38.2  ReactFiberWorkLoop.js <a href="#t27738.2  ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
<span class="hljs-addition">+ shouldYield</span>
} from "./Scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags, Passive } from "./ReactFiberFlags";
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from "./ReactFiberCommitWork";
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
  includesBlockingLane
} from './ReactFiberLane';
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
  DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority
} from './ReactEventPriorities';
import { getCurrentEventPriority } from 'react-dom-bindings/src/client/ReactDOMHostConfig';
import { scheduleSyncCallback, flushSyncCallbacks } from './ReactFiberSyncTaskQueue';

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

<span class="hljs-addition">+const RootInProgress = 0;</span>
<span class="hljs-addition">+const RootCompleted = 5;</span>
<span class="hljs-addition">+let workInProgressRoot = null;</span>
<span class="hljs-addition">+let workInProgressRootExitStatus = RootInProgress;</span>

export function scheduleUpdateOnFiber(root, fiber, lane) {
  markRootUpdated(root, lane);
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  const nextLanes = getNextLanes(root, NoLanes);
<span class="hljs-addition">+ if (nextLanes === NoLanes) {</span>
<span class="hljs-addition">+   root.callbackNode = null;</span>
<span class="hljs-addition">+   root.callbackPriority = NoLane;</span>
<span class="hljs-addition">+   return;</span>
<span class="hljs-addition">+ }</span>
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
<span class="hljs-addition">+ let newCallbackNode;</span>
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
    queueMicrotask(flushSyncCallbacks);
<span class="hljs-addition">+   newCallbackNode = null;</span>
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
<span class="hljs-addition">+   newCallbackNode = Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))</span>
  }
<span class="hljs-addition">+ root.callbackNode = newCallbackNode;</span>
}
function performSyncWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  renderRootSync(root, lanes);
  const finishedWork = root.current.alternate
  root.finishedWork = finishedWork
  commitRoot(root)
  return null;
}
function performConcurrentWorkOnRoot(root, didTimeout) {
<span class="hljs-addition">+ const originalCallbackNode = root.callbackNode;</span>
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
  const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);
<span class="hljs-addition">+ const exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);</span>
<span class="hljs-addition">+ if (exitStatus !== RootInProgress) {</span>
<span class="hljs-addition">+   const finishedWork = root.current.alternate</span>
<span class="hljs-addition">+   root.finishedWork = finishedWork</span>
<span class="hljs-addition">+   commitRoot(root)</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ if (root.callbackNode === originalCallbackNode) {</span>
<span class="hljs-addition">+   return performConcurrentWorkOnRoot.bind(null, root);</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ return null;</span>
}
function renderRootConcurrent(root, lanes) {
<span class="hljs-addition">+ if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>
<span class="hljs-addition">+   prepareFreshStack(root, lanes);</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ workLoopConcurrent();</span>
<span class="hljs-addition">+ if (workInProgress !== null) {</span>
<span class="hljs-addition">+   return RootInProgress;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ workInProgressRoot = null;</span>
<span class="hljs-addition">+ workInProgressRootRenderLanes = NoLanes;</span>
<span class="hljs-addition">+ return workInProgressRootExitStatus;</span>
}
<span class="hljs-addition">+function workLoopConcurrent() {</span>
<span class="hljs-addition">+  sleep(6);</span>
<span class="hljs-addition">+  performUnitOfWork(workInProgress);</span>
<span class="hljs-addition">+  console.log('shouldYield()', shouldYield(), workInProgress?.type);</span>
<span class="hljs-addition">+}</span>
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const previousPriority = getCurrentUpdatePriority();
  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    commitRootImpl(root);
  } finally {
    setCurrentUpdatePriority(previousPriority);
  }
}
function commitRootImpl(root) {
  const { finishedWork } = root;
<span class="hljs-addition">+ root.callbackNode = null;</span>
<span class="hljs-addition">+ root.callbackPriority = NoLane;</span>
<span class="hljs-addition">+ workInProgressRoot = null;</span>
<span class="hljs-addition">+ workInProgressRootRenderLanes = NoLanes;</span>
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root, lanes) {
<span class="hljs-addition">+ workInProgressRoot = root;</span>
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
<span class="hljs-addition">+ //不是一个根，或者是更高优先级的更新</span>
<span class="hljs-addition">+ if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>
    prepareFreshStack(root, lanes)
<span class="hljs-addition">+ }</span>
  workLoopSync();
<span class="hljs-addition">+ return workInProgressRootExitStatus;</span>
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
<span class="hljs-addition">+ if (workInProgressRootExitStatus === RootInProgress) {</span>
<span class="hljs-addition">+   workInProgressRootExitStatus = RootCompleted;</span>
<span class="hljs-addition">+ }</span>
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}

<span class="hljs-addition">+function sleep(time) {</span>
<span class="hljs-addition">+  const timeStamp = new Date().getTime();</span>
<span class="hljs-addition">+  const endTime = timeStamp + time;</span>
<span class="hljs-addition">+  while (true) {</span>
<span class="hljs-addition">+    if (new Date().getTime() &gt; endTime) {</span>
<span class="hljs-addition">+      return;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t27838.3 Scheduler.js">38.3 Scheduler.js <a href="#t27838.3 Scheduler.js"> # </a></h3>
<p>src\react-reconciler\src\Scheduler.js</p>
<pre><code class="lang-diff">import * as Scheduler from 'scheduler'
export const scheduleCallback = Scheduler.unstable_scheduleCallback
export const NormalPriority = Scheduler.unstable_NormalPriority
export const ImmediatePriority = Scheduler.unstable_ImmediatePriority;
export const UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
export const LowPriority = Scheduler.unstable_LowPriority;
export const IdlePriority = Scheduler.unstable_IdlePriority;
<span class="hljs-addition">+export const shouldYield = Scheduler.unstable_shouldYield</span>
</code></pre>
<h3 id="t27938.4 Scheduler.js">38.4 Scheduler.js <a href="#t27938.4 Scheduler.js"> # </a></h3>
<p>src\scheduler\src\forks\Scheduler.js</p>
<pre><code class="lang-diff">import {
  ImmediatePriority,
  UserBlockingPriority,
  NormalPriority,
  LowPriority,
  IdlePriority,
} from "../SchedulerPriorities";
import { push, pop, peek } from "../SchedulerMinHeap";
import { frameYieldMs } from "../SchedulerFeatureFlags";

const maxSigned31BitInt = 1073741823;
const IMMEDIATE_PRIORITY_TIMEOUT = -1;
const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
const NORMAL_PRIORITY_TIMEOUT = 5000;
const LOW_PRIORITY_TIMEOUT = 10000;
const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;

const taskQueue = [];
let taskIdCounter = 1;
let scheduledHostCallback = null;
let startTime = -1;
let currentTask = null;
const frameInterval = frameYieldMs;
const channel = new MessageChannel();
const port = channel.port2;

const getCurrentTime = () =&gt; performance.now();
channel.port1.onmessage = performWorkUntilDeadline;

function schedulePerformWorkUntilDeadline() {
  port.postMessage(null);
}
function performWorkUntilDeadline() {
  if (scheduledHostCallback !== null) {
    startTime = getCurrentTime();
    let hasMoreWork = true;
    try {
      hasMoreWork = scheduledHostCallback(startTime);
    } finally {
      if (hasMoreWork) {
        schedulePerformWorkUntilDeadline();
      } else {
        scheduledHostCallback = null;
      }
    }
  }
}
function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  schedulePerformWorkUntilDeadline();
}

function unstable_scheduleCallback(priorityLevel, callback) {
  const currentTime = getCurrentTime();
  const startTime = currentTime;
  let timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }
  const expirationTime = startTime + timeout;
  const newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sort<span class="hljs-comment">Index: -1,</span>
  };
  newTask.sortIndex = expirationTime;
  push(taskQueue, newTask);
  requestHostCallback(flushWork);
  return newTask;
}

function flushWork(initialTime) {
  return workLoop(initialTime);
}

function shouldYieldToHost() {
  const timeElapsed = getCurrentTime() - startTime;
  if (timeElapsed &lt; frameInterval) {
    return false;
  }
  return true;
}
function workLoop(initialTime) {
  let currentTime = initialTime;
  currentTask = peek(taskQueue);
  while (currentTask !== null) {
    if (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) {
      break;
    }
    const callback = currentTask.callback;
    if (typeof callback <span class="hljs-comment">=== "function") {</span>
      currentTask.callback = null;
      const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      if (typeof continuationCallback <span class="hljs-comment">=== "function") {</span>
        currentTask.callback = continuationCallback;
        return true;
      }
      if (currentTask <span class="hljs-comment">=== peek(taskQueue)) {</span>
        pop(taskQueue);
      }
    } else {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
  }
  if (currentTask !== null) {
    return true;
  }
  return false;
}

export {
  NormalPriority as unstable_NormalPriority,
  unstable_scheduleCallback,
<span class="hljs-addition">+ shouldYieldToHost as unstable_shouldYield</span>
};
</code></pre>
<h3 id="t28038.5 ReactFiberLane.js">38.5 ReactFiberLane.js <a href="#t28038.5 ReactFiberLane.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberLane.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { allowConcurrentByDefault } from 'shared/ReactFeatureFlags';</span>

export const TotalLanes = 31;
export const NoLanes = 0b0000000000000000000000000000000;
export const NoLane = 0b0000000000000000000000000000000;
export const SyncLane = 0b0000000000000000000000000000001;// 1
export const InputContinuousLane = 0b0000000000000000000000000000100;// 4
export const DefaultLane = 0b0000000000000000000000000010000;// 16
export const NonIdleLanes = 0b0001111111111111111111111111111;
export const IdleLane = 0b0100000000000000000000000000000;

export function mergeLanes(a, b) {
  return a | b;
}
export function markRootUpdated(root, updateLane) {
  root.pendingLanes |= updateLane;
}

export function getNextLanes(root) {
  const pendingLanes = root.pendingLanes;
  if (pendingLanes <span class="hljs-comment">=== NoLanes) {</span>
    return NoLanes;
  }
  const nextLanes = getHighestPriorityLanes(pendingLanes);
  return nextLanes;
}

function getHighestPriorityLanes(lanes) {
  return getHighestPriorityLane(lanes);
}

export function getHighestPriorityLane(lanes) {
  return lanes &amp; -lanes;
}

export function includesNonIdleWork(lanes) {
  return (lanes &amp; NonIdleLanes) !== NoLanes;
}
export function includesBlockingLane(root, lanes) {
<span class="hljs-addition">+ if (allowConcurrentByDefault) {</span>
<span class="hljs-addition">+   return false;</span>
<span class="hljs-addition">+ }</span>
  const SyncDefaultLanes = InputContinuousLane | DefaultLane;
  return (lanes &amp; SyncDefaultLanes) !== NoLanes;
}
export function isSubsetOfLanes(set, subset) {
  return (set &amp; subset) <span class="hljs-comment">=== subset;</span>
}
</code></pre>
<h3 id="t28138.6 ReactFeatureFlags.js">38.6 ReactFeatureFlags.js <a href="#t28138.6 ReactFeatureFlags.js"> # </a></h3>
<p>src\shared\ReactFeatureFlags.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> allowConcurrentByDefault = <span class="hljs-literal">true</span>; 
</code></pre>
<h2 id="t28239.批量更新">39.批量更新 <a href="#t28239.批量更新"> # </a></h2>
<h3 id="t28339.1  src\main.jsx">39.1  src\main.jsx <a href="#t28339.1  src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  console.log('FunctionComponent');</span>
<span class="hljs-addition">+  const [number, setNumber] = React.useState(0);</span>
<span class="hljs-addition">+  React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+  }, []);</span>
<span class="hljs-addition">+  return (&lt;button onClick={() =&gt; {</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+    setNumber(number =&gt; number + 1)</span>
<span class="hljs-addition">+  }}&gt;{number}&lt;/button&gt;)</span>
<span class="hljs-addition">+}</span>
const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById("root");
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t28439.2 ReactFiberHooks.js">39.2 ReactFiberHooks.js <a href="#t28439.2 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from "shared/ReactSharedInternals";
import { enqueueConcurrentHookUpdate } from "./ReactFiberConcurrentUpdates";
import { scheduleUpdateOnFiber, requestUpdateLane } from "./ReactFiberWorkLoop";
import is from "shared/objectIs";
import { Passive as PassiveEffect, Update as UpdateEffect } from "./ReactFiberFlags";
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from "./ReactHookEffectTags";
<span class="hljs-addition">+import { NoLanes } from './ReactFiberLane';</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
};
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== "function" ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const lane = requestUpdateLane(fiber);
  const update = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
<span class="hljs-addition">+ const alternate = fiber.alternate;</span>
<span class="hljs-addition">+ if (fiber.lanes === NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) {</span>
    const lastRenderedReducer = queue.lastRenderedReducer;
    const currentState = queue.lastRenderedState;
    const eagerState = lastRenderedReducer(currentState, action);
    update.hasEagerState = true;
    update.eagerState = eagerState;
    if (is(eagerState, currentState)) {
      return;
    }
<span class="hljs-addition">+ }</span>
  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
  scheduleUpdateOnFiber(root, fiber, lane);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}
</code></pre>
<h3 id="t28539.3  ReactFiberWorkLoop.js">39.3  ReactFiberWorkLoop.js <a href="#t28539.3  ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
  shouldYield
} from "./Scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags, Passive } from "./ReactFiberFlags";
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from "./ReactFiberCommitWork";
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
  includesBlockingLane
} from './ReactFiberLane';
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
  DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority
} from './ReactEventPriorities';
import { getCurrentEventPriority } from 'react-dom-bindings/src/client/ReactDOMHostConfig';
import { scheduleSyncCallback, flushSyncCallbacks } from './ReactFiberSyncTaskQueue';

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

const RootInProgress = 0;
const RootCompleted = 5;
let workInProgressRoot = null;
let workInProgressRootExitStatus = RootInProgress;

export function scheduleUpdateOnFiber(root, fiber, lane) {
  markRootUpdated(root, lane);
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
  const nextLanes = getNextLanes(root, NoLanes);
  if (nextLanes <span class="hljs-comment">=== NoLanes) {</span>
    root.callbackNode = null;
    root.callbackPriority = NoLane;
    return;
  }
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
<span class="hljs-addition">+ const existingCallbackPriority = root.callbackPriority;</span>
<span class="hljs-addition">+ if (existingCallbackPriority === newCallbackPriority) {</span>
<span class="hljs-addition">+   return;</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+  let newCallbackNode;</span>
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
    queueMicrotask(flushSyncCallbacks);
    newCallbackNode = null;
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
<span class="hljs-addition">+   newCallbackNode = Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))</span>
  }
<span class="hljs-addition">+ root.callbackPriority = newCallbackPriority;</span>
<span class="hljs-addition">+ root.callbackNode = newCallbackNode;</span>
}
function performSyncWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  renderRootSync(root, lanes);
  const finishedWork = root.current.alternate
  root.finishedWork = finishedWork
  commitRoot(root)
  return null;
}
function performConcurrentWorkOnRoot(root, didTimeout) {
  const originalCallbackNode = root.callbackNode;
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
  const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);
  const exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
  if (exitStatus !== RootInProgress) {
    const finishedWork = root.current.alternate
    root.finishedWork = finishedWork
    commitRoot(root)
  }
  if (root.callbackNode <span class="hljs-comment">=== originalCallbackNode) {</span>
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}
function renderRootConcurrent(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
  }
  workLoopConcurrent();
  if (workInProgress !== null) {
    return RootInProgress;
  }
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}
function workLoopConcurrent() {
  while (workInProgress !== null &amp;&amp; !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const previousPriority = getCurrentUpdatePriority();
  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    commitRootImpl(root);
  } finally {
    setCurrentUpdatePriority(previousPriority);
  }
}
function commitRootImpl(root) {
  const { finishedWork } = root;
  root.callbackNode = null;
<span class="hljs-addition">+ root.callbackPriority = NoLane;</span>
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root, lanes) {
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes)
  }
  workLoopSync();
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
  if (workInProgressRootExitStatus <span class="hljs-comment">=== RootInProgress) {</span>
    workInProgressRootExitStatus = RootCompleted;
  }
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}
</code></pre>
<h2 id="t28640.高优更新打断低优更新(useRef)">40.高优更新打断低优更新(useRef) <a href="#t28640.高优更新打断低优更新(useRef)"> # </a></h2>
<h3 id="t28740.1 src\main.jsx">40.1 src\main.jsx <a href="#t28740.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

function FunctionComponent() {
<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  const [numbers, setNumbers] = React.useState(new Array(10).fill('A'));</span>
<span class="hljs-addition">+  const divRef = React.useRef();</span>
<span class="hljs-addition">+  React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+    setTimeout(() =&gt; {</span>
<span class="hljs-addition">+      divRef.current.click();</span>
<span class="hljs-addition">+    }, 10);</span>
<span class="hljs-addition">+    setNumbers(numbers =&gt; numbers.map(item =&gt; item + 'B'))</span>
<span class="hljs-addition">+  }, []);</span>
<span class="hljs-addition">+  return (&lt;div ref={divRef} onClick={() =&gt; {</span>
<span class="hljs-addition">+    setNumbers(numbers =&gt; numbers.map(item =&gt; item + 'C'))</span>
<span class="hljs-addition">+  }}&gt;{numbers.map((number, index) =&gt; &lt;span key={index}&gt;{number}&lt;/span&gt;)}&lt;/div&gt;)</span>
<span class="hljs-addition">+}</span>
const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById("root");
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t28840.2 react\index.js">40.2 react\index.js <a href="#t28840.2 react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff">export {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  useReducer,
  useState,
  useEffect,
  useLayoutEffect,
<span class="hljs-addition">+ useRef</span>
} from "./src/React";
</code></pre>
<h3 id="t28940.3 React.js">40.3 React.js <a href="#t28940.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { useReducer, useState, useEffect, useLayoutEffect, useRef } from "./ReactHooks";</span>
import ReactSharedInternals from "./ReactSharedInternals";

export {
  useReducer,
  useState,
  useEffect,
  useLayoutEffect,
<span class="hljs-addition">+ useRef,</span>
  ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
};
</code></pre>
<h3 id="t29040.4 ReactHooks.js">40.4 ReactHooks.js <a href="#t29040.4 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from "./ReactCurrentDispatcher";

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

export function useState(initialState) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

export function useEffect(create, deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
export function useLayoutEffect(create, deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
<span class="hljs-addition">+export function useRef(initialValue) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useRef(initialValue);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t29140.5 ReactFiberWorkLoop.js">40.5 ReactFiberWorkLoop.js <a href="#t29140.5 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
  shouldYield，
<span class="hljs-addition">+ cancelCallback as Scheduler_cancelCallback</span>
} from "./Scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags, Passive } from "./ReactFiberFlags";
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from "./ReactFiberCommitWork";
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
  includesBlockingLane
} from './ReactFiberLane';
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
  DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority
} from './ReactEventPriorities';
import { getCurrentEventPriority } from 'react-dom-bindings/src/client/ReactDOMHostConfig';
import { scheduleSyncCallback, flushSyncCallbacks } from './ReactFiberSyncTaskQueue';

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

const RootInProgress = 0;
const RootCompleted = 5;
let workInProgressRoot = null;
let workInProgressRootExitStatus = RootInProgress;

export function scheduleUpdateOnFiber(root, fiber, lane) {
  markRootUpdated(root, lane);
  ensureRootIsScheduled(root);
}
function ensureRootIsScheduled(root) {
<span class="hljs-addition">+ const existingCallbackNode = root.callbackNode;</span>
<span class="hljs-addition">+ const nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);</span>
  if (nextLanes <span class="hljs-comment">=== NoLanes) {</span>
    root.callbackNode = null;
    root.callbackPriority = NoLane;
    return;
  }
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
  const existingCallbackPriority = root.callbackPriority;
  if (existingCallbackPriority <span class="hljs-comment">=== newCallbackPriority) {</span>
    return;
  }
<span class="hljs-addition">+ if (existingCallbackNode != null) {</span>
<span class="hljs-addition">+   Scheduler_cancelCallback(existingCallbackNode);</span>
<span class="hljs-addition">+ }</span>
  let newCallbackNode;
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
    queueMicrotask(flushSyncCallbacks);
    newCallbackNode = null;
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
    newCallbackNode = Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))
  }
  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}
function performSyncWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  renderRootSync(root, lanes);
  const finishedWork = root.current.alternate
  root.finishedWork = finishedWork
  commitRoot(root)
  return null;
}
function performConcurrentWorkOnRoot(root, didTimeout) {
  const originalCallbackNode = root.callbackNode;
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
  const shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; (!didTimeout);
  const exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
  if (exitStatus !== RootInProgress) {
    const finishedWork = root.current.alternate
    root.finishedWork = finishedWork
    commitRoot(root)
  }
  if (root.callbackNode <span class="hljs-comment">=== originalCallbackNode) {</span>
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}
function renderRootConcurrent(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
  }
  workLoopConcurrent();
  if (workInProgress !== null) {
    return RootInProgress;
  }
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}
function workLoopConcurrent() {
  while (workInProgress !== null &amp;&amp; !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const previousPriority = getCurrentUpdatePriority();
  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    commitRootImpl(root);
  } finally {
    setCurrentUpdatePriority(previousPriority);
  }
}
function commitRootImpl(root) {
  const { finishedWork } = root;
  console.log('commit', finishedWork.child.memoizedState.memoizedState);
  root.callbackNode = null;
  root.callbackPriority = NoLane;
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
}
function prepareFreshStack(root, lanes) {
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes)
  }
  workLoopSync();
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
  if (workInProgressRootExitStatus <span class="hljs-comment">=== RootInProgress) {</span>
    workInProgressRootExitStatus = RootCompleted;
  }
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}
</code></pre>
<h3 id="t29240.6 ReactFiberLane.js">40.6 ReactFiberLane.js <a href="#t29240.6 ReactFiberLane.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberLane.js</p>
<pre><code class="lang-diff">import { allowConcurrentByDefault } from 'shared/ReactFeatureFlags';

export const TotalLanes = 31;
export const NoLanes = 0b0000000000000000000000000000000;
export const NoLane = 0b0000000000000000000000000000000;
export const SyncLane = 0b0000000000000000000000000000001;// 1
export const InputContinuousLane = 0b0000000000000000000000000000100;// 4
export const DefaultLane = 0b0000000000000000000000000010000;// 16
export const NonIdleLanes = 0b0001111111111111111111111111111;
export const IdleLane = 0b0100000000000000000000000000000;

export function mergeLanes(a, b) {
  return a | b;
}
export function markRootUpdated(root, updateLane) {
  root.pendingLanes |= updateLane;
}

<span class="hljs-addition">+export function getNextLanes(root, wipLanes) {</span>
  const pendingLanes = root.pendingLanes;
  if (pendingLanes <span class="hljs-comment">=== NoLanes) {</span>
    return NoLanes;
  }
  const nextLanes = getHighestPriorityLanes(pendingLanes);
<span class="hljs-addition">+ if (wipLanes !== NoLanes &amp;&amp; wipLanes !== nextLanes) {</span>
<span class="hljs-addition">+   if (nextLanes &gt;= wipLanes) {</span>
<span class="hljs-addition">+     return wipLanes;</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+ }</span>
  return nextLanes;
}

function getHighestPriorityLanes(lanes) {
  return getHighestPriorityLane(lanes);
}

export function getHighestPriorityLane(lanes) {
  return lanes &amp; -lanes;
}

export function includesNonIdleWork(lanes) {
  return (lanes &amp; NonIdleLanes) !== NoLanes;
}
export function includesBlockingLane(root, lanes) {
  if (allowConcurrentByDefault) {
    return false;
  }
  const SyncDefaultLanes = InputContinuousLane | DefaultLane;
  return (lanes &amp; SyncDefaultLanes) !== NoLanes;
}
export function isSubsetOfLanes(set, subset) {
  return (set &amp; subset) <span class="hljs-comment">=== subset;</span>
}
</code></pre>
<h3 id="t29340.7  ReactFiberHooks.js">40.7  ReactFiberHooks.js <a href="#t29340.7  ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from "shared/ReactSharedInternals";
import { enqueueConcurrentHookUpdate } from "./ReactFiberConcurrentUpdates";
import { scheduleUpdateOnFiber, requestUpdateLane } from "./ReactFiberWorkLoop";
import is from "shared/objectIs";
import { Passive as PassiveEffect, Update as UpdateEffect } from "./ReactFiberFlags";
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from "./ReactHookEffectTags";
import { NoLanes } from './ReactFiberLane';

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
<span class="hljs-addition">+ useRef: mountRef,</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
<span class="hljs-addition">+ useRef: updateRef</span>
};
<span class="hljs-addition">+function mountRef(initialValue) {</span>
<span class="hljs-addition">+  const hook = mountWorkInProgressHook();</span>
<span class="hljs-addition">+  const ref = {</span>
<span class="hljs-addition">+    current: initialValue,</span>
<span class="hljs-addition">+  };</span>
<span class="hljs-addition">+  hook.memoizedState = ref;</span>
<span class="hljs-addition">+  return ref;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function updateRef() {</span>
<span class="hljs-addition">+  const hook = updateWorkInProgressHook();</span>
<span class="hljs-addition">+  return hook.memoizedState;</span>
<span class="hljs-addition">+}</span>
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== "function" ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  const pendingQueue = queue.pending;
  let baseQueue = null;
  let newState = current.memoizedState;
  if (pendingQueue !== null) {
    baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let update = first;
    do {
      if (update.hasEagerState) {
        newState = update.eagerState;
      } else {
        const action = update.action;
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
  }
  hook.memoizedState = newState;
  queue.lastRenderedState = newState;
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const lane = requestUpdateLane(fiber);
  const update = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const alternate = fiber.alternate;
  if (fiber.lanes <span class="hljs-comment">=== NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) {</span>
    const lastRenderedReducer = queue.lastRenderedReducer;
    const currentState = queue.lastRenderedState;
    const eagerState = lastRenderedReducer(currentState, action);
    update.hasEagerState = true;
    update.eagerState = eagerState;
    if (is(eagerState, currentState)) {
      return;
    }
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
  scheduleUpdateOnFiber(root, fiber, lane);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props) {
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  return children;
}
</code></pre>
<h3 id="t29440.8 ReactFiberFlags.js">40.8 ReactFiberFlags.js <a href="#t29440.8 ReactFiberFlags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberFlags.js</p>
<pre><code class="lang-diff">export const NoFlags = 0b00000000000000000000000000;
export const Placement = 0b00000000000000000000000010;
export const Update = 0b00000000000000000000000100;
export const ChildDeletion = 0b00000000000000000000001000;
export const Passive = 0b00000000000000010000000000;
export const LayoutMask = Update;
<span class="hljs-addition">+export const Ref = 0b00000000000000000100000000;</span>
<span class="hljs-addition">+export const MutationMask = Placement | Update | Ref;</span>
</code></pre>
<h3 id="t29540.9 ReactFiberCompleteWork.js">40.9 ReactFiberCompleteWork.js <a href="#t29540.9 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
  prepareUpdate,
} from "react-dom-bindings/src/client/ReactDOMHostConfig";
import { HostComponent, HostRoot, HostText, FunctionComponent } from "./ReactWorkTags";
<span class="hljs-addition">+import { Ref, NoFlags, Update } from "./ReactFiberFlags";</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function markRef(workInProgress) {</span>
<span class="hljs-addition">+  workInProgress.flags |= Ref;</span>
<span class="hljs-addition">+}</span>

function bubbleProperties(completedWork) {
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // 我们只有创建的顶级fiber，但需要递归其子节点来查找所有终端节点
  let node = workInProgress.child;
  while (node !== null) {
    // 如果是原生节点，直接添加到父节点上
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // 再看看第一个节节点是不是原生节点
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // 如果没有弟弟就找父亲的弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // 如果找到了根节点或者回到了原节点结束
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // 下一个弟弟节点
    node = node.sibling;
  }
}
function markUpdate(workInProgress) {
  workInProgress.flags |= Update;
}
function updateHostComponent(current, workInProgress, type, newProps) {
  const oldProps = current.memoizedProps;
  const instance = workInProgress.stateNode;
  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);
  workInProgress.updateQueue = updatePayload;
  if (updatePayload) {
    markUpdate(workInProgress);
  }
}
export function completeWork(current, workInProgress) {
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
      if (current !== null &amp;&amp; workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress, type, newProps);
<span class="hljs-addition">+       if (current.ref !== workInProgress.ref) {</span>
<span class="hljs-addition">+         markRef(workInProgress);</span>
<span class="hljs-addition">+       }</span>
      } else {
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
<span class="hljs-addition">+       if (workInProgress.ref !== null) {</span>
<span class="hljs-addition">+         markRef(workInProgress);</span>
<span class="hljs-addition">+       }</span>
      }
      bubbleProperties(workInProgress);
      return null;
      break;
    }
    case FunctionComponent:
      bubbleProperties(workInProgress);
      break;
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
    default:
      break;
  }
}
</code></pre>
<h3 id="t29640.10 ReactFiberCommitWork.js">40.10 ReactFiberCommitWork.js <a href="#t29640.10 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, FunctionComponent } from "./ReactWorkTags";
<span class="hljs-addition">+import { Passive, MutationMask, Placement, Update, LayoutMask, Ref } from "./ReactFiberFlags";</span>
import { insertBefore, appendChild, commitUpdate, removeChild } from "react-dom-bindings/src/client/ReactDOMHostConfig";
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from "./ReactHookEffectTags";

export function commitMutationEffects(finishedWork, root) {
  commitMutationEffectsOnFiber(finishedWork, root);
}
export function commitPassiveUnmountEffects(finishedWork) {
  commitPassiveUnmountOnFiber(finishedWork);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      if (finishedWork.flags &amp; Passive) {
        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive | HookHasEffect);
      }
      break;
    }
    default: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    }
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveUnmountOnFiber(child);
      child = child.sibling;
    }
  }
}
function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
  commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
}

function commitHookEffectListUnmount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const destroy = effect.destroy;
        effect.destroy = undefined;
        if (destroy !== undefined) {
          destroy();
        }
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

export function commitPassiveMountEffects(root, finishedWork) {
  commitPassiveMountOnFiber(root, finishedWork);
}
function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      if (flags &amp; Passive) {
        commitHookPassiveMountEffects(finishedWork, HookPassive | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function commitHookPassiveMountEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}
function commitHookEffectListMount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const create = effect.create;
        effect.destroy = create();
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
function recursivelyTraversePassiveMountEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveMountOnFiber(root, child);
      child = child.sibling;
    }
  }
}
let hostParent = null;
function commitDeletionEffects(root, returnFiber, deletedFiber) {
  let parent = returnFiber;
  findParent: while (parent !== null) {
    switch (parent.tag) {
      case HostComponent: {
        hostParent = parent.stateNode;
        break findParent;
      }
      case HostRoot: {
        hostParent = parent.stateNode.containerInfo;
        break findParent;
      }
      default:
        break;
    }
    parent = parent.return;
  }
  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
  hostParent = null;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  switch (deletedFiber.tag) {
    case HostComponent:
    case HostText: {
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      if (hostParent !== null) {
        removeChild(hostParent, deletedFiber.stateNode);
      }
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  let child = parent.child;
  while (child !== null) {
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
    child = child.sibling;
  }
}
function recursivelyTraverseMutationEffects(root, parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i &lt; deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // 如果我们没有找到任何东西，让我们试试下一个弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // 如果我们是根Fiber或者父亲是原生节点，我们就是最后的弟弟
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // 如果它不是原生节点，并且，我们可能在其中有一个原生节点
      // 试着向下搜索，直到找到为止
      if (node.flags &amp; Placement) {
        // 如果我们没有孩子，可以试试弟弟
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // 检查此原生节点是否稳定可以放置
    if (!(node.flags &amp; Placement)) {
      // 找到它了!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);
      }
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
<span class="hljs-addition">+     if (flags &amp; Ref) {</span>
<span class="hljs-addition">+       commitAttachRef(finishedWork);</span>
<span class="hljs-addition">+     }</span>
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }

      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    default: {
      break;
    }
  }
}
<span class="hljs-addition">+function commitAttachRef(finishedWork) {</span>
<span class="hljs-addition">+  const ref = finishedWork.ref;</span>
<span class="hljs-addition">+  if (ref !== null) {</span>
<span class="hljs-addition">+    const instance = finishedWork.stateNode;</span>
<span class="hljs-addition">+    if (typeof ref === "function") {</span>
<span class="hljs-addition">+      ref(instance)</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      ref.current = instance;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
export function commitLayoutEffects(finishedWork, root) {
  const current = finishedWork.alternate;
  commitLayoutEffectOnFiber(root, current, finishedWork);
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags &amp; Update) {
        commitHookLayoutEffects(finishedWork, HookLayout | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; LayoutMask) {
    let child = parentFiber.child;
    while (child !== null) {
      const current = child.alternate;
      commitLayoutEffectOnFiber(root, current, child);
      child = child.sibling;
    }
  }
}
function commitHookLayoutEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}
</code></pre>
<h3 id="t29740.11  ReactFiber.js">40.11  ReactFiber.js <a href="#t29740.11  ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">import { HostRoot, IndeterminateComponent, HostComponent, HostText } from "./ReactWorkTags";
import { NoFlags } from "./ReactFiberFlags";
export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.alternate = null;

  this.index = 0;
<span class="hljs-addition">+ this.ref = null;</span>
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
//我们使用双缓冲池技术，因为我们知道一棵树最多只需要两个版本
//我们将“其他”未使用的我们可以自由重用的节点
//这是延迟创建的，以避免分配从未更新的内容的额外对象。它还允许我们如果需要，回收额外的内存
export function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  if (workInProgress <span class="hljs-comment">=== null) {</span>
    workInProgress = createFiber(current.tag, pendingProps, current.key);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
  }
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
<span class="hljs-addition">+ workInProgress.ref = current.ref;</span>
  return workInProgress;
}
export function createFiberFromTypeAndProps(type, key, pendingProps) {
  let fiberTag = IndeterminateComponent;
  if (typeof type <span class="hljs-comment">=== "string") {</span>
    fiberTag = HostComponent;
  }
  const fiber = createFiber(fiberTag, pendingProps, key);
  fiber.type = type;
  return fiber;
}
export function createFiberFromElement(element) {
  const { type } = element;
  const { key } = element;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(type, key, pendingProps);
  return fiber;
}

export function createFiberFromText(content) {
  const fiber = createFiber(HostText, content, null);
  return fiber;
}
</code></pre>
<h3 id="t29840.12 ReactChildFiber.js">40.12 ReactChildFiber.js <a href="#t29840.12 ReactChildFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactChildFiber.js</p>
<pre><code class="lang-diff">import { REACT_ELEMENT_TYPE } from "shared/ReactSymbols";
import isArray from "shared/isArray";
import { createFiberFromElement, FiberNode, createFiberFromText, createWorkInProgress } from "./ReactFiber";
import { Placement, ChildDeletion } from "./ReactFiberFlags";
import { HostText } from "./ReactWorkTags";
function createChildReconciler(shouldTrackSideEffects) {
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      return;
    }
    const deletions = returnFiber.deletions;
    if (deletions <span class="hljs-comment">=== null) {</span>
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion;
    } else {
      deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      return null;
    }
    let childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key <span class="hljs-comment">=== key) {</span>
        const elementType = element.type;
        if (child.type <span class="hljs-comment">=== elementType) {</span>
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
<span class="hljs-addition">+         existing.ref = element.ref;</span>
          existing.return = returnFiber;
          return existing;
        }
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    const created = createFiberFromElement(element);
<span class="hljs-addition">+   created.ref = element.ref;</span>
    created.return = returnFiber;
    return created;
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
      newFiber.flags |= Placement;
    }
    return newFiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const created = new FiberNode(HostText, { content }, null);
    created.return = returnFiber;
    return created;
  }
  function createChild(returnFiber, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== "string" &amp;&amp; newChild !== "") || typeof newChild === "number") {</span>
      const created = createFiberFromText(`${newChild}`);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(newChild);
<span class="hljs-addition">+         created.ref = newChild.ref;</span>
          created.return = returnFiber;
          return created;
        }
        default:
          break;
      }
    }
    return null;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      return lastPlacedIndex;
    }
    const current = newFiber.alternate;
    if (current !== null) {
      const oldIndex = current.index;
      if (oldIndex &lt; lastPlacedIndex) {
        newFiber.flags |= Placement;
        return lastPlacedIndex;
      } else {
        return oldIndex;
      }
    } else {
      newFiber.flags |= Placement;
      return lastPlacedIndex;
    }
  }
  function updateElement(returnFiber, current, element) {
    const elementType = element.type;
    if (current !== null) {
      if (current.type <span class="hljs-comment">=== elementType) {</span>
        const existing = useFiber(current, element.props);
<span class="hljs-addition">+       existing.ref = element.ref;</span>
        existing.return = returnFiber;
        return existing;
      }
    }
    const created = createFiberFromElement(element);
<span class="hljs-addition">+   created.ref = element.ref;</span>
    created.return = returnFiber;
    return created;
  }
  function updateSlot(returnFiber, oldFiber, newChild) {
    const key = oldFiber !== null ? oldFiber.key : null;
    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          if (newChild.key <span class="hljs-comment">=== key) {</span>
            return updateElement(returnFiber, oldFiber, newChild);
          } else {
            return null;
          }
        }
        default:
          return null;
      }
    }
  }
  function mapRemainingChildren(returnFiber, currentFirstChild) {
    const existingChildren = new Map();
    let existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }
  function updateTextNode(returnFiber, current, textContent) {
    if (current <span class="hljs-comment">=== null || current.tag !== HostText) {</span>
      const created = createFiberFromText(textContent, returnFiber.mode);
      created.return = returnFiber;
      return created;
    } else {
      const existing = useFiber(current, textContent);
      existing.return = returnFiber;
      return existing;
    }
  }
  function updateFromMap(existingChildren, returnFiber, newIdx, newChild) {
    if ((typeof newChild <span class="hljs-comment">=== "string" &amp;&amp; newChild !== "") || typeof newChild === "number") {</span>
      const matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, "" + newChild);
    }
    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const matchedFiber = existingChildren.get(newChild.key <span class="hljs-comment">=== null ? newIdx : newChild.key) || null;</span>
          return updateElement(returnFiber, matchedFiber, newChild);
        }
      }
    }
    return null;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let newIdx = 0;
    let oldFiber = currentFirstChild;
    let nextOldFiber = null;
    let lastPlacedIndex = 0;
    for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) {
      nextOldFiber = oldFiber.sibling;
      const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx]);
      if (newFiber <span class="hljs-comment">=== null) {</span>
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber &amp;&amp; newFiber.alternate <span class="hljs-comment">=== null) {</span>
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber <span class="hljs-comment">=== null) {</span>
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx <span class="hljs-comment">=== newChildren.length) {</span>
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }
    if (oldFiber <span class="hljs-comment">=== null) {</span>
      for (; newIdx &lt; newChildren.length; newIdx++) {
        const newFiber = createChild(returnFiber, newChildren[newIdx]);
        if (newFiber <span class="hljs-comment">=== null) {</span>
          continue;
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber <span class="hljs-comment">=== null) {</span>
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }
    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
    for (; newIdx &lt; newChildren.length; newIdx++) {
      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx]);
      if (newFiber !== null) {
        if (shouldTrackSideEffects) {
          if (newFiber.alternate !== null) {
            existingChildren.delete(newFiber.key <span class="hljs-comment">=== null ? newIdx : newFiber.key);</span>
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber <span class="hljs-comment">=== null) {</span>
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }
    if (shouldTrackSideEffects) {
      existingChildren.forEach((child) =&gt; deleteChild(returnFiber, child));
    }
    return resultingFirstChild;
  }
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild <span class="hljs-comment">=== "object" &amp;&amp; newChild !== null) {</span>
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
        }
        default:
          break;
      }
      if (isArray(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
      }
    }
    if (typeof newChild <span class="hljs-comment">=== "string") {</span>
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild));
    }
    return null;
  }
  return reconcileChildFibers;
}
export const reconcileChildFibers = createChildReconciler(true);
export const mountChildFibers = createChildReconciler(false);
</code></pre>
<h2 id="t29941.饥饿问题">41.饥饿问题 <a href="#t29941.饥饿问题"> # </a></h2>
<h3 id="t30041.1 src\main.jsx">41.1 src\main.jsx <a href="#t30041.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

<span class="hljs-addition">+let counter = 0;</span>
<span class="hljs-addition">+let timer;</span>
<span class="hljs-addition">+let bCounter = 0;</span>
<span class="hljs-addition">+let cCounter = 0;</span>
<span class="hljs-addition">+function FunctionComponent() {</span>
<span class="hljs-addition">+  const [numbers, setNumbers] = React.useState(new Array(100).fill('A'));</span>
<span class="hljs-addition">+  const divRef = React.useRef();</span>
<span class="hljs-addition">+  const updateB = (numbers) =&gt; new Array(100).fill(numbers[0] + 'B')</span>
<span class="hljs-addition">+  updateB.id = 'updateB' + (bCounter++);</span>
<span class="hljs-addition">+  const updateC = (numbers) =&gt; new Array(100).fill(numbers[0] + 'C')</span>
<span class="hljs-addition">+  updateC.id = 'updateC' + (cCounter++);</span>
<span class="hljs-addition">+  React.useEffect(() =&gt; {</span>
<span class="hljs-addition">+    timer = setInterval(() =&gt; {</span>
<span class="hljs-addition">+      console.log(divRef);</span>
<span class="hljs-addition">+      divRef.current.click();</span>
<span class="hljs-addition">+      if (counter++ === 0) {</span>
<span class="hljs-addition">+        setNumbers(updateB)</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      divRef.current.click();</span>
<span class="hljs-addition">+      if (counter++ &gt; 10) {</span>
<span class="hljs-addition">+        clearInterval(timer);</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+    });</span>
<span class="hljs-addition">+  }, []);</span>
<span class="hljs-addition">+  return (&lt;div ref={divRef} onClick={() =&gt; setNumbers(updateC)}&gt;</span>
<span class="hljs-addition">+    {numbers.map((number, index) =&gt; &lt;span key={index}&gt;{number}&lt;/span&gt;)}&lt;/ div&gt;)</span>
<span class="hljs-addition">+}</span>

const element = &lt;FunctionComponent /&gt;;
const container = document.getElementById("root");
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t30141.2 Scheduler.js">41.2 Scheduler.js <a href="#t30141.2 Scheduler.js"> # </a></h3>
<p>src\scheduler\src\forks\Scheduler.js</p>
<pre><code class="lang-diff">import {
  ImmediatePriority,
  UserBlockingPriority,
  NormalPriority,
  LowPriority,
  IdlePriority,
} from "../SchedulerPriorities";
import { push, pop, peek } from "../SchedulerMinHeap";
import { frameYieldMs } from "../SchedulerFeatureFlags";

const maxSigned31BitInt = 1073741823;
const IMMEDIATE_PRIORITY_TIMEOUT = -1;
const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
const NORMAL_PRIORITY_TIMEOUT = 5000;
const LOW_PRIORITY_TIMEOUT = 10000;
const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;

const taskQueue = [];
let taskIdCounter = 1;
let scheduledHostCallback = null;
let startTime = -1;
let currentTask = null;
const frameInterval = frameYieldMs;
const channel = new MessageChannel();
const port = channel.port2;

const getCurrentTime = () =&gt; performance.now();
channel.port1.onmessage = performWorkUntilDeadline;

function schedulePerformWorkUntilDeadline() {
  port.postMessage(null);
}
function performWorkUntilDeadline() {
  if (scheduledHostCallback !== null) {
    startTime = getCurrentTime();
    let hasMoreWork = true;
    try {
      hasMoreWork = scheduledHostCallback(startTime);
    } finally {
      if (hasMoreWork) {
        schedulePerformWorkUntilDeadline();
      } else {
        scheduledHostCallback = null;
      }
    }
  }
}
function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  schedulePerformWorkUntilDeadline();
}

function unstable_scheduleCallback(priorityLevel, callback) {
  const currentTime = getCurrentTime();
  const startTime = currentTime;
  let timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }
  const expirationTime = startTime + timeout;
  const newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sort<span class="hljs-comment">Index: -1,</span>
  };
  newTask.sortIndex = expirationTime;
  push(taskQueue, newTask);
  requestHostCallback(flushWork);
  return newTask;
}

function flushWork(initialTime) {
  return workLoop(initialTime);
}

function shouldYieldToHost() {
  const timeElapsed = getCurrentTime() - startTime;
  if (timeElapsed &lt; frameInterval) {
    return false;
  }
  return true;
}
function workLoop(initialTime) {
  let currentTime = initialTime;
  currentTask = peek(taskQueue);
  while (currentTask !== null) {
    if (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) {
      break;
    }
    const callback = currentTask.callback;
    if (typeof callback <span class="hljs-comment">=== "function") {</span>
      currentTask.callback = null;
      const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      if (typeof continuationCallback <span class="hljs-comment">=== "function") {</span>
        currentTask.callback = continuationCallback;
        return true;
      }
      if (currentTask <span class="hljs-comment">=== peek(taskQueue)) {</span>
        pop(taskQueue);
      }
    } else {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
  }
  if (currentTask !== null) {
    return true;
  }
  return false;
}

<span class="hljs-addition">+function unstable_cancelCallback(task) {</span>
<span class="hljs-addition">+  task.callback = null;</span>
<span class="hljs-addition">+}</span>

export {
  NormalPriority as unstable_NormalPriority,
  unstable_scheduleCallback,
  shouldYieldToHost as unstable_shouldYield,
<span class="hljs-addition">+ unstable_cancelCallback,</span>
<span class="hljs-addition">+ getCurrentTime as unstable_now</span>
};

</code></pre>
<h3 id="t30241.3 Scheduler.js">41.3 Scheduler.js <a href="#t30241.3 Scheduler.js"> # </a></h3>
<p>src\react-reconciler\src\Scheduler.js</p>
<pre><code class="lang-diff">import * as Scheduler from 'scheduler'
export const scheduleCallback = Scheduler.unstable_scheduleCallback
export const NormalPriority = Scheduler.unstable_NormalPriority
export const ImmediatePriority = Scheduler.unstable_ImmediatePriority;
export const UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
export const LowPriority = Scheduler.unstable_LowPriority;
export const IdlePriority = Scheduler.unstable_IdlePriority;
export const shouldYield = Scheduler.unstable_shouldYield
<span class="hljs-addition">+export const cancelCallback = Scheduler.unstable_cancelCallback</span>
<span class="hljs-addition">+export const now = Scheduler.unstable_now;</span>
</code></pre>
<h3 id="t30341.4 ReactFiberWorkLoop.js">41.4 ReactFiberWorkLoop.js <a href="#t30341.4 ReactFiberWorkLoop.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberWorkLoop.js</p>
<pre><code class="lang-diff">import {
  scheduleCallback as Scheduler_scheduleCallback,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  IdlePriority as IdleSchedulerPriority,
  shouldYield,
<span class="hljs-addition">+ cancelCallback as Scheduler_cancelCallback,</span>
<span class="hljs-addition">+ now</span>
} from "./Scheduler";
import { createWorkInProgress } from "./ReactFiber";
import { beginWork } from "./ReactFiberBeginWork";
import { completeWork } from "./ReactFiberCompleteWork";
import { MutationMask, NoFlags, Passive } from "./ReactFiberFlags";
import {
  commitMutationEffects,
  commitPassiveUnmountEffects,
  commitPassiveMountEffects,
  commitLayoutEffects,
} from "./ReactFiberCommitWork";
import { finishQueueingConcurrentUpdates } from "./ReactFiberConcurrentUpdates";
import {
  NoLane, markRootUpdated, NoLanes,
  getNextLanes, getHighestPriorityLane, SyncLane,
<span class="hljs-addition">+ includesBlockingLane, markStarvedLanesAsExpired, includesExpiredLane,</span>
<span class="hljs-addition">+ mergeLanes, markRootFinished, NoTimestamp</span>
} from './ReactFiberLane';
import {
  getCurrentUpdatePriority, lanesToEventPriority, DiscreteEventPriority, ContinuousEventPriority,
  DefaultEventPriority, IdleEventPriority, setCurrentUpdatePriority
} from './ReactEventPriorities';
import { getCurrentEventPriority } from 'react-dom-bindings/src/client/ReactDOMHostConfig';
import { scheduleSyncCallback, flushSyncCallbacks } from './ReactFiberSyncTaskQueue';

let workInProgress = null;
let rootDoesHavePassiveEffects = false;
let rootWithPendingPassiveEffects = null;
let workInProgressRootRenderLanes = NoLanes;

const RootInProgress = 0;
const RootCompleted = 5;
let workInProgressRoot = null;
let workInProgressRootExitStatus = RootInProgress;
<span class="hljs-addition">+let currentEventTime = NoTimestamp;</span>

<span class="hljs-addition">+function cancelCallback(callbackNode) {</span>
<span class="hljs-addition">+  console.log('cancelCallback');</span>
<span class="hljs-addition">+  return Scheduler_cancelCallback(callbackNode);</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+export function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {</span>
  markRootUpdated(root, lane);
<span class="hljs-addition">+ ensureRootIsScheduled(root, eventTime);</span>
}
<span class="hljs-addition">+function ensureRootIsScheduled(root, currentTime) {</span>
  const existingCallbackNode = root.callbackNode;
<span class="hljs-addition">+ markStarvedLanesAsExpired(root, currentTime);</span>
  const nextLanes = getNextLanes(root, root <span class="hljs-comment">=== workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);</span>
  if (nextLanes <span class="hljs-comment">=== NoLanes) {</span>
    root.callbackNode = null;
    root.callbackPriority = NoLane;
    return;
  }
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
  const existingCallbackPriority = root.callbackPriority;
  if (existingCallbackPriority <span class="hljs-comment">=== newCallbackPriority) {</span>
    return;
  }
  if (existingCallbackNode != null) {
    cancelCallback(existingCallbackNode);
  }
  let newCallbackNode;
  if (newCallbackPriority <span class="hljs-comment">=== SyncLane) {</span>
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
    queueMicrotask(flushSyncCallbacks);
    newCallbackNode = null;
  } else {
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
    newCallbackNode = Scheduler_scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))
  }
  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}
function performSyncWorkOnRoot(root) {
  const lanes = getNextLanes(root, NoLanes);
  renderRootSync(root, lanes);
  const finishedWork = root.current.alternate
  root.finishedWork = finishedWork
  commitRoot(root)
  return null;
}
function performConcurrentWorkOnRoot(root, didTimeout) {
  const originalCallbackNode = root.callbackNode;
  const lanes = getNextLanes(root, NoLanes);
  if (lanes <span class="hljs-comment">=== NoLanes) {</span>
    return null;
  }
<span class="hljs-addition">+ const nonIncludesBlockingLane = !includesBlockingLane(root, lanes);</span>
<span class="hljs-addition">+ const nonIncludesExpiredLane = !includesExpiredLane(root, lanes);</span>
<span class="hljs-addition">+ const nonTimeout = !didTimeout;</span>
<span class="hljs-addition">+ const shouldTimeSlice = nonIncludesBlockingLane &amp;&amp; nonIncludesExpiredLane &amp;&amp; nonTimeout;</span>
  const exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
  if (exitStatus !== RootInProgress) {
    const finishedWork = root.current.alternate
    root.finishedWork = finishedWork
    commitRoot(root)
  }
  if (root.callbackNode <span class="hljs-comment">=== originalCallbackNode) {</span>
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}
function renderRootConcurrent(root, lanes) {
 if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
  }
  workLoopConcurrent();
  if (workInProgress !== null) {
    return RootInProgress;
  }
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}
function workLoopConcurrent() {
  while (workInProgress !== null &amp;&amp; !shouldYield()) {
<span class="hljs-addition">+   sleep(5)</span>
    performUnitOfWork(workInProgress);
  }
}
export function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    commitPassiveUnmountEffects(root.current);
    commitPassiveMountEffects(root, root.current);
  }
}
function commitRoot(root) {
  const previousPriority = getCurrentUpdatePriority();
  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    commitRootImpl(root);
  } finally {
    setCurrentUpdatePriority(previousPriority);
  }
}
function commitRootImpl(root) {
  const { finishedWork } = root;
<span class="hljs-addition">+ console.log('commit', finishedWork.child.memoizedState.memoizedState[0]);</span>
  root.callbackNode = null;
  root.callbackPriority = NoLane;
<span class="hljs-addition">+ const remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);</span>
<span class="hljs-addition">+ markRootFinished(root, remainingLanes);</span>
  if ((finishedWork.subtreeFlags &amp; Passive) !== NoFlags || (finishedWork.flags &amp; Passive) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      Scheduler_scheduleCallback(NormalSchedulerPriority, flushPassiveEffects);
    }
  }
  const subtreeHasEffects = (finishedWork.subtreeFlags &amp; MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags &amp; MutationMask) !== NoFlags;
  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(finishedWork, root);
    commitLayoutEffects(finishedWork, root);
    root.current = finishedWork;
    if (rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = false;
      rootWithPendingPassiveEffects = root;
    }
  }
  root.current = finishedWork;
<span class="hljs-addition">+ ensureRootIsScheduled(root, now());</span>
}
function prepareFreshStack(root, lanes) {
  workInProgressRoot = root;
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
}
function renderRootSync(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes)
  }
  workLoopSync();
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  const next = beginWork(current, unitOfWork, workInProgressRootRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next <span class="hljs-comment">=== null) {</span>
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    completeWork(current, completedWork);
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
  if (workInProgressRootExitStatus <span class="hljs-comment">=== RootInProgress) {</span>
    workInProgressRootExitStatus = RootCompleted;
  }
}

export function requestUpdateLane() {
  const updateLane = getCurrentUpdatePriority();
  if (updateLane !== NoLane) {
    return updateLane;
  }
  const eventLane = getCurrentEventPriority();
  return eventLane;
}

<span class="hljs-addition">+export function requestEventTime() {</span>
<span class="hljs-addition">+  currentEventTime = now();</span>
<span class="hljs-addition">+  return currentEventTime;</span>
<span class="hljs-addition">+}</span>

<span class="hljs-addition">+function sleep(time) {</span>
<span class="hljs-addition">+  const timeStamp = new Date().getTime();</span>
<span class="hljs-addition">+  const endTime = timeStamp + time;</span>
<span class="hljs-addition">+  while (true) {</span>
<span class="hljs-addition">+    if (new Date().getTime() &gt; endTime) {</span>
<span class="hljs-addition">+      return;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t30441.5 ReactFiberLane.js">41.5 ReactFiberLane.js <a href="#t30441.5 ReactFiberLane.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberLane.js</p>
<pre><code class="lang-diff">import { allowConcurrentByDefault } from 'shared/ReactFeatureFlags';

<span class="hljs-addition">+export const NoTimestamp = -1;</span>

export const TotalLanes = 31;
export const NoLanes = 0b0000000000000000000000000000000;
export const NoLane = 0b0000000000000000000000000000000;
export const SyncLane = 0b0000000000000000000000000000001;// 1
export const InputContinuousLane = 0b0000000000000000000000000000100;// 4
export const DefaultLane = 0b0000000000000000000000000010000;// 16
export const NonIdleLanes = 0b0001111111111111111111111111111;
export const IdleLane = 0b0100000000000000000000000000000;

export function mergeLanes(a, b) {
  return a | b;
}
export function markRootUpdated(root, updateLane) {
  root.pendingLanes |= updateLane;
}

export function getNextLanes(root, wipLanes) {
  const pendingLanes = root.pendingLanes;
  if (pendingLanes <span class="hljs-comment">=== NoLanes) {</span>
    return NoLanes;
  }
  const nextLanes = getHighestPriorityLanes(pendingLanes);
  if (wipLanes !== NoLanes &amp;&amp; wipLanes !== nextLanes) {
    if (nextLanes &gt;= wipLanes) {
      return wipLanes;
    }
  }
  return nextLanes;
}

function getHighestPriorityLanes(lanes) {
  return getHighestPriorityLane(lanes);
}

export function getHighestPriorityLane(lanes) {
  return lanes &amp; -lanes;
}

export function includesNonIdleWork(lanes) {
  return (lanes &amp; NonIdleLanes) !== NoLanes;
}
export function includesBlockingLane(root, lanes) {
  if (allowConcurrentByDefault) {
    return false;
  }
  const SyncDefaultLanes = InputContinuousLane | DefaultLane;
  return (lanes &amp; SyncDefaultLanes) !== NoLanes;
}
export function isSubsetOfLanes(set, subset) {
  return (set &amp; subset) <span class="hljs-comment">=== subset;</span>
}


<span class="hljs-addition">+function pickArbitraryLaneIndex(lanes) {</span>
<span class="hljs-addition">+  return 31 - Math.clz32(lanes);</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+export function markStarvedLanesAsExpired(root, currentTime) {</span>
<span class="hljs-addition">+  const pendingLanes = root.pendingLanes;</span>
<span class="hljs-addition">+  const expirationTimes = root.expirationTimes;</span>
<span class="hljs-addition">+  let lanes = pendingLanes</span>
<span class="hljs-addition">+  while (lanes &gt; 0) {</span>
<span class="hljs-addition">+    const index = pickArbitraryLaneIndex(lanes);</span>
<span class="hljs-addition">+    const lane = 1 &lt;&lt; index;</span>
<span class="hljs-addition">+    const expirationTime = expirationTimes[index];</span>
<span class="hljs-addition">+    if (expirationTime === NoTimestamp) {</span>
<span class="hljs-addition">+      expirationTimes[index] = computeExpirationTime(lane, currentTime);</span>
<span class="hljs-addition">+    } else if (expirationTime &lt;= currentTime) {</span>
<span class="hljs-addition">+      root.expiredLanes |= lane;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    lanes &amp;= ~lane;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function computeExpirationTime(lane, currentTime) {</span>
<span class="hljs-addition">+  switch (lane) {</span>
<span class="hljs-addition">+    case SyncLane:</span>
<span class="hljs-addition">+    case InputContinuousLane:</span>
<span class="hljs-addition">+      return currentTime + 250;</span>
<span class="hljs-addition">+    case DefaultLane:</span>
<span class="hljs-addition">+      return currentTime + 5000;</span>
<span class="hljs-addition">+    case IdleLane:</span>
<span class="hljs-addition">+      return NoTimestamp;</span>
<span class="hljs-addition">+    default:</span>
<span class="hljs-addition">+      return NoTimestamp;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function createLaneMap(initial) {</span>
<span class="hljs-addition">+  const laneMap = [];</span>
<span class="hljs-addition">+  for (let i = 0; i &lt; TotalLanes; i++) {</span>
<span class="hljs-addition">+    laneMap.push(initial);</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  return laneMap;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function includesExpiredLane(root, lanes) {</span>
<span class="hljs-addition">+  return (lanes &amp; root.expiredLanes) !== NoLanes;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+export function markRootFinished(root, remainingLanes) {</span>
<span class="hljs-addition">+  const noLongerPendingLanes = root.pendingLanes &amp; ~remainingLanes;</span>
<span class="hljs-addition">+  root.pendingLanes = remainingLanes;</span>
<span class="hljs-addition">+  let lanes = noLongerPendingLanes;</span>
<span class="hljs-addition">+  const expirationTimes = root.expirationTimes;</span>
<span class="hljs-addition">+  while (lanes &gt; 0) {</span>
<span class="hljs-addition">+    const index = pickArbitraryLaneIndex(lanes);</span>
<span class="hljs-addition">+    const lane = 1 &lt;&lt; index;</span>
<span class="hljs-addition">+    expirationTimes[index] = NoTimestamp;</span>
<span class="hljs-addition">+    lanes &amp;= ~lane;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t30541.6 ReactFiber.js">41.6 ReactFiber.js <a href="#t30541.6 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff">import { HostRoot, IndeterminateComponent, HostComponent, HostText } from "./ReactWorkTags";
import { NoFlags } from "./ReactFiberFlags";
<span class="hljs-addition">+import { NoLanes } from './ReactFiberLane';</span>

export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.alternate = null;

  this.index = 0;
  this.ref = null;
<span class="hljs-addition">+ this.lanes = NoLanes;</span>
<span class="hljs-addition">+ this.childLanes = NoLanes;</span>
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
//我们使用双缓冲池技术，因为我们知道一棵树最多只需要两个版本
//我们将“其他”未使用的我们可以自由重用的节点
//这是延迟创建的，以避免分配从未更新的内容的额外对象。它还允许我们如果需要，回收额外的内存
export function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  if (workInProgress <span class="hljs-comment">=== null) {</span>
    workInProgress = createFiber(current.tag, pendingProps, current.key);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
<span class="hljs-addition">+   workInProgress.deletions = null;</span>
  }
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
<span class="hljs-addition">+ workInProgress.flags = current.flags;</span>
<span class="hljs-addition">+ workInProgress.childLanes = current.childLanes;</span>
<span class="hljs-addition">+ workInProgress.lanes = current.lanes;</span>
  return workInProgress;
}
export function createFiberFromTypeAndProps(type, key, pendingProps) {
  let fiberTag = IndeterminateComponent;
  if (typeof type <span class="hljs-comment">=== "string") {</span>
    fiberTag = HostComponent;
  }
  const fiber = createFiber(fiberTag, pendingProps, key);
  fiber.type = type;
  return fiber;
}
export function createFiberFromElement(element) {
  const { type } = element;
  const { key } = element;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(type, key, pendingProps);
  return fiber;
}

export function createFiberFromText(content) {
  const fiber = createFiber(HostText, content, null);
  return fiber;
}
</code></pre>
<h3 id="t30641.7 ReactFiberBeginWork.js">41.7 ReactFiberBeginWork.js <a href="#t30641.7 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import { HostRoot, HostComponent, HostText, IndeterminateComponent, FunctionComponent } from "./ReactWorkTags";
import { processUpdateQueue, cloneUpdateQueue } from "./ReactFiberClassUpdateQueue";
import { mountChildFibers, reconcileChildFibers } from "./ReactChildFiber";
import { shouldSetTextContent } from "react-dom-bindings/src/client/ReactDOMHostConfig";
import { renderWithHooks } from "react-reconciler/src/ReactFiberHooks";
<span class="hljs-addition">+import { NoLanes } from './ReactFiberLane';</span>

function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
function updateHostRoot(current, workInProgress, renderLanes) {
  const nextProps = workInProgress.pendingProps;
  cloneUpdateQueue(current, workInProgress);
  processUpdateQueue(workInProgress, nextProps, renderLanes)
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function mountIndeterminateComponent(_current, workInProgress, Component) {
  const props = workInProgress.pendingProps;
  const value = renderWithHooks(null, workInProgress, Component, props);
  workInProgress.tag = FunctionComponent;
  reconcileChildren(null, workInProgress, value);
  return workInProgress.child;
}
<span class="hljs-addition">+function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {</span>
<span class="hljs-addition">+ const nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, renderLanes);</span>
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
export function beginWork(current, workInProgress, renderLanes) {
<span class="hljs-addition">+ workInProgress.lanes = NoLanes;</span>
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
    }
    case FunctionComponent: {
      const Component = workInProgress.type;
      const resolvedProps = workInProgress.pendingProps;
<span class="hljs-addition">+     return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);</span>
    }
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
    default:
      return null;
  }
}
</code></pre>
<h3 id="t30741.8 ReactFiberCompleteWork.js">41.8 ReactFiberCompleteWork.js <a href="#t30741.8 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
  prepareUpdate,
} from "react-dom-bindings/src/client/ReactDOMHostConfig";
import { HostComponent, HostRoot, HostText, FunctionComponent } from "./ReactWorkTags";
import { Ref, NoFlags, Update } from "./ReactFiberFlags";
<span class="hljs-addition">+import { NoLanes, mergeLanes } from './ReactFiberLane';</span>

function markRef(workInProgress) {
  workInProgress.flags |= Ref;
}

function bubbleProperties(completedWork) {
<span class="hljs-addition">+ let newChildLanes = NoLanes;</span>
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
<span class="hljs-addition">+   newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));</span>
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
<span class="hljs-addition">+ completedWork.childLanes = newChildLanes;</span>
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // 我们只有创建的顶级fiber，但需要递归其子节点来查找所有终端节点
  let node = workInProgress.child;
  while (node !== null) {
    // 如果是原生节点，直接添加到父节点上
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // 再看看第一个节节点是不是原生节点
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // 如果没有弟弟就找父亲的弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // 如果找到了根节点或者回到了原节点结束
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // 下一个弟弟节点
    node = node.sibling;
  }
}
function markUpdate(workInProgress) {
  workInProgress.flags |= Update;
}
function updateHostComponent(current, workInProgress, type, newProps) {
  const oldProps = current.memoizedProps;
  const instance = workInProgress.stateNode;
  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);
  workInProgress.updateQueue = updatePayload;
  if (updatePayload) {
    markUpdate(workInProgress);
  }
}
export function completeWork(current, workInProgress) {
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
      if (current !== null &amp;&amp; workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress, type, newProps);
        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      } else {
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
        if (workInProgress.ref !== null) {
          markRef(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    case FunctionComponent:
      bubbleProperties(workInProgress);
      break;
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
    default:
      break;
  }
}
</code></pre>
<h3 id="t30841.9 ReactFiberConcurrentUpdates.js">41.9 ReactFiberConcurrentUpdates.js <a href="#t30841.9 ReactFiberConcurrentUpdates.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberConcurrentUpdates.js</p>
<pre><code class="lang-diff">import { HostRoot } from "./ReactWorkTags";
<span class="hljs-addition">+import { mergeLanes, NoLanes } from './ReactFiberLane';</span>

const concurrentQueues = [];
let concurrentQueuesIndex = 0;

export function markUpdateLaneFromFiberToRoot(sourceFiber) {
  let node = sourceFiber;
  let parent = sourceFiber.return;
  while (parent !== null) {
    node = parent;
    parent = parent.return;
  }
  if (node.tag <span class="hljs-comment">=== HostRoot) {</span>
    const root = node.stateNode;
    return root;
  }
  return null;
}
export function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
export function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
  enqueueUpdate(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}

function enqueueUpdate(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
<span class="hljs-addition">+ fiber.lanes = mergeLanes(fiber.lanes, lane);</span>
}
function getRootForUpdatedFiber(sourceFiber) {
  let node = sourceFiber;
  let parent = node.return;
  while (parent !== null) {
    node = parent;
    parent = node.return;
  }
  return node.tag <span class="hljs-comment">=== HostRoot ? node.stateNode : null;</span>
}

export function finishQueueingConcurrentUpdates() {
  const endIndex = concurrentQueuesIndex;
  concurrentQueuesIndex = 0;
  let i = 0;
  while (i &lt; endIndex) {
    const fiber = concurrentQueues[i++];
    const queue = concurrentQueues[i++];
    const update = concurrentQueues[i++];
    const lane = concurrentQueues[i++]
    if (queue !== null &amp;&amp; update !== null) {
      const pending = queue.pending;
      if (pending <span class="hljs-comment">=== null) {</span>
        update.next = update;
      } else {
        update.next = pending.next;
        pending.next = update;
      }
      queue.pending = update;
    }
  }
}
</code></pre>
<h3 id="t30941.10 ReactFiberHooks.js">41.10 ReactFiberHooks.js <a href="#t30941.10 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from "shared/ReactSharedInternals";
import { enqueueConcurrentHookUpdate } from "./ReactFiberConcurrentUpdates";
<span class="hljs-addition">+import { scheduleUpdateOnFiber, requestUpdateLane, requestEventTime } from "./ReactFiberWorkLoop";</span>
import is from "shared/objectIs";
import { Passive as PassiveEffect, Update as UpdateEffect } from "./ReactFiberFlags";
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from "./ReactHookEffectTags";
<span class="hljs-addition">+import { NoLanes, NoLane, mergeLanes, isSubsetOfLanes } from './ReactFiberLane';</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;
<span class="hljs-addition">+let renderLanes = NoLanes;</span>

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
  useRef: mountRef,
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  useRef: updateRef
};
function mountRef(initialValue) {
  const hook = mountWorkInProgressHook();
  const ref = {
    current: initialValue,
  };
  hook.memoizedState = ref;
  return ref;
}
function updateRef() {
  const hook = updateWorkInProgressHook();
  return hook.memoizedState;
}
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== "function" ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
<span class="hljs-addition">+   lastRenderedReducer: reducer,</span>
<span class="hljs-addition">+   lastRenderedState: initialArg</span>
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
<span class="hljs-addition">+  const hook = updateWorkInProgressHook();</span>
<span class="hljs-addition">+  const queue = hook.queue;</span>
<span class="hljs-addition">+  queue.lastRenderedReducer = reducer;</span>
<span class="hljs-addition">+  const current = currentHook;</span>
<span class="hljs-addition">+  let baseQueue = current.baseQueue;</span>
<span class="hljs-addition">+  const pendingQueue = queue.pending;</span>
<span class="hljs-addition">+  if (pendingQueue !== null) {</span>
<span class="hljs-addition">+    if (baseQueue !== null) {</span>
<span class="hljs-addition">+      const baseFirst = baseQueue.next;</span>
<span class="hljs-addition">+      const pendingFirst = pendingQueue.next;</span>
<span class="hljs-addition">+      baseQueue.next = pendingFirst;</span>
<span class="hljs-addition">+      pendingQueue.next = baseFirst;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    current.baseQueue = baseQueue = pendingQueue;</span>
<span class="hljs-addition">+    queue.pending = null;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (baseQueue !== null) {</span>
<span class="hljs-addition">+    printQueue(baseQueue)</span>
<span class="hljs-addition">+    const first = baseQueue.next;</span>
<span class="hljs-addition">+    let newState = current.baseState;</span>
<span class="hljs-addition">+    let newBaseState = null;</span>
<span class="hljs-addition">+    let newBaseQueueFirst = null;</span>
<span class="hljs-addition">+    let newBaseQueueLast = null;</span>
<span class="hljs-addition">+    let update = first;</span>
<span class="hljs-addition">+    do {</span>
<span class="hljs-addition">+      const updateLane = update.lane;</span>
<span class="hljs-addition">+      const shouldSkipUpdate = !isSubsetOfLanes(renderLanes, updateLane);</span>
<span class="hljs-addition">+      if (shouldSkipUpdate) {</span>
<span class="hljs-addition">+        const clone = {</span>
<span class="hljs-addition">+          lane: updateLane,</span>
<span class="hljs-addition">+          action: update.action,</span>
<span class="hljs-addition">+          hasEagerState: update.hasEagerState,</span>
<span class="hljs-addition">+          eagerState: update.eagerState,</span>
<span class="hljs-addition">+          next: null,</span>
<span class="hljs-addition">+        };</span>
<span class="hljs-addition">+        if (newBaseQueueLast === null) {</span>
<span class="hljs-addition">+          newBaseQueueFirst = newBaseQueueLast = clone;</span>
<span class="hljs-addition">+          newBaseState = newState;</span>
<span class="hljs-addition">+        } else {</span>
<span class="hljs-addition">+          newBaseQueueLast = newBaseQueueLast.next = clone;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, updateLane);</span>
<span class="hljs-addition">+      } else {</span>
<span class="hljs-addition">+        if (newBaseQueueLast !== null) {</span>
<span class="hljs-addition">+          const clone = {</span>
<span class="hljs-addition">+            lane: NoLane,</span>
<span class="hljs-addition">+            action: update.action,</span>
<span class="hljs-addition">+            hasEagerState: update.hasEagerState,</span>
<span class="hljs-addition">+            eagerState: update.eagerState,</span>
<span class="hljs-addition">+            next: null,</span>
<span class="hljs-addition">+          };</span>
<span class="hljs-addition">+          newBaseQueueLast = newBaseQueueLast.next = clone;</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+        if (update.hasEagerState) {</span>
<span class="hljs-addition">+          newState = update.eagerState;</span>
<span class="hljs-addition">+        } else {</span>
<span class="hljs-addition">+          const action = update.action;</span>
<span class="hljs-addition">+          newState = reducer(newState, action);</span>
<span class="hljs-addition">+        }</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      update = update.next;</span>
<span class="hljs-addition">+    } while (update !== null &amp;&amp; update !== first);</span>
<span class="hljs-addition">+    if (newBaseQueueLast === null) {</span>
<span class="hljs-addition">+      newBaseState = newState;</span>
<span class="hljs-addition">+    } else {</span>
<span class="hljs-addition">+      newBaseQueueLast.next = newBaseQueueFirst;</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    hook.memoizedState = newState;</span>
<span class="hljs-addition">+    hook.baseState = newBaseState;</span>
<span class="hljs-addition">+    hook.baseQueue = newBaseQueueLast;</span>
<span class="hljs-addition">+    queue.lastRenderedState = newState;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  if (baseQueue === null) {</span>
<span class="hljs-addition">+    queue.lanes = NoLanes;</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+  const dispatch = queue.dispatch;</span>
<span class="hljs-addition">+  return [hook.memoizedState, dispatch];</span>
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const lane = requestUpdateLane(fiber);
  const update = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const alternate = fiber.alternate;
  if (fiber.lanes <span class="hljs-comment">=== NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) {</span>
    const lastRenderedReducer = queue.lastRenderedReducer;
    const currentState = queue.lastRenderedState;
    const eagerState = lastRenderedReducer(currentState, action);
    update.hasEagerState = true;
    update.eagerState = eagerState;
    if (is(eagerState, currentState)) {
      return;
    }
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
<span class="hljs-addition">+ const eventTime = requestEventTime();</span>
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
<span class="hljs-addition">+   baseState: null,</span>
<span class="hljs-addition">+   baseQueue: null,</span>
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
<span class="hljs-addition">+     baseState: currentHook.baseState,</span>
<span class="hljs-addition">+     baseQueue: currentHook.baseQueue,</span>
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props, nextRenderLanes) {
<span class="hljs-addition">+ renderLanes = nextRenderLanes;</span>
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
<span class="hljs-addition">+ workInProgress.memoizedState = null;</span>
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
<span class="hljs-addition">+ renderLanes = NoLanes;</span>
  return children;
}

<span class="hljs-addition">+function printQueue(queue) {</span>
<span class="hljs-addition">+  const first = queue.next;</span>
<span class="hljs-addition">+  let desc = '';</span>
<span class="hljs-addition">+  let update = first;</span>
<span class="hljs-addition">+  do {</span>
<span class="hljs-addition">+    desc += ("=&gt;" + (update.action.id));</span>
<span class="hljs-addition">+    update = update.next;</span>
<span class="hljs-addition">+  } while (update !== null &amp;&amp; update !== first);</span>
<span class="hljs-addition">+  desc += "=&gt;null";</span>
<span class="hljs-addition">+  console.log(desc);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t31041.11 ReactFiberReconciler.js">41.11 ReactFiberReconciler.js <a href="#t31041.11 ReactFiberReconciler.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberReconciler.js</p>
<pre><code class="lang-diff">import { createFiberRoot } from "./ReactFiberRoot";
import { createUpdate, enqueueUpdate } from "./ReactFiberClassUpdateQueue";
<span class="hljs-addition">+import { scheduleUpdateOnFiber, requestUpdateLane, requestEventTime } from "./ReactFiberWorkLoop";</span>
export function createContainer(containerInfo) {
  return createFiberRoot(containerInfo);
}
export function updateContainer(element, container) {
  const current = container.current;
<span class="hljs-addition">+ const eventTime = requestEventTime();</span>
  const lane = requestUpdateLane(current);
  const update = createUpdate(lane);
  update.payload = { element };
  const root = enqueueUpdate(current, update, lane);
<span class="hljs-addition">+ scheduleUpdateOnFiber(root, current, lane, eventTime);</span>
}
</code></pre>
<h3 id="t31141.12 ReactFiberRoot.js">41.12 ReactFiberRoot.js <a href="#t31141.12 ReactFiberRoot.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberRoot.js</p>
<pre><code class="lang-diff">import { createHostRootFiber } from "./ReactFiber";
import { initializeUpdateQueue } from "./ReactFiberClassUpdateQueue";
<span class="hljs-addition">+import { NoTimestamp, createLaneMap, NoLanes } from 'react-reconciler/src/ReactFiberLane';</span>

function FiberRootNode(containerInfo) {
  this.containerInfo = containerInfo;
<span class="hljs-addition">+ this.expirationTimes = createLaneMap(NoTimestamp);</span>
<span class="hljs-addition">+ this.expiredLanes = NoLanes;</span>
}

export function createFiberRoot(containerInfo) {
  const root = new FiberRootNode(containerInfo);
  const uninitializedFiber = createHostRootFiber();
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  initializeUpdateQueue(uninitializedFiber);
  return root;
}
</code></pre>
<h2 id="t31242.context">42.context <a href="#t31242.context"> # </a></h2>
<h3 id="t31342.1 src\main.jsx">42.1 src\main.jsx <a href="#t31342.1 src\main.jsx"> # </a></h3>
<p>src\main.jsx</p>
<pre><code class="lang-diff">import * as React from "react";
import { createRoot } from "react-dom/client";

<span class="hljs-addition">+const NameContext = React.createContext('');</span>
<span class="hljs-addition">+const AgeContext = React.createContext('');</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+function Child() {</span>
<span class="hljs-addition">+  const name = React.useContext(NameContext);</span>
<span class="hljs-addition">+  const age = React.useContext(AgeContext);</span>
<span class="hljs-addition">+  return &lt;button&gt;{name + age}&lt;/button&gt;</span>
<span class="hljs-addition">+}</span>
<span class="hljs-addition">+function App() {</span>
<span class="hljs-addition">+  const [name, setName] = React.useState('a');</span>
<span class="hljs-addition">+  const [age, setAge] = React.useState('1');</span>
<span class="hljs-addition">+  return (</span>
<span class="hljs-addition">+    &lt;div&gt;</span>
<span class="hljs-addition">+      &lt;button onClick={() =&gt; {</span>
<span class="hljs-addition">+        setName(name + 'a')</span>
<span class="hljs-addition">+      }}&gt;setName&lt;/button&gt;</span>
<span class="hljs-addition">+      &lt;button onClick={() =&gt; {</span>
<span class="hljs-addition">+        setAge(age + '1')</span>
<span class="hljs-addition">+      }}&gt;setAge&lt;/button&gt;</span>
<span class="hljs-addition">+      &lt;NameContext.Provider value={name}&gt;</span>
<span class="hljs-addition">+        &lt;AgeContext.Provider value={age}&gt;</span>
<span class="hljs-addition">+          &lt;Child /&gt;</span>
<span class="hljs-addition">+        &lt;/AgeContext.Provider&gt;</span>
<span class="hljs-addition">+      &lt;/NameContext.Provider&gt;</span>
<span class="hljs-addition">+    &lt;/div&gt;</span>
<span class="hljs-addition">+  )</span>
<span class="hljs-addition">+}</span>

const element = &lt;App /&gt;;
const container = document.getElementById("root");
const root = createRoot(container, { unstable_concurrentUpdatesByDefault: true });
root.render(element);
</code></pre>
<h3 id="t31442.2  react\index.js">42.2  react\index.js <a href="#t31442.2  react\index.js"> # </a></h3>
<p>src\react\index.js</p>
<pre><code class="lang-diff">export {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  useReducer,
  useState,
  useEffect,
  useLayoutEffect,
  useRef,
<span class="hljs-addition">+ createContext,</span>
<span class="hljs-addition">+ useContext,</span>
} from "./src/React";
</code></pre>
<h3 id="t31542.3 React.js">42.3 React.js <a href="#t31542.3 React.js"> # </a></h3>
<p>src\react\src\React.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { useReducer, useState, useEffect, useLayoutEffect, useRef, useContext } from "./ReactHooks";</span>
import ReactSharedInternals from "./ReactSharedInternals";
<span class="hljs-addition">+import { createContext } from './ReactContext';</span>

export {
  useReducer,
  useState,
  useEffect,
  useLayoutEffect,
  useRef,
<span class="hljs-addition">+ createContext,</span>
<span class="hljs-addition">+ useContext,</span>
  ReactSharedInternals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
};
</code></pre>
<h3 id="t31642.4 ReactContext.js">42.4 ReactContext.js <a href="#t31642.4 ReactContext.js"> # </a></h3>
<p>src\react\src\ReactContext.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { REACT_PROVIDER_TYPE, REACT_CONTEXT_TYPE } <span class="hljs-keyword">from</span> <span class="hljs-string">'shared/ReactSymbols'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createContext</span>(<span class="hljs-params">defaultValue</span>) </span>{
  <span class="hljs-keyword">const</span> context = {
    <span class="hljs-attr">$$typeof</span>: REACT_CONTEXT_TYPE,
    <span class="hljs-attr">_currentValue</span>: defaultValue,
    <span class="hljs-attr">Provider</span>: <span class="hljs-literal">null</span>
  };
  context.Provider = {
    <span class="hljs-attr">$$typeof</span>: REACT_PROVIDER_TYPE,
    <span class="hljs-attr">_context</span>: context
  };
  <span class="hljs-keyword">return</span> context;
}
</code></pre>
<h3 id="t31742.5 ReactHooks.js">42.5 ReactHooks.js <a href="#t31742.5 ReactHooks.js"> # </a></h3>
<p>src\react\src\ReactHooks.js</p>
<pre><code class="lang-diff">import ReactCurrentDispatcher from "./ReactCurrentDispatcher";

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  return dispatcher;
}

export function useReducer(reducer, initialArg, init) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

export function useState(initialState) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

export function useEffect(create, deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
export function useLayoutEffect(create, deps) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
export function useRef(initialValue) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
<span class="hljs-addition">+export function useContext(Context) {</span>
<span class="hljs-addition">+  const dispatcher = resolveDispatcher();</span>
<span class="hljs-addition">+  return dispatcher.useContext(Context);</span>
<span class="hljs-addition">+}</span>
</code></pre>
<h3 id="t31842.6 ReactFiber.js">42.6 ReactFiber.js <a href="#t31842.6 ReactFiber.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiber.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { HostRoot, IndeterminateComponent, HostComponent, HostText, ContextProvider } from "./ReactWorkTags";</span>
import { NoFlags } from "./ReactFiberFlags";
import { NoLanes } from './ReactFiberLane';
<span class="hljs-addition">+import { REACT_PROVIDER_TYPE } from 'shared/ReactSymbols';</span>

export function FiberNode(tag, pendingProps, key) {
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  this.return = null;
  this.child = null;
  this.sibling = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.alternate = null;

  this.index = 0;
  this.ref = null;
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
}
function createFiber(tag, pendingProps, key) {
  return new FiberNode(tag, pendingProps, key);
}
export function createHostRootFiber() {
  return createFiber(HostRoot, null, null);
}
// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
//我们使用双缓冲池技术，因为我们知道一棵树最多只需要两个版本
//我们将“其他”未使用的我们可以自由重用的节点
//这是延迟创建的，以避免分配从未更新的内容的额外对象。它还允许我们如果需要，回收额外的内存
export function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  if (workInProgress <span class="hljs-comment">=== null) {</span>
    workInProgress = createFiber(current.tag, pendingProps, current.key);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.flags = current.flags;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  return workInProgress;
}
export function createFiberFromTypeAndProps(type, key, pendingProps) {
  let fiberTag = IndeterminateComponent;
  if (typeof type <span class="hljs-comment">=== "string") {</span>
    fiberTag = HostComponent;
  } else {
<span class="hljs-addition">+   getTag: switch (type) {</span>
<span class="hljs-addition">+     default:</span>
<span class="hljs-addition">+       {</span>
<span class="hljs-addition">+         if (typeof type === 'object' &amp;&amp; type !== null) {</span>
<span class="hljs-addition">+           switch (type.$$typeof) {</span>
<span class="hljs-addition">+             case REACT_PROVIDER_TYPE:</span>
<span class="hljs-addition">+               fiberTag = ContextProvider;</span>
<span class="hljs-addition">+               break getTag;</span>
<span class="hljs-addition">+             default:</span>
<span class="hljs-addition">+               break;</span>
<span class="hljs-addition">+           }</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+       }</span>
<span class="hljs-addition">+   }</span>
  }
  const fiber = createFiber(fiberTag, pendingProps, key);
  fiber.type = type;
  return fiber;
}
export function createFiberFromElement(element) {
  const { type } = element;
  const { key } = element;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(type, key, pendingProps);
  return fiber;
}

export function createFiberFromText(content) {
  const fiber = createFiber(HostText, content, null);
  return fiber;
}
</code></pre>
<h3 id="t31942.7 ReactFiberBeginWork.js">42.7 ReactFiberBeginWork.js <a href="#t31942.7 ReactFiberBeginWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberBeginWork.js</p>
<pre><code class="lang-diff">import {
  HostRoot, HostComponent, HostText, IndeterminateComponent,
<span class="hljs-addition">+ FunctionComponent, ContextProvider</span>
} from "./ReactWorkTags";
import { processUpdateQueue, cloneUpdateQueue } from "./ReactFiberClassUpdateQueue";
import { mountChildFibers, reconcileChildFibers } from "./ReactChildFiber";
import { shouldSetTextContent } from "react-dom-bindings/src/client/ReactDOMHostConfig";
import { renderWithHooks } from "react-reconciler/src/ReactFiberHooks";
import { NoLanes } from './ReactFiberLane';
<span class="hljs-addition">+import { pushProvider } from './ReactFiberNewContext';</span>

function reconcileChildren(current, workInProgress, nextChildren) {
  if (current <span class="hljs-comment">=== null) {</span>
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
function updateHostRoot(current, workInProgress, renderLanes) {
  const nextProps = workInProgress.pendingProps;
  cloneUpdateQueue(current, workInProgress);
  processUpdateQueue(workInProgress, nextProps, renderLanes)
  const nextState = workInProgress.memoizedState;
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function updateHostComponent(current, workInProgress) {
  const { type } = workInProgress;
  const nextProps = workInProgress.pendingProps;
  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
function mountIndeterminateComponent(_current, workInProgress, Component) {
  const props = workInProgress.pendingProps;
  const value = renderWithHooks(null, workInProgress, Component, props);
  workInProgress.tag = FunctionComponent;
  reconcileChildren(null, workInProgress, value);
  return workInProgress.child;
}
function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
  const nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, renderLanes);
  reconcileChildren(current, workInProgress, nextChildren);
  return workInProgress.child;
}
export function beginWork(current, workInProgress, renderLanes) {
  workInProgress.lanes = NoLanes;
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
    }
    case FunctionComponent: {
      const Component = workInProgress.type;
      const resolvedProps = workInProgress.pendingProps;
      return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);
    }
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
      return null;
<span class="hljs-addition">+   case ContextProvider:</span>
<span class="hljs-addition">+     return updateContextProvider(current, workInProgress, renderLanes);</span>
    default:
      return null;
  }
}

<span class="hljs-addition">+function updateContextProvider(current, workInProgress, renderLanes) {</span>
<span class="hljs-addition">+  const providerType = workInProgress.type;</span>
<span class="hljs-addition">+  const context = providerType._context;</span>
<span class="hljs-addition">+  const newProps = workInProgress.pendingProps;</span>
<span class="hljs-addition">+  const newValue = newProps.value;</span>
<span class="hljs-addition">+  pushProvider(context, newValue);</span>
<span class="hljs-addition">+  const newChildren = newProps.children;</span>
<span class="hljs-addition">+  reconcileChildren(current, workInProgress, newChildren, renderLanes);</span>
<span class="hljs-addition">+  return workInProgress.child;</span>
<span class="hljs-addition">+}</span>

</code></pre>
<h3 id="t32042.8 ReactFiberCompleteWork.js">42.8 ReactFiberCompleteWork.js <a href="#t32042.8 ReactFiberCompleteWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCompleteWork.js</p>
<pre><code class="lang-diff">import {
  appendInitialChild,
  createInstance,
  createTextInstance,
  finalizeInitialChildren,
  prepareUpdate,
} from "react-dom-bindings/src/client/ReactDOMHostConfig";
<span class="hljs-addition">+import { HostComponent, HostRoot, HostText, FunctionComponent, ContextProvider } from "./ReactWorkTags";</span>
import { Ref, NoFlags, Update } from "./ReactFiberFlags";
import { NoLanes, mergeLanes } from './ReactFiberLane';

function markRef(workInProgress) {
  workInProgress.flags |= Ref;
}

function bubbleProperties(completedWork) {
  let newChildLanes = NoLanes;
  let subtreeFlags = NoFlags;
  let child = completedWork.child;
  while (child !== null) {
    newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child = child.sibling;
  }
  completedWork.childLanes = newChildLanes;
  completedWork.subtreeFlags |= subtreeFlags;
}

function appendAllChildren(parent, workInProgress) {
  // 我们只有创建的顶级fiber，但需要递归其子节点来查找所有终端节点
  let node = workInProgress.child;
  while (node !== null) {
    // 如果是原生节点，直接添加到父节点上
    if (node.tag <span class="hljs-comment">=== HostComponent || node.tag === HostText) {</span>
      appendInitialChild(parent, node.stateNode);
      // 再看看第一个节节点是不是原生节点
    } else if (node.child !== null) {
      // node.child.return = node
      node = node.child;
      continue;
    }
    if (node <span class="hljs-comment">=== workInProgress) {</span>
      return;
    }
    // 如果没有弟弟就找父亲的弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      // 如果找到了根节点或者回到了原节点结束
      if (node.return <span class="hljs-comment">=== null || node.return === workInProgress) {</span>
        return;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    // 下一个弟弟节点
    node = node.sibling;
  }
}
function markUpdate(workInProgress) {
  workInProgress.flags |= Update;
}
function updateHostComponent(current, workInProgress, type, newProps) {
  const oldProps = current.memoizedProps;
  const instance = workInProgress.stateNode;
  const updatePayload = prepareUpdate(instance, type, oldProps, newProps);
  workInProgress.updateQueue = updatePayload;
  if (updatePayload) {
    markUpdate(workInProgress);
  }
}
export function completeWork(current, workInProgress) {
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case HostComponent: {
      const { type } = workInProgress;
      if (current !== null &amp;&amp; workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress, type, newProps);
        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      } else {
        const instance = createInstance(type, newProps, workInProgress);
        appendAllChildren(instance, workInProgress);
        workInProgress.stateNode = instance;
        finalizeInitialChildren(instance, type, newProps);
        if (workInProgress.ref !== null) {
          markRef(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    case FunctionComponent:
      bubbleProperties(workInProgress);
      break;
    case HostRoot:
      bubbleProperties(workInProgress);
      break;
    case HostText: {
      const newText = newProps;
      workInProgress.stateNode = createTextInstance(newText);
      bubbleProperties(workInProgress);
      break;
    }
<span class="hljs-addition">+   case ContextProvider: {</span>
<span class="hljs-addition">+     bubbleProperties(workInProgress);</span>
<span class="hljs-addition">+     break;</span>
<span class="hljs-addition">+   }</span>
    default:
      break;
  }
}
</code></pre>
<h3 id="t32142.9 ReactFiberCommitWork.js">42.9 ReactFiberCommitWork.js <a href="#t32142.9 ReactFiberCommitWork.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberCommitWork.js</p>
<pre><code class="lang-diff"><span class="hljs-addition">+import { HostRoot, HostComponent, HostText, FunctionComponent, ContextProvider } from "./ReactWorkTags";</span>
import { Passive, MutationMask, Placement, Update, LayoutMask, Ref } from "./ReactFiberFlags";
import { insertBefore, appendChild, commitUpdate, removeChild } from "react-dom-bindings/src/client/ReactDOMHostConfig";
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from "./ReactHookEffectTags";

export function commitMutationEffects(finishedWork, root) {
  commitMutationEffectsOnFiber(finishedWork, root);
}
export function commitPassiveUnmountEffects(finishedWork) {
  commitPassiveUnmountOnFiber(finishedWork);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      if (finishedWork.flags &amp; Passive) {
        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive | HookHasEffect);
      }
      break;
    }
    default: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    }
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveUnmountOnFiber(child);
      child = child.sibling;
    }
  }
}
function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
  commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
}

function commitHookEffectListUnmount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const destroy = effect.destroy;
        effect.destroy = undefined;
        if (destroy !== undefined) {
          destroy();
        }
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

export function commitPassiveMountEffects(root, finishedWork) {
  commitPassiveMountOnFiber(root, finishedWork);
}
function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      if (flags &amp; Passive) {
        commitHookPassiveMountEffects(finishedWork, HookPassive | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function commitHookPassiveMountEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}
function commitHookEffectListMount(flags, finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      if ((effect.tag &amp; flags) <span class="hljs-comment">=== flags) {</span>
        const create = effect.create;
        effect.destroy = create();
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
function recursivelyTraversePassiveMountEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; Passive) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveMountOnFiber(root, child);
      child = child.sibling;
    }
  }
}
let hostParent = null;
function commitDeletionEffects(root, returnFiber, deletedFiber) {
  let parent = returnFiber;
  findParent: while (parent !== null) {
    switch (parent.tag) {
      case HostComponent: {
        hostParent = parent.stateNode;
        break findParent;
      }
      case HostRoot: {
        hostParent = parent.stateNode.containerInfo;
        break findParent;
      }
      default:
        break;
    }
    parent = parent.return;
  }
  commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
  hostParent = null;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  switch (deletedFiber.tag) {
    case HostComponent:
    case HostText: {
      recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      if (hostParent !== null) {
        removeChild(hostParent, deletedFiber.stateNode);
      }
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  let child = parent.child;
  while (child !== null) {
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
    child = child.sibling;
  }
}
function recursivelyTraverseMutationEffects(root, parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i &lt; deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }
  if (parentFiber.subtreeFlags &amp; MutationMask) {
    let { child } = parentFiber;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
}
function isHostParent(fiber) {
  return fiber.tag <span class="hljs-comment">=== HostComponent || fiber.tag === HostRoot;</span>
}
function getHostParentFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  return parent;
}
function insertOrAppendPlacementNode(node, before, parent) {
  const { tag } = node;
  const isHost = tag <span class="hljs-comment">=== HostComponent || tag === HostText;</span>
  if (isHost) {
    const { stateNode } = node;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else {
    const { child } = node;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let { sibling } = child;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    // 如果我们没有找到任何东西，让我们试试下一个弟弟
    while (node.sibling <span class="hljs-comment">=== null) {</span>
      if (node.return <span class="hljs-comment">=== null || isHostParent(node.return)) {</span>
        // 如果我们是根Fiber或者父亲是原生节点，我们就是最后的弟弟
        return null;
      }
      node = node.return;
    }
    // node.sibling.return = node.return
    node = node.sibling;
    while (node.tag !== HostComponent &amp;&amp; node.tag !== HostText) {
      // 如果它不是原生节点，并且，我们可能在其中有一个原生节点
      // 试着向下搜索，直到找到为止
      if (node.flags &amp; Placement) {
        // 如果我们没有孩子，可以试试弟弟
        continue siblings;
      } else {
        // node.child.return = node
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.
    // 检查此原生节点是否稳定可以放置
    if (!(node.flags &amp; Placement)) {
      // 找到它了!
      return node.stateNode;
    }
  }
}
function commitPlacement(finishedWork) {
  const parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent = parentFiber.stateNode;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    case HostRoot: {
      const parent = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    default:
      break;
  }
}
function commitReconciliationEffects(finishedWork) {
  const { flags } = finishedWork;
  if (flags &amp; Placement) {
    commitPlacement(finishedWork);
    finishedWork.flags &amp;= ~Placement;
  }
}
export function commitMutationEffectsOnFiber(finishedWork, root) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostRoot: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
    case FunctionComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Update) {
        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);
      }
      break;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags &amp; Ref) {
        commitAttachRef(finishedWork);
      }
      if (flags &amp; Update) {
        const instance = finishedWork.stateNode;
        if (instance != null) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current !== null ? current.memoizedProps : newProps;
          const type = finishedWork.type;
          const updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
      }

      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    }
<span class="hljs-addition">+   case ContextProvider: {</span>
<span class="hljs-addition">+     recursivelyTraverseMutationEffects(root, finishedWork);</span>
<span class="hljs-addition">+     commitReconciliationEffects(finishedWork);</span>
<span class="hljs-addition">+     break;</span>
    }
    default: {
      break;
    }
  }
}
function commitAttachRef(finishedWork) {
  const ref = finishedWork.ref;
  if (ref !== null) {
    const instance = finishedWork.stateNode;
    if (typeof ref <span class="hljs-comment">=== "function") {</span>
      ref(instance)
    } else {
      ref.current = instance;
    }
  }
}
export function commitLayoutEffects(finishedWork, root) {
  const current = finishedWork.alternate;
  commitLayoutEffectOnFiber(root, current, finishedWork);
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent: {
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags &amp; Update) {
        commitHookLayoutEffects(finishedWork, HookLayout | HookHasEffect);
      }
      break;
    }
    case HostRoot: {
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    }
    default:
      break;
  }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags &amp; LayoutMask) {
    let child = parentFiber.child;
    while (child !== null) {
      const current = child.alternate;
      commitLayoutEffectOnFiber(root, current, child);
      child = child.sibling;
    }
  }
}
function commitHookLayoutEffects(finishedWork, hookFlags) {
  commitHookEffectListMount(hookFlags, finishedWork);
}

</code></pre>
<h3 id="t32242.10 ReactFiberHooks.js">42.10 ReactFiberHooks.js <a href="#t32242.10 ReactFiberHooks.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberHooks.js</p>
<pre><code class="lang-diff">import ReactSharedInternals from "shared/ReactSharedInternals";
import { enqueueConcurrentHookUpdate } from "./ReactFiberConcurrentUpdates";
import { scheduleUpdateOnFiber, requestUpdateLane, requestEventTime } from "./ReactFiberWorkLoop";
import is from "shared/objectIs";
import { Passive as PassiveEffect, Update as UpdateEffect } from "./ReactFiberFlags";
import { HasEffect as HookHasEffect, Passive as HookPassive, Layout as HookLayout } from "./ReactHookEffectTags";
import { NoLanes, NoLane, mergeLanes, isSubsetOfLanes } from './ReactFiberLane';
<span class="hljs-addition">+import { readContext } from './ReactFiberNewContext';</span>

const { ReactCurrentDispatcher } = ReactSharedInternals;
let currentlyRenderingFiber = null;
let workInProgressHook = null;
let currentHook = null;
let renderLanes = NoLanes;

const HooksDispatcherOnMountInDEV = {
  useReducer: mountReducer,
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
  useRef: mountRef,
<span class="hljs-addition">+ useContext: readContext</span>
};
const HooksDispatcherOnUpdateInDEV = {
  useReducer: updateReducer,
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  useRef: updateRef,
<span class="hljs-addition">+ useContext: readContext</span>
};
function mountRef(initialValue) {
  const hook = mountWorkInProgressHook();
  const ref = {
    current: initialValue,
  };
  hook.memoizedState = ref;
  return ref;
}
function updateRef() {
  const hook = updateWorkInProgressHook();
  return hook.memoizedState;
}
export function useLayoutEffect(reducer, initialArg) {
  return ReactCurrentDispatcher.current.useLayoutEffect(reducer, initialArg);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);
}
function mountLayoutEffect(create, deps) {
  const fiberFlags = UpdateEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  let destroy;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps);
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps <span class="hljs-comment">=== null) {</span>
    return false;
  }
  for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }

  return true;
}
function mountEffect(create, deps) {
  return mountEffectImpl(PassiveEffect, HookPassive, create, deps);
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps <span class="hljs-comment">=== undefined ? null : deps;</span>
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue <span class="hljs-comment">=== null) {</span>
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect <span class="hljs-comment">=== null) {</span>
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
  };
}
function basicStateReducer(state, action) {
  return typeof action <span class="hljs-comment">=== "function" ? action(state) : action;</span>
}
function mountReducer(reducer, initialArg) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialArg;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: initialArg
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  let baseQueue = current.baseQueue;
  const pendingQueue = queue.pending;
  if (pendingQueue !== null) {
    if (baseQueue !== null) {
      const baseFirst = baseQueue.next;
      const pendingFirst = pendingQueue.next;
      baseQueue.next = pendingFirst;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  if (baseQueue !== null) {
    printQueue(baseQueue)
    const first = baseQueue.next;
    let newState = current.baseState;
    let newBaseState = null;
    let newBaseQueueFirst = null;
    let newBaseQueueLast = null;
    let update = first;
    do {
      const updateLane = update.lane;
      const shouldSkipUpdate = !isSubsetOfLanes(renderLanes, updateLane);
      if (shouldSkipUpdate) {
        const clone = {
          lane: updateLane,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null,
        };
        if (newBaseQueueLast <span class="hljs-comment">=== null) {</span>
          newBaseQueueFirst = newBaseQueueLast = clone;
          newBaseState = newState;
        } else {
          newBaseQueueLast = newBaseQueueLast.next = clone;
        }
        currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, updateLane);
      } else {
        if (newBaseQueueLast !== null) {
          const clone = {
            lane: NoLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null,
          };
          newBaseQueueLast = newBaseQueueLast.next = clone;
        }
        if (update.hasEagerState) {
          newState = update.eagerState;
        } else {
          const action = update.action;
          newState = reducer(newState, action);
        }
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
    if (newBaseQueueLast <span class="hljs-comment">=== null) {</span>
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = newBaseQueueFirst;
    }
    hook.memoizedState = newState;
    hook.baseState = newBaseState;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = newState;
  }
  if (baseQueue <span class="hljs-comment">=== null) {</span>
    queue.lanes = NoLanes;
  }
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = initialState;
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
  return [hook.memoizedState, dispatch];
}
function dispatchSetState(fiber, queue, action) {
  const lane = requestUpdateLane(fiber);
  const update = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  const alternate = fiber.alternate;
  if (fiber.lanes <span class="hljs-comment">=== NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) {</span>
    const lastRenderedReducer = queue.lastRenderedReducer;
    const currentState = queue.lastRenderedState;
    const eagerState = lastRenderedReducer(currentState, action);
    update.hasEagerState = true;
    update.eagerState = eagerState;
    if (is(eagerState, currentState)) {
      return;
    }
  }
  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
  const eventTime = requestEventTime();
  scheduleUpdateOnFiber(root, fiber, lane, eventTime);
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    queue: null,
    next: null,
    baseState: null,
    baseQueue: null,
  };
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function dispatchReducerAction(fiber, queue, action) {
  const update = {
    action,
    next: null,
  };
  const root = enqueueConcurrentHookUpdate(fiber, queue, update);
  scheduleUpdateOnFiber(root, fiber);
}

function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook <span class="hljs-comment">=== null) {</span>
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook;
  if (workInProgressHook <span class="hljs-comment">=== null) {</span>
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      queue: currentHook.queue,
      next: null,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
    };
    if (workInProgressHook <span class="hljs-comment">=== null) {</span>
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}

export function renderWithHooks(current, workInProgress, Component, props, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  workInProgress.updateQueue = null;
  workInProgress.memoizedState = null;
  if (current !== null &amp;&amp; current.memoizedState !== null) {
    ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
  } else {
    ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
  }
  const children = Component(props);
  currentlyRenderingFiber = null;
  workInProgressHook = null;
  currentHook = null;
  renderLanes = NoLanes;
  return children;
}

function printQueue(queue) {
  const first = queue.next;
  let desc = '';
  let update = first;
  do {
    desc += ("=&gt;" + (update.action.id));
    update = update.next;
  } while (update !== null &amp;&amp; update !== first);
  desc += "=&gt;null";
  console.log(desc);
}
</code></pre>
<h3 id="t32342.11 ReactFiberNewContext.js">42.11 ReactFiberNewContext.js <a href="#t32342.11 ReactFiberNewContext.js"> # </a></h3>
<p>src\react-reconciler\src\ReactFiberNewContext.js</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushProvider</span>(<span class="hljs-params">context, nextValue</span>) </span>{
  context._currentValue = nextValue;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readContext</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> context._currentValue;
}
</code></pre>
<h3 id="t32442.12 ReactWorkTags.js">42.12 ReactWorkTags.js <a href="#t32442.12 ReactWorkTags.js"> # </a></h3>
<p>src\react-reconciler\src\ReactWorkTags.js</p>
<pre><code class="lang-diff">export const FunctionComponent = 0;
export const IndeterminateComponent = 2;
export const HostRoot = 3;
export const HostComponent = 5;
export const HostText = 6;
<span class="hljs-addition">+export const ContextProvider = 10;</span>
</code></pre>
<h3 id="t32542.13 ReactSymbols.js">42.13 ReactSymbols.js <a href="#t32542.13 ReactSymbols.js"> # </a></h3>
<p>src\shared\ReactSymbols.js</p>
<pre><code class="lang-diff">export const REACT_ELEMENT_TYPE = Symbol.for("react.element");
<span class="hljs-addition">+export const REACT_PROVIDER_TYPE = Symbol.for('react.provider');</span>
<span class="hljs-addition">+export const REACT_CONTEXT_TYPE = Symbol.for('react.context');</span>
</code></pre>

    </div>
  </div>
  <div class="modal fade" id="loginModal" tabindex="-1" role="dialog" aria-labelledby="loginModalLabel">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
          <h4 class="modal-title" id="loginModalLabel">请登录</h4>
        </div>
        <div class="modal-body">
          <form>
            <div class="form-group">
              <label for="username" class="control-label">姓名:</label>
              <input type="text" class="form-control" id="username" placeholder="珠峰架构VIP会员系统用户名">
            </div>
            <div class="form-group">
              <label for="password" class="control-label">密码:</label>
              <input type="text" class="form-control" id="password" placeholder="珠峰架构VIP会员系统密码">
            </div>
          </form>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">登录</button>
        </div>
      </div>
    </div>
  </div>
  <script src="https://static.zhufengpeixun.com/jquerymin_1645176580555.js"></script>
  <script src="https://static.zhufengpeixun.com/bootstrapmin_1645176554753.js"></script>
  <script>
  </script>
  <script>
$('.warpper .page-toc ul ul li a').on('click',function(){
  $('.warpper .page-toc ul ul li a').removeClass('my-active')
  $(this).addClass('my-active')
})
$('.logo').on('mouseenter',function(){
  $('.nav').height('450px');
})
$('.nav').on('mouseleave',function(){
  $('.nav').height('80px');
})
$('.logo').on('click',function(){
  // $(".nav").css("display", "none");
 $('.warpper').css('padding','0px');
})
</script><script type="text/javascript" src="../static/js/theme.js"></script>


</body></html>
